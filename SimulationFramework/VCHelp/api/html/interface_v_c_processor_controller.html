<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VisualCommander: VCProcessorController Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>VCProcessorController Class Reference<br/>
<small>
[<a class="el" href="group__processorplugin.html">Processor Plugins</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="VCProcessorController" --><!-- doxytag: inherits="VCDataConsumerController" -->
<p>Superclass for all Processor plugins. Users writing Procesors should subclass from this directly, not from <a class="el" href="interface_v_c_data_consumer_controller.html" title="Primary client plugin class for the development of Displays and Processors. Do not subclass directly...">VCDataConsumerController</a>.  
<a href="#_details">More...</a></p>
<!-- startSectionHeader --><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png"/> Inheritance diagram for VCProcessorController:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><div id="dynsection-0-summary" class="dynsummary" style="display:block;">
<!-- endSectionSummary --></div>
<!-- startSectionContent --><div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="interface_v_c_processor_controller.png" usemap="#VCProcessorController_map" alt=""/>
  <map id="VCProcessorController_map" name="VCProcessorController_map">
<area href="interface_v_c_data_consumer_controller.html" alt="VCDataConsumerController" shape="rect" coords="0,0,169,24"/>
</map>
 </div><!-- endSectionContent --></div>

<p><a href="class_v_c_processor_controller-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Data Consumer Lifecycle - Override</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(id)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ab5b46fdf20ab81f99d3224c8fa80c590">initWithEntity:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard data consumer initializer.  <a href="#ab5b46fdf20ab81f99d3224c8fa80c590"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a7170639e0a7d675135a0cdf8eae98e6b">invalidated</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data consumer teardown prior to dealloc.  <a href="#a7170639e0a7d675135a0cdf8eae98e6b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility Methods</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSNib *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ab22c59a9b3796f25b858890e472ed4aa">loadNibWithName:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a nib from the plugin's bundle, or return the pre-loaded nib.  <a href="#ab22c59a9b3796f25b858890e472ed4aa"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Configuration</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are called by VisualCommander to handle configuration of the data consumer. At a minimum, configurationWindow and configurationDoneButton should be overridden if the data consumer allows configuration (alternately, configureInWindow: may be overridden; see its detailed documentation for specifics). </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ab1031b3cdb88cbb139f2c697465a8edf">configurationNibName</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the name of a nib that should be loaded prior to attempting to configure the data consumer.  <a href="#ab1031b3cdb88cbb139f2c697465a8edf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSWindow *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#afc6033c5bee0a06e1288f9262f03cf35">configurationWindow</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the configuration window to be displayed at user request.  <a href="#afc6033c5bee0a06e1288f9262f03cf35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSButton *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a5dd955d0f2c267e30adc25628fad9789">configurationDoneButton</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the button in the configuration window that should be used to end configuration of the data consumer and dismiss the configuration window.  <a href="#a5dd955d0f2c267e30adc25628fad9789"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#aa4d70a7b3c1cd0811169649f8dc2c504">configurationNibHasLoaded</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the configuration nib provided by configurationNibName has been automatically loaded.  <a href="#aa4d70a7b3c1cd0811169649f8dc2c504"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a7a999f19b09ea6ac9e96e448cc63dcf0">configurationBeginning</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just before the configuration sheet is shown.  <a href="#a7a999f19b09ea6ac9e96e448cc63dcf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ae41115090f14503a4c0ab0c6a414ae2c">configurationEnded</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the button provided by configurationDoneButton has been clicked by the user.  <a href="#ae41115090f14503a4c0ab0c6a414ae2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a7a3e143c74572d7c1e1a63575e560efa">closeConfigurationWindow</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dismiss the configuration window if it's presently displayed.  <a href="#a7a3e143c74572d7c1e1a63575e560efa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#aa1ed45a3b0be57d41a2b47578d13cd23">configureInWindow:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the configuration window as a sheet in the requested window, or as a standalone window.  <a href="#aa1ed45a3b0be57d41a2b47578d13cd23"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Input Set Management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The inputs for a data consumer can be grouped into various input sets. These methods provide functionality to manage input sets, including the ability to create, delete sets, add look up sets. Input sets, just as with the data consumer controller's entity, can store arbitrary key-value pairs of configuration data. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a99531b72099e1d8a61ff5e0979535d1b">createInputSetWithName:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new input set.  <a href="#a99531b72099e1d8a61ff5e0979535d1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a0ac6c1fae47f725375f6a021dcafebe6">inputSetWithReferencePath:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the input set with the provided reference path.  <a href="#a0ac6c1fae47f725375f6a021dcafebe6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSSet *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ae45ae946a8edcae1c9f17b04f748a87e">inputSetsWithName:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the input sets with a specific name.  <a href="#ae45ae946a8edcae1c9f17b04f748a87e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSSet *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#aa750dfd45f5a63575ce3044fac072f7f">allInputSets</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the input sets at this data consumer.  <a href="#aa750dfd45f5a63575ce3044fac072f7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#abee9a4c43050559b581aa838d02d31cb">destroyInputSet:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an input set.  <a href="#abee9a4c43050559b581aa838d02d31cb"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Input Management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide functionality to manage inputs at the data consumer, including the ability to create, delete, and modify inputs. Inputs, just as with the data consumer controller's entity, can store arbitrary key-value pairs of configuration data. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a27571f7b2af320f7f83885eb6e9d9695">createInputWithName:inSet:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new input with the provided name and set.  <a href="#a27571f7b2af320f7f83885eb6e9d9695"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSSet *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a88f17496fd2a9ccd2b81be7c14aee4ef">inputsWithName:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all inputs with a matching name, regardless of the set that they're in.  <a href="#a88f17496fd2a9ccd2b81be7c14aee4ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSSet *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ae4593aea786a54c3977a4643145dc4d4">allInputs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all inputs at the data consumer.  <a href="#ae4593aea786a54c3977a4643145dc4d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSSet *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#abf00a3ed87237a8caf02b787570325ac">inputsWithName:inSet:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all inputs with a matching name in a specific input set.  <a href="#abf00a3ed87237a8caf02b787570325ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ac4c4765f53c180b41443b9309a38d307">inputWithName:inSet:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a single input that matches the name, input set criteria.  <a href="#ac4c4765f53c180b41443b9309a38d307"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSSet *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a038becd5c159df36e5c3b8a90da2f050">allInputsInSet:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all inputs in the given set.  <a href="#a038becd5c159df36e5c3b8a90da2f050"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a9013525efae7822a98049b3bee3cfa32">anyInput</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a single input from the data consumer.  <a href="#a9013525efae7822a98049b3bee3cfa32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_input_element.html">VCInputElement</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a5598209ff96c851f9514742ec91e5a0a">inputElementForElementPath:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an input element based on its path.  <a href="#a5598209ff96c851f9514742ec91e5a0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a292596ad8f4d1d2f0347b1c8250917ae">allInputsConnected</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if all inputs currently return YES to isConnected.  <a href="#a292596ad8f4d1d2f0347b1c8250917ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_value.html">VCValue</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#aee09994fb9b8542326056222de9dca60">currentValueForInputWithName:inSet:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current value for an input with the given name and input set.  <a href="#aee09994fb9b8542326056222de9dca60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a361f1e34c7a0448ffbd25210c047f9ed">destroyInput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an input.  <a href="#a361f1e34c7a0448ffbd25210c047f9ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a3280d3c607c818c2c6913cc565212c56">disconnectInput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The input to be disconnected.  <a href="#a3280d3c607c818c2c6913cc565212c56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a755646fe158c5a587d5fa21d8d07b7ef">placeInput:inSet:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the input set that an input is in.  <a href="#a755646fe158c5a587d5fa21d8d07b7ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a70665c89d3ff6f61a6944a59ab82c4c5">connectInput:withSource:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Programmatically connect an input to a specific source.  <a href="#a70665c89d3ff6f61a6944a59ab82c4c5"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Input Handling</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are called by VisualCommander in response to events involving inputs connected to this data consumer. They should be overridden as needed by subclasses to customize the data consumer's behavior. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a7ca7f3d1c746b5b38174546a19ba31e0">willAcceptSource:forInput:withTooltip:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether or not the provided data point will be accepted by this data consumer.  <a href="#a7ca7f3d1c746b5b38174546a19ba31e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a734790c29686228809b69c74f1871e05">inputForDataPoint:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the input that a data point should be connected to when the user has not specified.  <a href="#a734790c29686228809b69c74f1871e05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a7a740b72176ed28efe94643f8772e026">inputDidGainSource:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take any action necessary to respond to an input becoming connected.  <a href="#a7a740b72176ed28efe94643f8772e026"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a378d1d9e1d3472d92bba618f5fd633f2">inputDidLoseSource:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take any action necessary to respond to an input becoming disconnected.  <a href="#a378d1d9e1d3472d92bba618f5fd633f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#afb36d59c32fd7fb25be4636365ae62d9">inputDidBecomeActive:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take any action necessary to respond to an input becoming active.  <a href="#afb36d59c32fd7fb25be4636365ae62d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a6e4ce1195a9c44d007e708caaf01651a">inputDidBecomeInactive:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take any action necessary to respond to an input becoming inactive.  <a href="#a6e4ce1195a9c44d007e708caaf01651a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Command Outlet Management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide command outlet management functionality to the data consumer- creation, destruction, and lookup of command outlets.</p>
<p>Command outlets allow the data consumer to send data back sessions; individual commands at those sessions can have a wide variety of potential results. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a0d9094998310f66c0b2e689be7ed2a75">createCommandOutletWithName:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new command outlet.  <a href="#a0d9094998310f66c0b2e689be7ed2a75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSSet *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a6180becb21ce399e148c76c9c2de9739">commandOutletsWithName:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all command outlets with a specific name.  <a href="#a6180becb21ce399e148c76c9c2de9739"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ad1ed8f3f78be4a4a1139b80bda603810">commandOutletWithName:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a single command outlets with a specific name.  <a href="#ad1ed8f3f78be4a4a1139b80bda603810"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSSet *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a008b45d6dfca842bba5d2e98dfbf5e7b">allCommandOutlets</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the set of all command outlets.  <a href="#a008b45d6dfca842bba5d2e98dfbf5e7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#aa14770a9fe712de8003f5be53b1775cc">anyCommandOutlet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a single command outlet.  <a href="#aa14770a9fe712de8003f5be53b1775cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a3897344497493559244bb7e5f7718ee1">destroyCommandOutlet:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a command outlet and remove it from this data consumer.  <a href="#a3897344497493559244bb7e5f7718ee1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a9d933783eec84262461e8e42e45d23ed">disconnectCommandOutlet:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect a command outlet from its command.  <a href="#a9d933783eec84262461e8e42e45d23ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ade26f89a9ba4785fa11bb69b5610a554">connectOutlet:withCommand:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Programmatically connect a command outlet to a source command.  <a href="#ade26f89a9ba4785fa11bb69b5610a554"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Command Handling</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are called by VisualCommander in response to events involving commands connected to this data consumer. Subclasses should override these methods to provide custom handling of these events. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a9269d050c7eac76eff52db71229c3c9a">willAcceptCommand:forOutlet:withTooltip:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether or not a command can be connected to the specified command outlet.  <a href="#a9269d050c7eac76eff52db71229c3c9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a2fb0a8ef7003518fa6e783b12c7b630d">outletForCommand:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the most appropriate command outlet for a command.  <a href="#a2fb0a8ef7003518fa6e783b12c7b630d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ad9e34007880d3117188bee0e2df5bf98">outletDidGainCommand:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take any action necessary to respond to a command outlet becoming connected.  <a href="#ad9e34007880d3117188bee0e2df5bf98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#afed29ba7a99868a8995345ea7faa1702">outletDidLoseCommand:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take any action necessary to respond to a command outlet becoming disconnected.  <a href="#afed29ba7a99868a8995345ea7faa1702"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Output Management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide output related functionality to the data consumer- creation, destruction, and lookup of outputs. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_output.html">VCOutput</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ad989ecfec6f930cfd17f9a38d431d036">createOutputWithName:dataType:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new output with the specified name and data type.  <a href="#ad989ecfec6f930cfd17f9a38d431d036"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSSet *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a93909c3523e93816b1fd00e43b5ff76d">outputsWithName:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the set of outputs that matches the provided name.  <a href="#a93909c3523e93816b1fd00e43b5ff76d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSSet *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a5dc8b0b4e7e10200d47db41e7e3743d1">allOutputs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the set of all outputs at this data consumer.  <a href="#a5dc8b0b4e7e10200d47db41e7e3743d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#af3d8e425f88eb222b3df5c6c2d89a8b2">destroyOutput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an output object.  <a href="#af3d8e425f88eb222b3df5c6c2d89a8b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a875e35b9c72731899dfb180bacb833d7">notifyForNewData</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify any data consumers using this data consumer's outputs that new or changed data can now be computed.  <a href="#a875e35b9c72731899dfb180bacb833d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ab80f9cbf9348b413eff0afa226245952">setValue:forAttribute:ofOutput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an attribute for this output.  <a href="#ab80f9cbf9348b413eff0afa226245952"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(void)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a27c62a0e5118511846d2261263907b51">removeAttribute:fromOutput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an attribute from this output.  <a href="#a27c62a0e5118511846d2261263907b51"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Output Data Production</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are called by VisualCommander when other portions of the system need data from the outputs that this data consumer manages. They should be overridden by any data consumers that provide outputs. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_timestamp.html">VCTimestamp</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a13b6c5f35150e95264e69129d6a5a485">youngestDataTimestampForOutput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the youngest time for which data can be calculated.  <a href="#a13b6c5f35150e95264e69129d6a5a485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_timestamp.html">VCTimestamp</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#afc261be261fc2166094cde6363ee85c4">oldestDataTimestampForOutput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the oldest time for which data can be calculated.  <a href="#afc261be261fc2166094cde6363ee85c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_timestamp.html">VCTimestamp</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#af5e3d8e850b8ebd14ad9d4f878972527">currentTimestampForOutput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the current timestamp for data from an output.  <a href="#af5e3d8e850b8ebd14ad9d4f878972527"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_value.html">VCValue</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#ac3fa16be6012302d1f95b96d57c0267f">currentValueForOutput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the current value of an output.  <a href="#ac3fa16be6012302d1f95b96d57c0267f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(<a class="el" href="interface_v_c_value.html">VCValue</a> *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#aa832912257d215fb105f0cc02c104ab7">valueAtTime:forOutput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value of an output at a specific time.  <a href="#aa832912257d215fb105f0cc02c104ab7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSArray *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a66372e372b81700b7f51c6b0e1a3b746">count:fromTime:to:forOutput:</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a set of calculated values for an output, evenly distributed between two timestamps.  <a href="#a66372e372b81700b7f51c6b0e1a3b746"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Plugin Help</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are called by VisualCommander to facilitate providing help documentation to the user for this plugin. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a6846948beba3485dd0b88c8779c81d00">pathToHelpFile</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a path to a help file for this plugin.  <a href="#a6846948beba3485dd0b88c8779c81d00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_v_c_data_consumer_controller.html#a2a35ea58550454d0bcb6b4b3bf55136d">hasHelp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether or not help is available for this plugin.  <a href="#a2a35ea58550454d0bcb6b4b3bf55136d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Plugin Information</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide information about the data consumer plugin. Subclasses should override them to return appropriate values. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(BOOL)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_v_c_data_consumer_controller.html#a56ff8d2237b85f0bf1207b4e32339607">storesPerElementConfiguration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses should override this method if they need to store configuration for every element of matrix inputs (ie, line color for a plot)  <a href="#a56ff8d2237b85f0bf1207b4e32339607"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_v_c_data_consumer_controller.html#a05e4048ea3085501320d26e7683ae814">name</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a name for this plugin.  <a href="#a05e4048ea3085501320d26e7683ae814"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_v_c_data_consumer_controller.html#a55e9e9e561a0a8b31bd2b667cc528811">tooltip</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a tooltip describing the plugin.  <a href="#a55e9e9e561a0a8b31bd2b667cc528811"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSString *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_v_c_data_consumer_controller.html#a06c312203f9279fd4da89c483528464a">category</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the category into which the plugin should be organized for display.  <a href="#a06c312203f9279fd4da89c483528464a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">(NSDictionary *)&#160;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_v_c_data_consumer_controller.html#af240baf4c4ce31b8f202a1bab830fe3c">consumerDefaults</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide default values to be stored into the data consumer's entity.  <a href="#af240baf4c4ce31b8f202a1bab830fe3c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="interface_v_c_processor_controller.html" title="Superclass for all Processor plugins. Users writing Procesors should subclass from this directly...">VCProcessorController</a> provides default implementations of some methods useful to Processors. There is no additional user-visible functionality unique to Processors; please see <a class="el" href="interface_v_c_data_consumer_controller.html" title="Primary client plugin class for the development of Displays and Processors. Do not subclass directly...">VCDataConsumerController</a> for general data consumer documentation, as that documentation also applies to Processors. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a008b45d6dfca842bba5d2e98dfbf5e7b"></a><!-- doxytag: member="VCProcessorController::allCommandOutlets" ref="a008b45d6dfca842bba5d2e98dfbf5e7b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) allCommandOutlets </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve a set containing all command outlets at this data consumer </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The set of all command outlets </dd></dl>

</div>
</div>
<a class="anchor" id="ae4593aea786a54c3977a4643145dc4d4"></a><!-- doxytag: member="VCProcessorController::allInputs" ref="ae4593aea786a54c3977a4643145dc4d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) allInputs </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve a set containing all inputs at the data consumer </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A set with all inputs </dd></dl>

</div>
</div>
<a class="anchor" id="a292596ad8f4d1d2f0347b1c8250917ae"></a><!-- doxytag: member="VCProcessorController::allInputsConnected" ref="a292596ad8f4d1d2f0347b1c8250917ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) allInputsConnected </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check to see if all inputs are currently connected- that is, all inputs return YES for the isConnected property. This method is often useful for determining whether or not the data consumer has the data it needs to work properly. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>YES if all inputs return YES to isConnected; NO if any of them return NO. </dd></dl>

</div>
</div>
<a class="anchor" id="aa750dfd45f5a63575ce3044fac072f7f"></a><!-- doxytag: member="VCProcessorController::allInputSets" ref="aa750dfd45f5a63575ce3044fac072f7f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) allInputSets </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve all input sets at this data consumer </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A set containing all input sets at this data consumer </dd></dl>

</div>
</div>
<a class="anchor" id="a038becd5c159df36e5c3b8a90da2f050"></a><!-- doxytag: member="VCProcessorController::allInputsInSet:" ref="a038becd5c159df36e5c3b8a90da2f050" args="(VCInputSet *inputSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) allInputsInSet: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *)&#160;</td>
          <td class="paramname"> <em>inputSet</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve all inputs in the provided input set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inputSet</td><td>The for which inputs should be returned, or nil to retrieve all inputs that are not in an input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The set of matching inputs. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dc8b0b4e7e10200d47db41e7e3743d1"></a><!-- doxytag: member="VCProcessorController::allOutputs" ref="a5dc8b0b4e7e10200d47db41e7e3743d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) allOutputs </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve a set containing all outputs at this data consumer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The set of all outputs at this data consumer. </dd></dl>

</div>
</div>
<a class="anchor" id="aa14770a9fe712de8003f5be53b1775cc"></a><!-- doxytag: member="VCProcessorController::anyCommandOutlet" ref="aa14770a9fe712de8003f5be53b1775cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *) anyCommandOutlet </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve a single command outlet connected to this data consumer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A command outlet connected to this data consumer. If this data consumer has no command outlets, nil is returned. If this data consumer has more than one command outlet, one will be chosen in a nondeterministic fashion and returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a9013525efae7822a98049b3bee3cfa32"></a><!-- doxytag: member="VCProcessorController::anyInput" ref="a9013525efae7822a98049b3bee3cfa32" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_input.html">VCInput</a> *) anyInput </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve a single input attached to this data consumer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>eturns a single <a class="el" href="interface_v_c_input.html" title="Represents a single source of data used by a data consumer.">VCInput</a> attached to this data consumer. If no inputs exist, returns nil. If more than one input exists, one of them will be chosen in a nondeterministic fashion. </dd></dl>

</div>
</div>
<a class="anchor" id="a06c312203f9279fd4da89c483528464a"></a><!-- doxytag: member="VCProcessorController::category" ref="a06c312203f9279fd4da89c483528464a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString *) category </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide an optional category for this plugin. Plugins that return the same category will be grouped together in the tools palette. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The category, or nil to be placed in the General category. The default implementation returns nil. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a3e143c74572d7c1e1a63575e560efa"></a><!-- doxytag: member="VCProcessorController::closeConfigurationWindow" ref="a7a3e143c74572d7c1e1a63575e560efa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) closeConfigurationWindow </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Hide (either as a sheet or as a standard window) the configuration window provided by configurationWindow, and then call configurationEnded. </p>

</div>
</div>
<a class="anchor" id="a6180becb21ce399e148c76c9c2de9739"></a><!-- doxytag: member="VCProcessorController::commandOutletsWithName:" ref="a6180becb21ce399e148c76c9c2de9739" args="(NSString *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) commandOutletsWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve a set of all command outlets that have a specific name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A set containing the matching command outlets. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1ed8f3f78be4a4a1139b80bda603810"></a><!-- doxytag: member="VCProcessorController::commandOutletWithName:" ref="ad1ed8f3f78be4a4a1139b80bda603810" args="(NSString *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *) commandOutletWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a single command outlet with the given name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If no outlets with that name exist, returns nil. If more than one outlet with that name exists, one of them will be chosen in a nondeterministic fashion. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a999f19b09ea6ac9e96e448cc63dcf0"></a><!-- doxytag: member="VCProcessorController::configurationBeginning" ref="a7a999f19b09ea6ac9e96e448cc63dcf0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) configurationBeginning </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by configureInWindow just before the configuration sheet is shown. The configuration sheet is not yet showing when this is called.</p>
<p>If configureInWindow is overridden, this function is not necessary. </p>

</div>
</div>
<a class="anchor" id="a5dd955d0f2c267e30adc25628fad9789"></a><!-- doxytag: member="VCProcessorController::configurationDoneButton" ref="a5dd955d0f2c267e30adc25628fad9789" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSButton *) configurationDoneButton </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When the default implementation of -(void)<a class="el" href="interface_v_c_data_consumer_controller.html#aa1ed45a3b0be57d41a2b47578d13cd23" title="Display the configuration window as a sheet in the requested window, or as a standalone window...">configureInWindow:</a>window is used, the button provided as the return value to this function has its target and action changed to inform the data consumer controller that configuration is over and cause the configureInWindow to dismiss the configuration window.</p>
<p>If configureInWindow is overridden, this function is not necessary.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The button to use to indicate configuration completion, or nil if no such button exists. The default implementation returns nil. </dd></dl>

</div>
</div>
<a class="anchor" id="ae41115090f14503a4c0ab0c6a414ae2c"></a><!-- doxytag: member="VCProcessorController::configurationEnded" ref="ae41115090f14503a4c0ab0c6a414ae2c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) configurationEnded </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After the default implementation of configureInWindow is notified that the user has clicked on the button returned from configurationDoneButton, the configuration window will be hidden and this function will be called to give the data consumer controller a chance to perform any post-configuration actions necessary.</p>
<p>If configureInWindow is overridden, this function is not necessary. </p>

</div>
</div>
<a class="anchor" id="aa4d70a7b3c1cd0811169649f8dc2c504"></a><!-- doxytag: member="VCProcessorController::configurationNibHasLoaded" ref="aa4d70a7b3c1cd0811169649f8dc2c504" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) configurationNibHasLoaded </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After the default implementation of configureInWindow automatically loads the configuration nib provided by configurationNibName, it will call this method to give the data consumer controller a chance to handle any post-load setup required. The default implementation does nothing.</p>
<p>If configureInWindow is overridden, this function is not necessary. </p>

</div>
</div>
<a class="anchor" id="ab1031b3cdb88cbb139f2c697465a8edf"></a><!-- doxytag: member="VCProcessorController::configurationNibName" ref="ab1031b3cdb88cbb139f2c697465a8edf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) configurationNibName </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VisualCommander provides support for loading configuration nibs on-demand for data consumer plugins. If this method is overridden to return the name of a nib available in the data consumer plugin's bundle, that nib will be loaded with the data consumer as the File's Owner if -(NSWindow *)configurationWindow returns nil; configurationWindow will then be called again to try to get the configuration window that should be shown.</p>
<p>If configureInWindow is overridden, this function is not necessary.</p>
<p>Please see the best practices note in the <a class="el" href="interface_v_c_data_consumer_controller.html" title="Primary client plugin class for the development of Displays and Processors. Do not subclass directly...">VCDataConsumerController</a> documentation related to nibs.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of the nib (without extension) to load when configuration is required, or nil if no nib should be loaded on demand. The default implementation returns nil. </dd></dl>

</div>
</div>
<a class="anchor" id="afc6033c5bee0a06e1288f9262f03cf35"></a><!-- doxytag: member="VCProcessorController::configurationWindow" ref="afc6033c5bee0a06e1288f9262f03cf35" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSWindow *) configurationWindow </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide a configuration window to be displayed when the user attempts to configure the data consumer.</p>
<p>If configureInWindow is overridden, this function is not necessary.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The window to be displayed, or nil if no configuration window is available. The default implementation returns nil. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1ed45a3b0be57d41a2b47578d13cd23"></a><!-- doxytag: member="VCProcessorController::configureInWindow:" ref="aa1ed45a3b0be57d41a2b47578d13cd23" args="(NSWindow *window)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) configureInWindow: </td>
          <td></td>
          <td class="paramtype">(NSWindow *)&#160;</td>
          <td class="paramname"> <em>window</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VisualCommander will call this function to request that the data consumer controller present its configuration window as a sheet for the provided window. The default implementation uses configurationWindow and configurationDoneButton to look up the window and button to be used for indicating configuration completion and then begins a sheet modal for the specified window. If the configurationWindow returns nil on the first call, the nib (if any) specified with configurationNibName will be loaded and the call retried.</p>
<p>If more complex configuration handling is desired, this function can be overridden without the need to call the superclass implementation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>The window to which the configuration window should be attached as a sheet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70665c89d3ff6f61a6944a59ab82c4c5"></a><!-- doxytag: member="VCProcessorController::connectInput:withSource:" ref="a70665c89d3ff6f61a6944a59ab82c4c5" args="(VCInput *input,[withSource] id source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectInput: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td>
          <td class="paramname"> <em>input</em></td>
        </tr>
        <tr>
          <td class="paramkey">withSource:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"> <em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In most situations, inputs will automatically become connected in response to user actions. However, some data consumers may do automatic data discovery by looking through the data tree, and in those cases the input can manually hook inputs to sources with this method.</p>
<p>Most data consumers will not need to call this function; it is called automatically in response to user action.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to connect. </td></tr>
    <tr><td class="paramname">source</td><td>The source to connect the input to, either a data from from the data tree or an Output from another data consumer in this interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>YES if the connection was successful, or NO if an error ocurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ade26f89a9ba4785fa11bb69b5610a554"></a><!-- doxytag: member="VCProcessorController::connectOutlet:withCommand:" ref="ade26f89a9ba4785fa11bb69b5610a554" args="(VCCommandOutlet *outlet,[withCommand] id source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) connectOutlet: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *)&#160;</td>
          <td class="paramname"> <em>outlet</em></td>
        </tr>
        <tr>
          <td class="paramkey">withCommand:</td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"> <em>command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In most cases, a command outlet is connected to a command through user action. However, some data consumers may monitor the available data tree to find appropriate commands; these data consumers may call this method to programmatically connect a command outlet with a command object retrieved from the data tree. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">outlet</td><td>The command outlet to which the command should be connected </td></tr>
    <tr><td class="paramname">command</td><td>The command to connect to the outlet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>YES if the connection was successful; NO if an error occured. </dd></dl>

</div>
</div>
<a class="anchor" id="af240baf4c4ce31b8f202a1bab830fe3c"></a><!-- doxytag: member="VCProcessorController::consumerDefaults" ref="af240baf4c4ce31b8f202a1bab830fe3c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSDictionary *) consumerDefaults </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide a set of default values that will be stored in the consumer's entity before it is instantiated for the first time, allowing the code to rely on their presence in the entity.</p>
<p>If this data consumer is a Display, the following keys may be used to provide initial defaults for its appearance: </p>
<ul>
<li>
VCDisplayDefaultPadding - default 5.0f </li>
<li>
VCDisplayDefaultBorderWidth - default 1.0f </li>
<li>
VCDisplayDefaultBorderColor - default [NSColor blackColor] </li>
<li>
VCDisplayDefaultBackgroundColor - default [NSColor grayColor] </li>
</ul>

</div>
</div>
<a class="anchor" id="a66372e372b81700b7f51c6b0e1a3b746"></a><!-- doxytag: member="VCProcessorController::count:fromTime:to:forOutput:" ref="a66372e372b81700b7f51c6b0e1a3b746" args="(int numberOfPoints,[fromTime] VCTimestamp *start,[to] VCTimestamp *stop,[forOutput] VCOutput *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) count: </td>
          <td></td>
          <td class="paramtype">(int)&#160;</td>
          <td class="paramname"> <em>numberOfPoints</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromTime:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_timestamp.html">VCTimestamp</a> *)&#160;</td>
          <td class="paramname"> <em>start</em></td>
        </tr>
        <tr>
          <td class="paramkey">to:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_timestamp.html">VCTimestamp</a> *)&#160;</td>
          <td class="paramname"> <em>stop</em></td>
        </tr>
        <tr>
          <td class="paramkey">forOutput:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_output.html">VCOutput</a> *)&#160;</td>
          <td class="paramname"> <em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an array of calculated values for an output at a set of times evenly distributed between a start and end, inclusive. The default implementation simply interpolates the appropriate number of timestamps and calls valueAtTime:forOutput: for each one. Subclasses may override this function to provide improved performance. (This function may be called very frequently by other data consumers collecting historical data.) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">numberOfPoints</td><td>The number of calculated data points to return. This number is a maximum; if fewer points (or no points) are available, return only the number available. </td></tr>
    <tr><td class="paramname">start</td><td>The first timestamp for which the calculation should be returned. </td></tr>
    <tr><td class="paramname">stop</td><td>The last timestamp for which the calculation should be returned. </td></tr>
    <tr><td class="paramname">output</td><td>The output of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array of calculated values, ordered from oldest to youngest. If no values can be calculated, an empty array should b returned- under no circumstances should nil be returned from this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d9094998310f66c0b2e689be7ed2a75"></a><!-- doxytag: member="VCProcessorController::createCommandOutletWithName:" ref="a0d9094998310f66c0b2e689be7ed2a75" args="(NSString *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *) createCommandOutletWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new command outlet with the specified name. The command outlet's index is chosen to be the lowest integer greater than 0 such that the tuple (name,index) is unique at this data consumer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the new command outlet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The newly created command outlet object. </dd></dl>

</div>
</div>
<a class="anchor" id="a99531b72099e1d8a61ff5e0979535d1b"></a><!-- doxytag: member="VCProcessorController::createInputSetWithName:" ref="a99531b72099e1d8a61ff5e0979535d1b" args="(NSString *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *) createInputSetWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new input set with the provided name. If no other input sets with that name exist, the input set will have an index of 1. If other input sets with that name exist, the new set's index will be chosen so that the name and the index together uniquely identify the input set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to give the new input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The newly created input set object </dd></dl>

</div>
</div>
<a class="anchor" id="a27571f7b2af320f7f83885eb6e9d9695"></a><!-- doxytag: member="VCProcessorController::createInputWithName:inSet:" ref="a27571f7b2af320f7f83885eb6e9d9695" args="(NSString *name,[inSet] VCInputSet *inputSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_input.html">VCInput</a> *) createInputWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
        </tr>
        <tr>
          <td class="paramkey">inSet:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *)&#160;</td>
          <td class="paramname"> <em>inputSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new input with a specific name, placed in a specific input set. The new input's index will be chose so as to be the lowest integer greater than zero that causes the (name,inputSet,index) tuple to be unique. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the new input. </td></tr>
    <tr><td class="paramname">inputSet</td><td>The input set that the new input should be placed in, or nil if the input should not be assigned to an input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The newly created input object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad989ecfec6f930cfd17f9a38d431d036"></a><!-- doxytag: member="VCProcessorController::createOutputWithName:dataType:" ref="ad989ecfec6f930cfd17f9a38d431d036" args="(NSString *name,[dataType] enum VCDataTypes dataType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_output.html">VCOutput</a> *) createOutputWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
        </tr>
        <tr>
          <td class="paramkey">dataType:</td>
          <td></td>
          <td class="paramtype">(enum VCDataTypes)&#160;</td>
          <td class="paramname"> <em>dataType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new output with the specified name and data type. The output's index is chosen to be the lowest integer greater than 0 such that the tuple (name,index) is unique among outputs at this data consumer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the new output. </td></tr>
    <tr><td class="paramname">dataType</td><td>The data type of the data produced by the output </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The newly created output object. </dd></dl>

</div>
</div>
<a class="anchor" id="af5e3d8e850b8ebd14ad9d4f878972527"></a><!-- doxytag: member="VCProcessorController::currentTimestampForOutput:" ref="af5e3d8e850b8ebd14ad9d4f878972527" args="(VCOutput *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_timestamp.html">VCTimestamp</a> *) currentTimestampForOutput: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_output.html">VCOutput</a> *)&#160;</td>
          <td class="paramname"> <em>output</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sessions have a notion of current time, which changes as new data arrives or the Session Time Control interface is used to scrub through historical times. Data Consumers can also have a notion of current time for their outputs, generally based on the currentTime reported by their inputs. This function should return the current time associated with a specific output, which should generally be the current time associated with the inputs used to calculate that output.</p>
<p>The default implementation picks the youngest of all timestamps returned from currentTimestamp on each input connected to this data consumer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The output of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The timestamp to be used as current for the output. </dd></dl>

</div>
</div>
<a class="anchor" id="aee09994fb9b8542326056222de9dca60"></a><!-- doxytag: member="VCProcessorController::currentValueForInputWithName:inSet:" ref="aee09994fb9b8542326056222de9dca60" args="(NSString *name,[inSet] VCInputSet *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_value.html">VCValue</a> *) currentValueForInputWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
        </tr>
        <tr>
          <td class="paramkey">inSet:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *)&#160;</td>
          <td class="paramname"> <em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the current value of an input with the provided name, in the provided set. If more than one input that matches this criteria exists, the result will be nondeterministic. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the input to look up. </td></tr>
    <tr><td class="paramname">set</td><td>The input set to look in for the input, or nil to look for inputs that are not in an input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If an input that matches the criteria is found, return the result of calling currentValue on that input. If currentValue returns nil or no matching input is found, return nil. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3fa16be6012302d1f95b96d57c0267f"></a><!-- doxytag: member="VCProcessorController::currentValueForOutput:" ref="ac3fa16be6012302d1f95b96d57c0267f" args="(VCOutput *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_value.html">VCValue</a> *) currentValueForOutput: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_output.html">VCOutput</a> *)&#160;</td>
          <td class="paramname"> <em>output</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current value for an output- that is, the value at the the time returned by a call to currentTimestamp for the provided output. The default implementation calls currentTimestampForOutput: and then returns the result of valueAtTime:forOutput: with the appropriate timestamp and output. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The output of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value calculated for the output at the current time. </dd></dl>

</div>
</div>
<a class="anchor" id="a3897344497493559244bb7e5f7718ee1"></a><!-- doxytag: member="VCProcessorController::destroyCommandOutlet:" ref="a3897344497493559244bb7e5f7718ee1" args="(VCCommandOutlet *outlet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) destroyCommandOutlet: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *)&#160;</td>
          <td class="paramname"> <em>outlet</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy a command outlet object and remove it from this data consumer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">outlet</td><td>The command outlet to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a361f1e34c7a0448ffbd25210c047f9ed"></a><!-- doxytag: member="VCProcessorController::destroyInput:" ref="a361f1e34c7a0448ffbd25210c047f9ed" args="(VCInput *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) destroyInput: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td>
          <td class="paramname"> <em>input</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy an input object and remove it from the set (if it is in one) and from this data consumer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abee9a4c43050559b581aa838d02d31cb"></a><!-- doxytag: member="VCProcessorController::destroyInputSet:" ref="abee9a4c43050559b581aa838d02d31cb" args="(VCInputSet *inputSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) destroyInputSet: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *)&#160;</td>
          <td class="paramname"> <em>inputSet</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy an input set. Any inputs in the set will be reassigned to the base (nil) input set; their indices may be changed to ensure that name+index+set continues to uniquely define inputs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inputSet</td><td>the input set to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3d8e425f88eb222b3df5c6c2d89a8b2"></a><!-- doxytag: member="VCProcessorController::destroyOutput:" ref="af3d8e425f88eb222b3df5c6c2d89a8b2" args="(VCOutput *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) destroyOutput: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_output.html">VCOutput</a> *)&#160;</td>
          <td class="paramname"> <em>output</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy an output object and remove it from this consumer. Any inputs connected to the output will be disconnected. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The output to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d933783eec84262461e8e42e45d23ed"></a><!-- doxytag: member="VCProcessorController::disconnectCommandOutlet:" ref="a9d933783eec84262461e8e42e45d23ed" args="(VCCommandOutlet *outlet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectCommandOutlet: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *)&#160;</td>
          <td class="paramname"> <em>outlet</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnect a command outlet from the command that it is currently connected to, if any. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">outlet</td><td>The command outlet to disconnect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3280d3c607c818c2c6913cc565212c56"></a><!-- doxytag: member="VCProcessorController::disconnectInput:" ref="a3280d3c607c818c2c6913cc565212c56" args="(VCInput *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) disconnectInput: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td>
          <td class="paramname"> <em>input</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnect the input from any source (either a data point or an output) that it is currently connected to. If the input is not connected to a source, has no effect. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to be disconnected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a35ea58550454d0bcb6b4b3bf55136d"></a><!-- doxytag: member="VCProcessorController::hasHelp" ref="a2a35ea58550454d0bcb6b4b3bf55136d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) hasHelp </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subclasses can override this method to return YES if this object has a specific help file or NO if not. If not overridden, the default method will call pathToHelpFile: and return YES if a non-nil non-empty path string is returned. </p>

</div>
</div>
<a class="anchor" id="ab5b46fdf20ab81f99d3224c8fa80c590"></a><!-- doxytag: member="VCProcessorController::initWithEntity:" ref="ab5b46fdf20ab81f99d3224c8fa80c590" args="(VCExtendedManagedObject *anEntity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithEntity: </td>
          <td></td>
          <td class="paramtype">(VCExtendedManagedObject *)&#160;</td>
          <td class="paramname"> <em>anEntity</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All data consumers are initialized via a call to initWithEntity. Generally, the nib for the data consumer's view is loaded, if necessary, and any basic inputs, outputs and command outlets are set up. Remember that the data consumer may not be starting for the first time, if the interface is being loaded or a deletion of the data consumer is being undone; the values stored in the entity should be checked, and the absence of inputs/outputs/commands verified, to ensure that setup is not erroneously performed more than once. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">anEntity</td><td>The entity for this data consumer controller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>As with any init method, this method should always return self </dd></dl>

</div>
</div>
<a class="anchor" id="afb36d59c32fd7fb25be4636365ae62d9"></a><!-- doxytag: member="VCProcessorController::inputDidBecomeActive:" ref="afb36d59c32fd7fb25be4636365ae62d9" args="(VCInput *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) inputDidBecomeActive: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td>
          <td class="paramname"> <em>input</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VisualCommander will call this function when an input becomes active. Override if the plugin should take action in response to such an event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The Input that has become active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e4ce1195a9c44d007e708caaf01651a"></a><!-- doxytag: member="VCProcessorController::inputDidBecomeInactive:" ref="a6e4ce1195a9c44d007e708caaf01651a" args="(VCInput *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) inputDidBecomeInactive: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td>
          <td class="paramname"> <em>input</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VisualCommander will call this function when an input becomes inactive. Override if the plugin should take action in response to such an event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The Input that has become inactive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a740b72176ed28efe94643f8772e026"></a><!-- doxytag: member="VCProcessorController::inputDidGainSource:" ref="a7a740b72176ed28efe94643f8772e026" args="(VCInput *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) inputDidGainSource: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td>
          <td class="paramname"> <em>input</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VisualCommander will call this function when an input becomes connected. Override if the plugin should take action in response to such an event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The Input that has become connected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a378d1d9e1d3472d92bba618f5fd633f2"></a><!-- doxytag: member="VCProcessorController::inputDidLoseSource:" ref="a378d1d9e1d3472d92bba618f5fd633f2" args="(VCInput *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) inputDidLoseSource: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td>
          <td class="paramname"> <em>input</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VisualCommander will call this function when an input becomes disconnected. Override if the plugin should take action in response to such an event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The Input that has become disconnected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5598209ff96c851f9514742ec91e5a0a"></a><!-- doxytag: member="VCProcessorController::inputElementForElementPath:" ref="a5598209ff96c851f9514742ec91e5a0a" args="(NSString *elementPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_input_element.html">VCInputElement</a> *) inputElementForElementPath: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>elementPath</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve an input element object given its element path. All elements have a path that uniquely identifies them; this method can be used to look up a method by that path. Element paths, rather than elements themselves, should be used when configuration data needs to refer to a specific element.</p>
<p>This method will fail if the plugin does not return YES for +(BOOL)storesPerElementConfiguration.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">elementPath</td><td>the path to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The matching input element object, if one exists; nil if one could not be found. </dd></dl>

</div>
</div>
<a class="anchor" id="a734790c29686228809b69c74f1871e05"></a><!-- doxytag: member="VCProcessorController::inputForDataPoint:" ref="a734790c29686228809b69c74f1871e05" args="(id dataPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_input.html">VCInput</a> *) inputForDataPoint: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"> <em>dataPoint</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After willAcceptSource:forInput returns YES for a data point and a nil input, if the operation completes successfully this method will be called to return or create the <a class="el" href="interface_v_c_input.html" title="Represents a single source of data used by a data consumer.">VCInput</a> to which the data point should be connected. The default implementation always returns nil. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dataPoint</td><td>The dataPoint object responds to valueForKey: for the keys: "type", "units", "attributes", "path", "numberOfRows" and "numberOfColumns". The "numberOfRows" and "numberOfColumns" values are NSNumbers. The value for "type" is an NSNumber whose integer value is one of the VCDataTypes enumeration. The "units" and "path" values are NSString objects and the "attributes" value is an NSDictionary. These values should be sufficient to determine whether or not the data point should be used as an input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This method should return the input appropriate for the provided dataPoint. To cancel the operation, return nil. </dd></dl>

</div>
</div>
<a class="anchor" id="ae45ae946a8edcae1c9f17b04f748a87e"></a><!-- doxytag: member="VCProcessorController::inputSetsWithName:" ref="ae45ae946a8edcae1c9f17b04f748a87e" args="(NSString *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) inputSetsWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve all inputs matching the provided name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A set containing all input sets with the matching name. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ac6c1fae47f725375f6a021dcafebe6"></a><!-- doxytag: member="VCProcessorController::inputSetWithReferencePath:" ref="a0ac6c1fae47f725375f6a021dcafebe6" args="(NSString *referencePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *) inputSetWithReferencePath: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>referencePath</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the input set whose reference path matches the provided string. All input sets have a unique reference path based on their name and index. Input sets cannot be directly stored as configuration data, but their reference path can be; the reference path can subsequently be used to look the input set up with this method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">referencePath</td><td>The path to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If an input set with that reference path exists, it will be returned. If not, nil will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a88f17496fd2a9ccd2b81be7c14aee4ef"></a><!-- doxytag: member="VCProcessorController::inputsWithName:" ref="a88f17496fd2a9ccd2b81be7c14aee4ef" args="(NSString *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) inputsWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve all inputs with a name that matches the provided string </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A set containing all inputs with a matching name. </dd></dl>

</div>
</div>
<a class="anchor" id="abf00a3ed87237a8caf02b787570325ac"></a><!-- doxytag: member="VCProcessorController::inputsWithName:inSet:" ref="abf00a3ed87237a8caf02b787570325ac" args="(NSString *name,[inSet] VCInputSet *inputSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) inputsWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
        </tr>
        <tr>
          <td class="paramkey">inSet:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *)&#160;</td>
          <td class="paramname"> <em>inputSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve a set containing all inputs with a name that matches the provided string that are in the provided input set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to match. </td></tr>
    <tr><td class="paramname">inputSet</td><td>The input set to check for matching inputs, or nil to check inputs that are not in an input set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The set of matching inputs. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4c4765f53c180b41443b9309a38d307"></a><!-- doxytag: member="VCProcessorController::inputWithName:inSet:" ref="ac4c4765f53c180b41443b9309a38d307" args="(NSString *name,[inSet] VCInputSet *inputSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_input.html">VCInput</a> *) inputWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
        </tr>
        <tr>
          <td class="paramkey">inSet:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *)&#160;</td>
          <td class="paramname"> <em>inputSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a single <a class="el" href="interface_v_c_input.html" title="Represents a single source of data used by a data consumer.">VCInput</a> with the given name in the given set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to match </td></tr>
    <tr><td class="paramname">inputSet</td><td>The input set to check for matching inputs, or nil to check inputs that are not in a set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If no inputs with that name in that set exist, returns nil. If more than one input with that name exist in the set, one of them will be chosen in a nondeterministic fashion. </dd></dl>

</div>
</div>
<a class="anchor" id="a7170639e0a7d675135a0cdf8eae98e6b"></a><!-- doxytag: member="VCProcessorController::invalidated" ref="a7170639e0a7d675135a0cdf8eae98e6b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) invalidated </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When the data consumer is no longer needed (it has been deleted, the interface is being closed, etc), this method is first called to give it the opportunity to clean up any resources. Of particular note is the need to remove bindings that are attached directly to the controller, as these bindings retain the controller and will prevent it from being deallocated. Observations for key-value changes and notifications should also be unregistered here.</p>
<p>NOTE: It is critically important that, before returning, subclass implementations call their superclass's invalidated method. Failure to do so will lead to memory corruption. </p>

</div>
</div>
<a class="anchor" id="ab22c59a9b3796f25b858890e472ed4aa"></a><!-- doxytag: member="VCProcessorController::loadNibWithName:" ref="ab22c59a9b3796f25b858890e472ed4aa" args="(NSString *nibName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSNib *) loadNibWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>nibName</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load a nib with a given name from the bundle containing this object's class. If the nib has already been loaded, this function will avoid the need to re-load the nib and will simply return the previously loaded copy, speeding up subsequent loads of plugins. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nibName</td><td>The name of the nib to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The loaded nib, or nil if a nib with the specified name was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a05e4048ea3085501320d26e7683ae814"></a><!-- doxytag: member="VCProcessorController::name" ref="a05e4048ea3085501320d26e7683ae814" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString *) name </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide a human-readable name for this plugin. The name will be used to represent the data consumer in the tools palette; it will also be used as the default name for new instances of the data consumer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The plugin's name. </dd></dl>

</div>
</div>
<a class="anchor" id="a875e35b9c72731899dfb180bacb833d7"></a><!-- doxytag: member="VCProcessorController::notifyForNewData" ref="a875e35b9c72731899dfb180bacb833d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) notifyForNewData </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Notify all data consumers with inputs connected to an output at this data consumer that the data computable by this consumer has changed. This is often called in response to a connection or disconnection of an input (such that calculation becomes possible, or ceases to be possible) or to a configuration data change that would change how output values are calculated. </p>

</div>
</div>
<a class="anchor" id="afc261be261fc2166094cde6363ee85c4"></a><!-- doxytag: member="VCProcessorController::oldestDataTimestampForOutput:" ref="afc261be261fc2166094cde6363ee85c4" args="(VCOutput *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_timestamp.html">VCTimestamp</a> *) oldestDataTimestampForOutput: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_output.html">VCOutput</a> *)&#160;</td>
          <td class="paramname"> <em>output</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the oldest (smallest numerically) timestamp for which data can be produced for the provided output. The default implementation returns the oldest date for which all inputs connected to the data consumer have data available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The output of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The oldest possible timestamp for which data can be produced. If data cannot be produced at this time for the output, return nil. An older timestamp is one that occurs earlier chronologically- 2000-01-01 is older than 2009-01-01. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9e34007880d3117188bee0e2df5bf98"></a><!-- doxytag: member="VCProcessorController::outletDidGainCommand:" ref="ad9e34007880d3117188bee0e2df5bf98" args="(VCCommandOutlet *outlet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) outletDidGainCommand: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *)&#160;</td>
          <td class="paramname"> <em>outlet</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VisualCommander will call this function when a command is connected to a command outlet. Override if the plugin should take action in response to such an event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">outlet</td><td>The command outlet that has become connected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afed29ba7a99868a8995345ea7faa1702"></a><!-- doxytag: member="VCProcessorController::outletDidLoseCommand:" ref="afed29ba7a99868a8995345ea7faa1702" args="(VCCommandOutlet *outlet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) outletDidLoseCommand: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *)&#160;</td>
          <td class="paramname"> <em>outlet</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VisualCommander will call this function when a command outlet loses its connection to a command. Override if the plugin should take action in response to such an event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">outlet</td><td>The command outlet that has become connected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fb0a8ef7003518fa6e783b12c7b630d"></a><!-- doxytag: member="VCProcessorController::outletForCommand:" ref="a2fb0a8ef7003518fa6e783b12c7b630d" args="(id command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *) outletForCommand: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"> <em>command</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After willAcceptCommand:forOutlet returns YES for a command and a nil outlet, if the operation completes successfully this method will be called to return or create the command outlet to which the data point should be connected. The default implementation always returns nil. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command object responds to valueForKey: for the keys: "type", "units", "attributes", "path", "numberOfRows" and "numberOfColumns". The "numberOfRows" and "numberOfColumns" values are NSNumbers. The value for "type" is an NSNumber whose integer value is one of the VCDataTypes enumeration. The "units" and "path" values are NSString objects and the "attributes" value is an NSDictionary. These values should be sufficient to determine which command outlet should be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This method should return the command outlet appropriate for the provided command. To cancel the operation, return nil. </dd></dl>

</div>
</div>
<a class="anchor" id="a93909c3523e93816b1fd00e43b5ff76d"></a><!-- doxytag: member="VCProcessorController::outputsWithName:" ref="a93909c3523e93816b1fd00e43b5ff76d" args="(NSString *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) outputsWithName: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>name</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the set of outputs with a name that matches the provided string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A set containing the matching outputs. </dd></dl>

</div>
</div>
<a class="anchor" id="a6846948beba3485dd0b88c8779c81d00"></a><!-- doxytag: member="VCProcessorController::pathToHelpFile" ref="a6846948beba3485dd0b88c8779c81d00" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSString *) pathToHelpFile </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subclasses can override this method to return the path of a help file specific to this object. If not overridden, the default method will attempt to find a file named "help.html" in the bundle's Resources directory. If found, the path to that file will be returned. If not, nil is returned. The default implementations of hasHelp: and showHelp: both call this method if helpAnchor: doesn't return anything. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The path to the help file. </dd></dl>

</div>
</div>
<a class="anchor" id="a755646fe158c5a587d5fa21d8d07b7ef"></a><!-- doxytag: member="VCProcessorController::placeInput:inSet:" ref="a755646fe158c5a587d5fa21d8d07b7ef" args="(VCInput *input,[inSet] VCInputSet *inputSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) placeInput: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td>
          <td class="paramname"> <em>input</em></td>
        </tr>
        <tr>
          <td class="paramkey">inSet:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input_set.html">VCInputSet</a> *)&#160;</td>
          <td class="paramname"> <em>inputSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move an input from one input set to another. An input can only be in one input set at a time. If the new input set would cause the (name,input set,index) tuple to no longer be unique, the input's index will be updated to the lowest index that will ensure uniqueness. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to modify </td></tr>
    <tr><td class="paramname">inputSet</td><td>the input set that the input should be placed in, or nil if the input should be removed from any input set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27c62a0e5118511846d2261263907b51"></a><!-- doxytag: member="VCProcessorController::removeAttribute:fromOutput:" ref="a27c62a0e5118511846d2261263907b51" args="(NSString *attribute,[fromOutput] VCOutput *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) removeAttribute: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>attribute</em></td>
        </tr>
        <tr>
          <td class="paramkey">fromOutput:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_output.html">VCOutput</a> *)&#160;</td>
          <td class="paramname"> <em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove an attribute from an output. Attributes are frequently used by receiving data consumers to determine whether or not they should accept the output as an input. Be aware that changing the attributes of an input will not cause other data consumers to re-validate their usage of the output; it is best to set the attributes when the output is created and then not change them in the future. Instead, destroy and re-create the output to ensure that existing connections are broken and new ones properly validated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>The attribute for which the value should be set. Must not be nil. </td></tr>
    <tr><td class="paramname">output</td><td>The output to modify. Must not be nil </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab80f9cbf9348b413eff0afa226245952"></a><!-- doxytag: member="VCProcessorController::setValue:forAttribute:ofOutput:" ref="ab80f9cbf9348b413eff0afa226245952" args="(NSString *value,[forAttribute] NSString *attribute,[ofOutput] VCOutput *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setValue: </td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>value</em></td>
        </tr>
        <tr>
          <td class="paramkey">forAttribute:</td>
          <td></td>
          <td class="paramtype">(NSString *)&#160;</td>
          <td class="paramname"> <em>attribute</em></td>
        </tr>
        <tr>
          <td class="paramkey">ofOutput:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_output.html">VCOutput</a> *)&#160;</td>
          <td class="paramname"> <em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the value of an attribute of an output of this data consumer. Attributes are frequently used by receiving data consumers to determine whether or not they should accept the output as an input. Be aware that changing the attributes of an input will not cause other data consumers to re-validate their usage of the output; it is best to set the attributes when the output is created and then not change them in the future. Instead, destroy and re-create the output to ensure that existing connections are broken and new ones properly validated. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to set for the attribute. Must not be nil. </td></tr>
    <tr><td class="paramname">attribute</td><td>The attribute for which the value should be set. Must not be nil. </td></tr>
    <tr><td class="paramname">output</td><td>The output to modify. Must not be nil. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56ff8d2237b85f0bf1207b4e32339607"></a><!-- doxytag: member="VCProcessorController::storesPerElementConfiguration" ref="a56ff8d2237b85f0bf1207b4e32339607" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) storesPerElementConfiguration </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the data consumer needs to store separate configuration information for each element of matrix inputs (eg, line color information for a plot), this method can be overridden to return YES (the default is NO). If this method returns YES, all elements for any matrix inputs (and a single element for each double and integer input) will have corresponding <a class="el" href="interface_v_c_input_element.html" title="Provides per-element configuration storage for elements of a single input for a data consumer...">VCInputElement</a> objects created for them, which allow arbitrary key-value storage in the same way the data consumer's entity does. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>YES to create per-element configuration objects; NO otherwise. Default implementation returns NO. </dd></dl>

</div>
</div>
<a class="anchor" id="a55e9e9e561a0a8b31bd2b667cc528811"></a><!-- doxytag: member="VCProcessorController::tooltip" ref="a55e9e9e561a0a8b31bd2b667cc528811" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString *) tooltip </td>
          <td></td>
          <td class="paramname"></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide a tooltip that will be shown when the user hovers the mouse over the plugin's name in the tools palette; should provide a brief description of the plugin. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The plugin's tooltip. </dd></dl>

</div>
</div>
<a class="anchor" id="aa832912257d215fb105f0cc02c104ab7"></a><!-- doxytag: member="VCProcessorController::valueAtTime:forOutput:" ref="aa832912257d215fb105f0cc02c104ab7" args="(VCTimestamp *timestamp,[forOutput] VCOutput *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_value.html">VCValue</a> *) valueAtTime: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_timestamp.html">VCTimestamp</a> *)&#160;</td>
          <td class="paramname"> <em>timestamp</em></td>
        </tr>
        <tr>
          <td class="paramkey">forOutput:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_output.html">VCOutput</a> *)&#160;</td>
          <td class="paramname"> <em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the value of an output at the specified time. The default implementation returns nil. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>The timestamp for which a value should be calculated. </td></tr>
    <tr><td class="paramname">output</td><td>The output of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The calculated value, or nil if the value cannot be calculated. </dd></dl>

</div>
</div>
<a class="anchor" id="a9269d050c7eac76eff52db71229c3c9a"></a><!-- doxytag: member="VCProcessorController::willAcceptCommand:forOutlet:withTooltip:" ref="a9269d050c7eac76eff52db71229c3c9a" args="(id command,[forOutlet] VCCommandOutlet *outlet,[withTooltip] NSString **tooltip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) willAcceptCommand: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"> <em>command</em></td>
        </tr>
        <tr>
          <td class="paramkey">forOutlet:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_command_outlet.html">VCCommandOutlet</a> *)&#160;</td>
          <td class="paramname"> <em>outlet</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTooltip:</td>
          <td></td>
          <td class="paramtype">(NSString **)&#160;</td>
          <td class="paramname"> <em>tooltip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subclasses should override this method to perform custom logic determining whether or not a given command will be accepted as a source for the specified command outlet. The default implementation always returns NO. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command object responds to valueForKey: for the keys: "type", "units", "attributes", "path", "numberOfRows" and "numberOfColumns". The "numberOfRows" and "numberOfColumns" values are NSNumbers. The value for "type" is an NSNumber whose integer value is one of the VCDataTypes enumeration. The "units" and "path" values are NSString objects and the "attributes" value is an NSDictionary. These values should be sufficient to determine whether or not the command should be used for a command outlet. </td></tr>
    <tr><td class="paramname">outlet</td><td>The command outlet that the command may be connected to. If the command outlet is nil, the user has not specified the command outlet, and should this method return YES and a subsequent drop occur commandOutletForCommand: will be called to determine which command outlet should be connected. In this case the consumer should decide if any of the available command outlets are appropriate (or if it is possible to create a new appropriate command outlet). </td></tr>
    <tr><td class="paramname">tooltip</td><td>The implementation may set this to point to an NSString giving a tooltip to show as drag feedback (a reason for rejecting, or a detail regarding what the command will be used for, for instance) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This method should return YES if the command should be accepted, or NO if it should not. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ca7f3d1c746b5b38174546a19ba31e0"></a><!-- doxytag: member="VCProcessorController::willAcceptSource:forInput:withTooltip:" ref="a7ca7f3d1c746b5b38174546a19ba31e0" args="(id dataPoint,[forInput] VCInput *input,[withTooltip] NSString **tooltip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (BOOL) willAcceptSource: </td>
          <td></td>
          <td class="paramtype">(id)&#160;</td>
          <td class="paramname"> <em>dataPoint</em></td>
        </tr>
        <tr>
          <td class="paramkey">forInput:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_input.html">VCInput</a> *)&#160;</td>
          <td class="paramname"> <em>input</em></td>
        </tr>
        <tr>
          <td class="paramkey">withTooltip:</td>
          <td></td>
          <td class="paramtype">(NSString **)&#160;</td>
          <td class="paramname"> <em>tooltip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subclasses should override this method to perform custom logic determining whether or not a given data point will be accepted as a source for the specified input. The default implementation always returns NO </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dataPoint</td><td>The dataPoint object responds to valueForKey: for the keys: "type", "units", "attributes", "path", "numberOfRows" and "numberOfColumns". The "numberOfRows" and "numberOfColumns" values are NSNumbers. The value for "type" is an NSNumber whose integer value is one of the VCDataTypes enumeration. The "units" and "path" values are NSString objects and the "attributes" value is an NSDictionary. These values should be sufficient to determine whether or not the data point should be used as an input. </td></tr>
    <tr><td class="paramname">input</td><td>The input that the data point may be connected to. If the input is nil, the user has not specified the input, and should this method return YES and a subsequent drop occur inputForDataPoint: will be called to determine which input should be connected. In this case the consumer should decide if any of the available inputs are appropriate (or if it is possible to create a new appropriate input). </td></tr>
    <tr><td class="paramname">tooltip</td><td>The implementation may set this to point to an NSString giving a tooltip to show as drag feedback (a reason for rejecting, or a detail regarding what the input will be used for, for instance) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This method should return YES if the data point should be accepted, or NO if it should not. </dd></dl>

</div>
</div>
<a class="anchor" id="a13b6c5f35150e95264e69129d6a5a485"></a><!-- doxytag: member="VCProcessorController::youngestDataTimestampForOutput:" ref="a13b6c5f35150e95264e69129d6a5a485" args="(VCOutput *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_v_c_timestamp.html">VCTimestamp</a> *) youngestDataTimestampForOutput: </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_v_c_output.html">VCOutput</a> *)&#160;</td>
          <td class="paramname"> <em>output</em></td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the youngest (largest numerically) timestamp for which data can be produced for the provided output. The default implementation returns the youngest date for which all inputs connected to the data consumer have data available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The output of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The youngest possible timestamp for which data can be produced. If data cannot be produced at this time for the output, return nil. A younger timestamp is one that occurs later chronologically- 2009-01-01 is younger than 2000-01-01. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>VCProcessorController.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 19 2011 13:54:23 for VisualCommander by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
