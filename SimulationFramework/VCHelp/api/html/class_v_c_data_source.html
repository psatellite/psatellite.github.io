<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VisualCommander: VCDataSource Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>VCDataSource Class Reference<br/>
<small>
[<a class="el" href="group__datasource.html">Data Source Plugins</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="VCDataSource" -->
<p>Superclass for all data source plugins.  
<a href="#_details">More...</a></p>

<p>Inherited by VCArchiveSource, VCControlDeck2Source, VCControlDeckSource, VCDSim2Source, VCDSimSource, VCFlatFileSource, and VCTestSource.</p>

<p><a href="class_v_c_data_source-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a12dddddb3d8e75d29b56b63a4325de5c">VCDataSource</a> (const ds_dictionary *init_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a12dddddb3d8e75d29b56b63a4325de5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac07e5caf16e69ce93216df8b865cb1ae"></a><!-- doxytag: member="VCDataSource::~VCDataSource" ref="ac07e5caf16e69ce93216df8b865cb1ae" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#ac07e5caf16e69ce93216df8b865cb1ae">~VCDataSource</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#ad0b62f163a1ae63f41edfea302d15003">run_source</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The primary run loop. This function should not return until the source is ready to close.  <a href="#ad0b62f163a1ae63f41edfea302d15003"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62b7e1eebf502838bb2f9ccaac17311b"></a><!-- doxytag: member="VCDataSource::wait_for_configuration" ref="a62b7e1eebf502838bb2f9ccaac17311b" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a62b7e1eebf502838bb2f9ccaac17311b">wait_for_configuration</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the user has indicated a desire to provide configuration data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a5225cbd5400f83456ed3d59624fb5835">initialize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass to initialize the data source.  <a href="#a5225cbd5400f83456ed3d59624fb5835"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a4a6d1f6470db6690c254c3fd50bbdb93">configure</a> (const ds_dictionary *configuration_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass to handle configuration data.  <a href="#a4a6d1f6470db6690c254c3fd50bbdb93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ds_dictionary *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#aec7cde35ffc07b9db11054cac15aa400">configuration_query</a> (const ds_dictionary *query)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass to respond to configuration queries from configurators.  <a href="#aec7cde35ffc07b9db11054cac15aa400"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#acf039bd2e0ea0c905fdb810a28975d6c">setup_metadata</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass to define the data tree for this source.  <a href="#acf039bd2e0ea0c905fdb810a28975d6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#addb8b0e8638ee9fb921c0ac00a929d65">run</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass to handle actions that must occur when the source transitiions to the run state.  <a href="#addb8b0e8638ee9fb921c0ac00a929d65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a78a2f99099172543eb495ab1451a7864">pause</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass to pause the source.  <a href="#a78a2f99099172543eb495ab1451a7864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a88e4f7ac02ef75dab017b8a6766bb44d">resume</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass to handle resuming fromm pause.  <a href="#a88e4f7ac02ef75dab017b8a6766bb44d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#abd11a23ab778f75e497c722c640b4e5e">terminate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass to provide and handling that should occur at termination.  <a href="#abd11a23ab778f75e497c722c640b4e5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a8a849b58369982977f3cca045bd03f98">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass to provide "Quick Reset" functionality and increment the run number.  <a href="#a8a849b58369982977f3cca045bd03f98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a557cd159ee3f6a6f2a7f8a6044f6c57f">configuration_required</a> (const ds_dictionary *configuration_description)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that configuration is required, and optionally provide a dictionary that describes what is needed.  <a href="#a557cd159ee3f6a6f2a7f8a6044f6c57f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a77a6b252c6d0fd1944aa8b28acb0f3af">configuration_complete</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the source is now fully configured.  <a href="#a77a6b252c6d0fd1944aa8b28acb0f3af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a399f665acb039817fd4fa09e3288b696">metadata_complete</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the source has has defined all of the required metadata.  <a href="#a399f665acb039817fd4fa09e3288b696"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#afad2b7a1bcc11e5f30e5bf60a6f6f6d9">run_completed</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the source has finished producing data for this run.  <a href="#afad2b7a1bcc11e5f30e5bf60a6f6f6d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a6cc95c9ebc8e21f31e000954ae0cda5c">increment_run</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the run number; all subsequent data will be sent tagged with the new run number.  <a href="#a6cc95c9ebc8e21f31e000954ae0cda5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VCDataSourceState_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a560f8b0e8c645a41565055ae1738e265">stage</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current state of the source.  <a href="#a560f8b0e8c645a41565055ae1738e265"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#aaf435c8eaa8154f1cf69fbcc154156b7">define_point</a> (const char *path, int type, const char *units=&quot;&quot;, const char *description=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a data point produced by this source.  <a href="#aaf435c8eaa8154f1cf69fbcc154156b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#ae327c4926b4dc5ca68fdcb0950fae510">lookup_point</a> (const char *path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the id of a defined point based on its path.  <a href="#ae327c4926b4dc5ca68fdcb0950fae510"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#aed5b3b5b70d191c38c9894475545fb61">define_point_dimensions</a> (int key, int rows, int columns)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide dimension hints for a defined point.  <a href="#aed5b3b5b70d191c38c9894475545fb61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a484d1af7a81008bcb62ecf37876975b8">define_point_attribute</a> (int key, const char *attribute, const char *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an attribute/value pair for a defined point.  <a href="#a484d1af7a81008bcb62ecf37876975b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#ab3db09ec0384f664ec5c106bd695fc8d">set_point_as_unlogged</a> (int key, bool unlogged)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a point as unlogged (data is not saved)  <a href="#ab3db09ec0384f664ec5c106bd695fc8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#af0233fb12dbd43198df59141ca99ccc1">define_command</a> (const char *command_path, int type, const char *units=&quot;&quot;, const char *description=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a command accepted by this source.  <a href="#af0233fb12dbd43198df59141ca99ccc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#afecb992e0132166e8d41ba11bac5f9d1">lookup_command</a> (const char *path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the id of a defined command based on its path.  <a href="#afecb992e0132166e8d41ba11bac5f9d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a82d8f194501eb74cd51258ab7a91b5d6">define_command_dimensions</a> (int key, int rows, int columns)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide dimension hints for a defined command.  <a href="#a82d8f194501eb74cd51258ab7a91b5d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#ae78e1773015a626362d5bb272d16686d">define_command_attribute</a> (int key, const char *attribute, const char *value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an attribute/value pair for a defined point.  <a href="#ae78e1773015a626362d5bb272d16686d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#aa3ad3e34bd57eeea63e85c18f8fe7548">store_data</a> (int index, void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current value of the point with the provided id.  <a href="#aa3ad3e34bd57eeea63e85c18f8fe7548"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#adc4917cfeee8b75f451e31db8ebe67bc">send_data</a> (const ds_date &amp;datestamp, bool no_broadcast=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the values of all points that have been updated since the last <a class="el" href="class_v_c_data_source.html#aa3ad3e34bd57eeea63e85c18f8fe7548" title="Set the current value of the point with the provided id.">store_data()</a> call.  <a href="#adc4917cfeee8b75f451e31db8ebe67bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#ab8da3ae724f2898df2b1cb605eeace2f">complete_historical_load</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that any historical data has been loaded and sent.  <a href="#ab8da3ae724f2898df2b1cb605eeace2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#acd5d928399bb651a7f0448f4426acb75">commands_arrived</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass when new commands have arrived from the client.  <a href="#acd5d928399bb651a7f0448f4426acb75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a0f4f81b9e060b23d474b590917792cf9">handle_command</a> (int key, const char *path, void *data, unsigned int length, const ds_date &amp;execute_time)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the superclass to handle a specific command.  <a href="#a0f4f81b9e060b23d474b590917792cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#aca06f86691a993535401d4d56a151e34">run_commands_until_date</a> (const ds_date &amp;stop_date)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the data source to call <a class="el" href="class_v_c_data_source.html#a0f4f81b9e060b23d474b590917792cf9" title="Called by the superclass to handle a specific command.">handle_command()</a> for any commands that should be executed before a specific time.  <a href="#aca06f86691a993535401d4d56a151e34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ds_date&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a621a1d6f119d9aef9c7e75ab0c23967c">next_command_execute_time</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the execution time of the next scheduled command.  <a href="#a621a1d6f119d9aef9c7e75ab0c23967c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#ab1c68f11c4994ac3d34caf98006ffafb">unpack_data</a> (void *destination, int data_type, void *data, unsigned int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack command data based on its type.  <a href="#ab1c68f11c4994ac3d34caf98006ffafb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#ae4e13ae6898b84859fd6daadd6e936df">install_timer</a> (const char *name, double period, bool repeat, void(*callback)(<a class="el" href="class_v_c_data_source.html">VCDataSource</a> *source, const char *name, void *context), void *context)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a timer callback.  <a href="#ae4e13ae6898b84859fd6daadd6e936df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#ab4d8742c72671c0e56711727cd3e91aa">remove_timer</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a timer callback.  <a href="#ab4d8742c72671c0e56711727cd3e91aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#a852a62dfb76355ac793a3bf2b6f90af8">run_subtask</a> (bool dup_stdout, bool dup_stderr, int *input_fd, int *output_fd, const char *path, const char *args[])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start up a subprocess and pipe its input and output into this data source.  <a href="#a852a62dfb76355ac793a3bf2b6f90af8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#adc3c023a1eedb9c10244aaa567d90752">throw_error</a> (const char *msg,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the data source into the error state, and print a message to the console describing the problem.  <a href="#adc3c023a1eedb9c10244aaa567d90752"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#aa14ffb8173d18f681ad5f756bda3e397">log_message</a> (VCLogSeverity_t severity, const char *msg,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a log message to the console with a standard prefix giving the data, process, etc.  <a href="#aa14ffb8173d18f681ad5f756bda3e397"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_v_c_data_source.html#af96eb5c9904b34a7d7f898f73f650adb">handle_messages</a> (const ds_date *stop_date=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the data source to handle any messages for a period of time. Subclasses must call this at least periodically.  <a href="#af96eb5c9904b34a7d7f898f73f650adb"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="class_v_c_data_source.html" title="Superclass for all data source plugins.">VCDataSource</a> class provides a superclass for all data source plugins. User plugins override specific virtual functions to customize the behavior of the data source, and call <a class="el" href="class_v_c_data_source.html" title="Superclass for all data source plugins.">VCDataSource</a> functions to access relevant functionality. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a12dddddb3d8e75d29b56b63a4325de5c"></a><!-- doxytag: member="VCDataSource::VCDataSource" ref="a12dddddb3d8e75d29b56b63a4325de5c" args="(const ds_dictionary *init_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VCDataSource::VCDataSource </td>
          <td>(</td>
          <td class="paramtype">const ds_dictionary *&#160;</td>
          <td class="paramname"> <em>init_data</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Data source constructor. Subclasses must be sure to pass in the init_data paramter from the factory function without modification. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">init_data</td><td>The initialization dictionary for the data source. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acd5d928399bb651a7f0448f4426acb75"></a><!-- doxytag: member="VCDataSource::commands_arrived" ref="acd5d928399bb651a7f0448f4426acb75" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::commands_arrived </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When command messages arrive from VisualCommander, this method will be called, giving the data source an opportunity to see when the next command should be executed. The default implementation does nothing, and it is not required to override this method. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>If a fatal error ocurrs, return false; otherwise return true. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8da3ae724f2898df2b1cb605eeace2f"></a><!-- doxytag: member="VCDataSource::complete_historical_load" ref="ab8da3ae724f2898df2b1cb605eeace2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::complete_historical_load </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inform all clients that historical data has been loaded and that they should re-check the available range of data. This function should generally be called after a sequence of <a class="el" href="class_v_c_data_source.html#adc4917cfeee8b75f451e31db8ebe67bc" title="Send the values of all points that have been updated since the last store_data() call.">send_data()</a> calls has been made with the no_broadcast flag set to true. </p>

<p><p>ds_dictionary *send_dict = new ds_dictionary(*data_dict); </p>
</p>

</div>
</div>
<a class="anchor" id="a77a6b252c6d0fd1944aa8b28acb0f3af"></a><!-- doxytag: member="VCDataSource::configuration_complete" ref="a77a6b252c6d0fd1944aa8b28acb0f3af" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::configuration_complete </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicate that all configuration has ocurred, and that the data source is now ready to continue the startup sequence. The stage will be moved to VCDataSourceInitializing.</p>
<p>This function will throw an error if it is called when the stage is not VCDataSourceNeedsConfig or VCDataSourceStarting. </p>

</div>
</div>
<a class="anchor" id="aec7cde35ffc07b9db11054cac15aa400"></a><!-- doxytag: member="VCDataSource::configuration_query" ref="aec7cde35ffc07b9db11054cac15aa400" args="(const ds_dictionary *query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ds_dictionary * VCDataSource::configuration_query </td>
          <td>(</td>
          <td class="paramtype">const ds_dictionary *&#160;</td>
          <td class="paramname"> <em>query</em>&#160;)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle a configurator's configuration query to the source. Many sources will not need to implement this function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>The dictionary provided by the configurator. The meaning of the content of this dictionary is entirely user-defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A dictionary to be returned to the source. The meaning of the content of this dictionary is entirely user-defined. </dd></dl>

</div>
</div>
<a class="anchor" id="a557cd159ee3f6a6f2a7f8a6044f6c57f"></a><!-- doxytag: member="VCDataSource::configuration_required" ref="a557cd159ee3f6a6f2a7f8a6044f6c57f" args="(const ds_dictionary *configuration_description)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::configuration_required </td>
          <td>(</td>
          <td class="paramtype">const ds_dictionary *&#160;</td>
          <td class="paramname"> <em>configuration_description</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicate that the data source requires configuration data, and optionally provide a description of what is required. This function will also move the data source to the VCDataSourceNeedsConfig stage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">configuration_description</td><td>An optional configuraton description dictionary, or NULL if no description is provided. The meaning of the content of the dictionary, if provided, is entirely user defined; a configurator may use it in the client to customize the configuration options presented to the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a6d1f6470db6690c254c3fd50bbdb93"></a><!-- doxytag: member="VCDataSource::configure" ref="a4a6d1f6470db6690c254c3fd50bbdb93" args="(const ds_dictionary *configuration_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::configure </td>
          <td>(</td>
          <td class="paramtype">const ds_dictionary *&#160;</td>
          <td class="paramname"> <em>configuration_data</em>&#160;)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle configuration data sent to the source. If the configuration data is sufficient to complete the configuration of the source, this function should call <a class="el" href="class_v_c_data_source.html#a77a6b252c6d0fd1944aa8b28acb0f3af" title="Indicate that the source is now fully configured.">configuration_complete()</a> before returning. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">configuration_data</td><td>The configuration dictionary provided by the configurator </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success; false on fatal error </dd></dl>

</div>
</div>
<a class="anchor" id="af0233fb12dbd43198df59141ca99ccc1"></a><!-- doxytag: member="VCDataSource::define_command" ref="af0233fb12dbd43198df59141ca99ccc1" args="(const char *command_path, int type, const char *units=&quot;&quot;, const char *description=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VCDataSource::define_command </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>command_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>units</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define a command handled by this source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command_path</td><td>The path to the command. Paths take the form A|B|C:D, where A, B and C are volume names and D is the name of the point. That is, a path is formed by concatenating all parent volumes, in order from the root, with a pipe character '|' between each name, and by then appending a colon and the name of the command. To define a top-level command, simply provide no volume name; the colon is still required. Note that commands and points share a path namespace- a point and a command cannot both have the same path. </td></tr>
    <tr><td class="paramname">type</td><td>The data type of the command. Available options are: </p>
<ul>
<li>
sd_type_double - 64 bit Double </li>
<li>
sd_type_int- 32 bit Integer </li>
<li>
sd_type_matrix - ml_matrix matrix object; see MatrixLib </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>A string giving the units for the command, or an empty string if there are no units. Must not be null. </td></tr>
    <tr><td class="paramname">description</td><td>A string giving a human-readable description of the command, or an empty string if no description is available. Must not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The id of the newly defined command, or 0 if the definition failed because the path already exists or the path is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="ae78e1773015a626362d5bb272d16686d"></a><!-- doxytag: member="VCDataSource::define_command_attribute" ref="ae78e1773015a626362d5bb272d16686d" args="(int key, const char *attribute, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::define_command_attribute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide an attribute/value pair for a command. Attribute/value pairs are visible to the user when they are inspecting source metadata, and they are also often used by displays to determine how a command should be interpreted or handled. Their meaning is entirely user-defined and they are not used internally by VisualCommander. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The id of the command to provide an attribute for </td></tr>
    <tr><td class="paramname">attribute</td><td>The name of the attribute. Must not be null. Must be a null-terminated string. </td></tr>
    <tr><td class="paramname">value</td><td>the value for the attribute. Must not be null. Must be a null-terminated string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82d8f194501eb74cd51258ab7a91b5d6"></a><!-- doxytag: member="VCDataSource::define_command_dimensions" ref="a82d8f194501eb74cd51258ab7a91b5d6" args="(int key, int rows, int columns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::define_command_dimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide dimension hints for a command. The dimension hints may be used by displays to determine what data to send. However, the dimensions are not enforced by the system- it sthe responsibility of the source, upon receiving a command, to ensure that the provided data is valid.</p>
<p>Integer and Double commands have implicit dimension hints of 1x1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The id of the command to add hints for </td></tr>
    <tr><td class="paramname">rows</td><td>The number of rows the command is expected to have </td></tr>
    <tr><td class="paramname">columns</td><td>The number of columns the command is expected to have </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf435c8eaa8154f1cf69fbcc154156b7"></a><!-- doxytag: member="VCDataSource::define_point" ref="aaf435c8eaa8154f1cf69fbcc154156b7" args="(const char *path, int type, const char *units=&quot;&quot;, const char *description=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VCDataSource::define_point </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>units</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>description</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define a point for which data will be provided by this source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the point. Paths take the form A|B|C:D, where A, B and C are volume names and D is the name of the point. That is, a path is formed by concatenating all parent volumes, in order from the root, with a pipe character '|' between each name, and by then appending a colon and the name of the point. To define a top-level point, simply provide no volume name; the colon is still required. </td></tr>
    <tr><td class="paramname">type</td><td>The data type of the point. Available options are: </p>
<ul>
<li>
sd_type_double - 64 bit Double </li>
<li>
sd_type_int- 32 bit Integer </li>
<li>
sd_type_matrix - ml_matrix matrix object; see MatrixLib </li>
</ul>
</td></tr>
    <tr><td class="paramname">units</td><td>A string giving the units for the point, or an empty string if there are no units. Must not be null. </td></tr>
    <tr><td class="paramname">description</td><td>A string giving a human-readable description of the point, or an empty string if no description is available. Must not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The id of the newly defined point, or 0 if the definition failed because the path already exists or the path is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a484d1af7a81008bcb62ecf37876975b8"></a><!-- doxytag: member="VCDataSource::define_point_attribute" ref="a484d1af7a81008bcb62ecf37876975b8" args="(int key, const char *attribute, const char *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::define_point_attribute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide an attribute/value pair for a point. Attribute/value pairs are visible to the user when they are inspecting source metadata, and they are also often used by displays to determine how a point should be interpreted. Their meaning is entirely user-defined and they are not used internally by VisualCommander. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The id of the point to provide an attribute for </td></tr>
    <tr><td class="paramname">attribute</td><td>The name of the attribute. Must not be null. Must be a null-terminated string. </td></tr>
    <tr><td class="paramname">value</td><td>the value for the attribute. Must not be null. Must be a null-terminated string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed5b3b5b70d191c38c9894475545fb61"></a><!-- doxytag: member="VCDataSource::define_point_dimensions" ref="aed5b3b5b70d191c38c9894475545fb61" args="(int key, int rows, int columns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::define_point_dimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide dimension hints for a point. Dimension hints are often used by displays to set up expected sizes prior to the arrival of data. These dimensions are not binding- every value stored in the point could have different dimensions- but many displays perform poorly when points do not contain dimension hints or do not follow the provided dimensions.</p>
<p>Integer and Double data points have implicit dimension hints of 1x1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The id of the point to add hints for </td></tr>
    <tr><td class="paramname">rows</td><td>The number of rows the point is expected to have </td></tr>
    <tr><td class="paramname">columns</td><td>The number of columns the point is expected to have </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f4f81b9e060b23d474b590917792cf9"></a><!-- doxytag: member="VCDataSource::handle_command" ref="a0f4f81b9e060b23d474b590917792cf9" args="(int key, const char *path, void *data, unsigned int length, const ds_date &amp;execute_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::handle_command </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ds_date &amp;&#160;</td>
          <td class="paramname"> <em>execute_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by <a class="el" href="class_v_c_data_source.html#aca06f86691a993535401d4d56a151e34" title="Ask the data source to call handle_command() for any commands that should be executed before a specif...">run_commands_until_date()</a> to handle a single command. The default implementation does nothing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The id of the command. </td></tr>
    <tr><td class="paramname">path</td><td>The path of the command. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the raw data provided for the command. This data is in packed form, and must be unpacked prior to use; see the <a class="el" href="class_v_c_data_source.html#ab1c68f11c4994ac3d34caf98006ffafb" title="Unpack command data based on its type.">unpack_data()</a> function. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data provided. </td></tr>
    <tr><td class="paramname">execute_time</td><td>The time scheduled for the execution of this command. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If a fatal error ocurrs, return false; otherwise return true. </dd></dl>

</div>
</div>
<a class="anchor" id="af96eb5c9904b34a7d7f898f73f650adb"></a><!-- doxytag: member="VCDataSource::handle_messages" ref="af96eb5c9904b34a7d7f898f73f650adb" args="(const ds_date *stop_date=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::handle_messages </td>
          <td>(</td>
          <td class="paramtype">const ds_date *&#160;</td>
          <td class="paramname"> <em>stop_date</em> = <code>NULL</code>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cause the data source to handle network communication and check for incoming messages until the provided stop date. All other functions are called during a call to handle_messages. If the default <a class="el" href="class_v_c_data_source.html#ad0b62f163a1ae63f41edfea302d15003" title="The primary run loop. This function should not return until the source is ready to close...">run_source()</a> implementation is used, this method is called automatically; if it is overridden, the provided implementation must be careful to call <a class="el" href="class_v_c_data_source.html#af96eb5c9904b34a7d7f898f73f650adb" title="Ask the data source to handle any messages for a period of time. Subclasses must call this at least p...">handle_messages()</a> periodically. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_date</td><td>A pointer to a wall-clock date. The call will block until a message has been handled, or this data arrives, whichever comes first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cc95c9ebc8e21f31e000954ae0cda5c"></a><!-- doxytag: member="VCDataSource::increment_run" ref="a6cc95c9ebc8e21f31e000954ae0cda5c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::increment_run </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the run number that is included with all data, indicating that all subsequent data is associated with a new run. Generally called from within an implementation of <a class="el" href="class_v_c_data_source.html#a8a849b58369982977f3cca045bd03f98" title="Called by the superclass to provide &quot;Quick Reset&quot; functionality and increment the run numbe...">reset()</a>. </p>

</div>
</div>
<a class="anchor" id="a5225cbd5400f83456ed3d59624fb5835"></a><!-- doxytag: member="VCDataSource::initialize" ref="a5225cbd5400f83456ed3d59624fb5835" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::initialize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handle plugin any plugin initialization. If the plugin will require configuration (or if <a class="el" href="class_v_c_data_source.html#a62b7e1eebf502838bb2f9ccaac17311b" title="Whether or not the user has indicated a desire to provide configuration data.">wait_for_configuration()</a> is true), this function should also call <a class="el" href="class_v_c_data_source.html#a557cd159ee3f6a6f2a7f8a6044f6c57f" title="Indicate that configuration is required, and optionally provide a dictionary that describes what is n...">configuration_required()</a> and provide a description of the required configuration.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the initialization was successful; false if a fatal error ocurred </dd></dl>

</div>
</div>
<a class="anchor" id="ae4e13ae6898b84859fd6daadd6e936df"></a><!-- doxytag: member="VCDataSource::install_timer" ref="ae4e13ae6898b84859fd6daadd6e936df" args="(const char *name, double period, bool repeat, void(*callback)(VCDataSource *source, const char *name, void *context), void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::install_timer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="class_v_c_data_source.html">VCDataSource</a> *source, const char *name, void *context)&#160;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Install a timer callback. The callback will be called after a certain period, and may optionally repeat. Timers are named, and only one timer with a given name may exist at a time. Timers are fired only during calls to handle_message(). If the default <a class="el" href="class_v_c_data_source.html#ad0b62f163a1ae63f41edfea302d15003" title="The primary run loop. This function should not return until the source is ready to close...">run_source()</a> implementation is used, messages are handled continuously; if the data source is calling handle_message(), be aware that gaps in handle_message() coverage may impact the accuracy of timers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the timer. Will be provided as the second parameter of the callback when it is called. </td></tr>
    <tr><td class="paramname">period</td><td>The period of the timer, in seconds. </td></tr>
    <tr><td class="paramname">repeat</td><td>If this paramter is true, the timer will fire every period seconds. If not, it will fire after period seconds have elapsed and then remove itself. </td></tr>
    <tr><td class="paramname">callback</td><td>A pointer to the function that should be called when the timer fires. The function should take three parameters: a pointer to this data source, a pointer to the name of the timer, and a context pointer that is installed with the timer. </td></tr>
    <tr><td class="paramname">context</td><td>A user-defined context pointer, passed without modification to the callback function when it is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa14ffb8173d18f681ad5f756bda3e397"></a><!-- doxytag: member="VCDataSource::log_message" ref="aa14ffb8173d18f681ad5f756bda3e397" args="(VCLogSeverity_t severity, const char *msg,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::log_message </td>
          <td>(</td>
          <td class="paramtype">VCLogSeverity_t&#160;</td>
          <td class="paramname"> <em>severity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print a log message to the console, including a prefix that identifies the data source. The message will also be sent to the client to possibly be displayed to the user. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">severity</td><td>The severity level of the message. One of </p>
<ul>
<li>
VCLogError</li>
<li>
VCLogWarning</li>
<li>
VCLogInformation</li>
<li>
VCLogDebug</li>
</ul>
</td></tr>
    <tr><td class="paramname">msg</td><td>A printf-style format string. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments required by the format string. </td></tr>
  </table>
  </dd>
</dl>

<p><p>ds_dictionary *send_dict = new ds_dictionary(*data_dict); </p>
</p>

</div>
</div>
<a class="anchor" id="afecb992e0132166e8d41ba11bac5f9d1"></a><!-- doxytag: member="VCDataSource::lookup_command" ref="afecb992e0132166e8d41ba11bac5f9d1" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VCDataSource::lookup_command </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>path</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Look up the id of a defined command, given its path. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the command to look up. Must not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>id The id of the command with a matching path, or 0 if no such command was found. </dd></dl>

</div>
</div>
<a class="anchor" id="ae327c4926b4dc5ca68fdcb0950fae510"></a><!-- doxytag: member="VCDataSource::lookup_point" ref="ae327c4926b4dc5ca68fdcb0950fae510" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VCDataSource::lookup_point </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>path</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Look up the id of a defined point, given its path. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the point to look up. Must not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>id The id of the point with a matching path, or 0 if no such point was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a399f665acb039817fd4fa09e3288b696"></a><!-- doxytag: member="VCDataSource::metadata_complete" ref="a399f665acb039817fd4fa09e3288b696" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::metadata_complete </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicate that all metadata has been defined. The metadata will be published to clients and the storage manager, and the source will move into the VCDataSourceReady stage.</p>
<p>This function will throw an error if it is called when the stage is not VCDataSourceInitializing </p>

</div>
</div>
<a class="anchor" id="a621a1d6f119d9aef9c7e75ab0c23967c"></a><!-- doxytag: member="VCDataSource::next_command_execute_time" ref="a621a1d6f119d9aef9c7e75ab0c23967c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ds_date VCDataSource::next_command_execute_time </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the date of the next command scheduled for execution. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The date of the next command scheduled for execution. If no commands are scheduled, ds_date(0.0) is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a78a2f99099172543eb495ab1451a7864"></a><!-- doxytag: member="VCDataSource::pause" ref="a78a2f99099172543eb495ab1451a7864" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::pause </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform any actions necessary to pause the output of the source. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success; false on fatal error </dd></dl>

</div>
</div>
<a class="anchor" id="ab4d8742c72671c0e56711727cd3e91aa"></a><!-- doxytag: member="VCDataSource::remove_timer" ref="ab4d8742c72671c0e56711727cd3e91aa" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::remove_timer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>name</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove a timer and prevent it from firing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the timer to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a849b58369982977f3cca045bd03f98"></a><!-- doxytag: member="VCDataSource::reset" ref="a8a849b58369982977f3cca045bd03f98" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::reset </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform a soft reset of the source. This should involve incrementing the run number via a call to <a class="el" href="class_v_c_data_source.html#a6cc95c9ebc8e21f31e000954ae0cda5c" title="Increment the run number; all subsequent data will be sent tagged with the new run number...">increment_run()</a>. The source will move back to the Ready state after this call, and subsequently start again with another call to <a class="el" href="class_v_c_data_source.html#addb8b0e8638ee9fb921c0ac00a929d65" title="Called by the superclass to handle actions that must occur when the source transitiions to the run st...">run()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success; false on fatal error </dd></dl>

</div>
</div>
<a class="anchor" id="a88e4f7ac02ef75dab017b8a6766bb44d"></a><!-- doxytag: member="VCDataSource::resume" ref="a88e4f7ac02ef75dab017b8a6766bb44d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::resume </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform any actions necessary to resume the output of the source. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success; false on fatal error </dd></dl>

</div>
</div>
<a class="anchor" id="addb8b0e8638ee9fb921c0ac00a929d65"></a><!-- doxytag: member="VCDataSource::run" ref="addb8b0e8638ee9fb921c0ac00a929d65" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::run </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform any steps necessary to start running the source- for instance, installing data acquisition timers. The default implementation does nothing. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success; false on fatal error </dd></dl>

</div>
</div>
<a class="anchor" id="aca06f86691a993535401d4d56a151e34"></a><!-- doxytag: member="VCDataSource::run_commands_until_date" ref="aca06f86691a993535401d4d56a151e34" args="(const ds_date &amp;stop_date)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::run_commands_until_date </td>
          <td>(</td>
          <td class="paramtype">const ds_date &amp;&#160;</td>
          <td class="paramname"> <em>stop_date</em>&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cause the data source to iterate over all as-yet-unexecuted commands and call <a class="el" href="class_v_c_data_source.html#a0f4f81b9e060b23d474b590917792cf9" title="Called by the superclass to handle a specific command.">handle_command()</a> for each one with an execute time less than or equal to the provided stop date </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_date</td><td>The latest date of a command that should be executed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afad2b7a1bcc11e5f30e5bf60a6f6f6d9"></a><!-- doxytag: member="VCDataSource::run_completed" ref="afad2b7a1bcc11e5f30e5bf60a6f6f6d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::run_completed </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Indicate that the source has finished producing data for this run. The stage will be moved to VCDataSourceRunCompleted. </p>

</div>
</div>
<a class="anchor" id="ad0b62f163a1ae63f41edfea302d15003"></a><!-- doxytag: member="VCDataSource::run_source" ref="ad0b62f163a1ae63f41edfea302d15003" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::run_source </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subclasses may override this method to provide a custom run loop. If this method is overridden, the run loop must be sure to regularly call <a class="el" href="class_v_c_data_source.html#af96eb5c9904b34a7d7f898f73f650adb" title="Ask the data source to handle any messages for a period of time. Subclasses must call this at least p...">handle_messages()</a> to ensure that the data source can send and receive data from clients and the server.</p>
<p>The default implementation of this method does a simple message-handling and blocking run loop, and also handles firing installed timers at appropriate intervals. Data sources that need to block on different external entities will probably need to provide a custom implementation. </p>

</div>
</div>
<a class="anchor" id="a852a62dfb76355ac793a3bf2b6f90af8"></a><!-- doxytag: member="VCDataSource::run_subtask" ref="a852a62dfb76355ac793a3bf2b6f90af8" args="(bool dup_stdout, bool dup_stderr, int *input_fd, int *output_fd, const char *path, const char *args[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::run_subtask </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>dup_stdout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>dup_stderr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"> <em>input_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"> <em>output_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>args</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function for starting an external process and setting up pipes to read its output and write to its input. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dup_stdout</td><td>true if the subprocess's standard output should be captured </td></tr>
    <tr><td class="paramname">dup_stderr</td><td>true if the subprocess's standard error should be captured </td></tr>
    <tr><td class="paramname">input_fd</td><td>A pointer to an integer in which the file descriptor used for writing to the process's input will be stored </td></tr>
    <tr><td class="paramname">output_fd</td><td>A pointer too an integer in which the file descriptor used for reading from the process's output will be stored </td></tr>
    <tr><td class="paramname">path</td><td>The path of the process to run </td></tr>
    <tr><td class="paramname">args</td><td>An array of null-terminated strings providing arguments for the process. The first argument must be the name of the process should run; the last element of the array must be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc4917cfeee8b75f451e31db8ebe67bc"></a><!-- doxytag: member="VCDataSource::send_data" ref="adc4917cfeee8b75f451e31db8ebe67bc" args="(const ds_date &amp;datestamp, bool no_broadcast=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::send_data </td>
          <td>(</td>
          <td class="paramtype">const ds_date &amp;&#160;</td>
          <td class="paramname"> <em>datestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>no_broadcast</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send all data that has been stored since the last call to send_data, and tag each data with the provided timestamp. This function has no effect if the data source is not currently in the VCDataSourceRunning state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">datestamp</td><td>The time to be associated with the data that is being sent. </td></tr>
    <tr><td class="paramname">no_broadcast</td><td>An optional paramter, defaulting to false. If true, the data will not be sent to clients. Some data sources may bulk load data of various times when the initially start running; this flag is used for this purpose. See <a class="el" href="class_v_c_data_source.html#ab8da3ae724f2898df2b1cb605eeace2f" title="Indicate that any historical data has been loaded and sent.">complete_historical_load()</a> for more data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3db09ec0384f664ec5c106bd695fc8d"></a><!-- doxytag: member="VCDataSource::set_point_as_unlogged" ref="ab3db09ec0384f664ec5c106bd695fc8d" args="(int key, bool unlogged)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::set_point_as_unlogged </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>unlogged</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mark a point as unlogged- that is, its data will not be stored or cached, such that historical data cannot be retrieved. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The id of the point to affect </td></tr>
    <tr><td class="paramname">unlogged</td><td>True if the point should not be logged; false (the default) if it should be logged and its data saved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf039bd2e0ea0c905fdb810a28975d6c"></a><!-- doxytag: member="VCDataSource::setup_metadata" ref="acf039bd2e0ea0c905fdb810a28975d6c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::setup_metadata </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define the points and commands that make up this source's data tree. Before returning from this function, <a class="el" href="class_v_c_data_source.html#a399f665acb039817fd4fa09e3288b696" title="Indicate that the source has has defined all of the required metadata.">metadata_complete()</a> should be called. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success; false on fatal error </dd></dl>

</div>
</div>
<a class="anchor" id="a560f8b0e8c645a41565055ae1738e265"></a><!-- doxytag: member="VCDataSource::stage" ref="a560f8b0e8c645a41565055ae1738e265" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VCDataSourceState_t VCDataSource::stage </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the current stage for the data source. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current stage, one of: <ul>
<li>
VCDataSourceStarting </li>
<li>
VCDataSourceNeedsConfig </li>
<li>
VCDataSourceInitializing </li>
<li>
VCDataSourceReady </li>
<li>
VCDataSourceRunning </li>
<li>
VCDataSourcePaused </li>
<li>
VCDataSourceCompleted </li>
<li>
VCDataSourceTerminated </li>
<li>
VCDataSourceError </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa3ad3e34bd57eeea63e85c18f8fe7548"></a><!-- doxytag: member="VCDataSource::store_data" ref="aa3ad3e34bd57eeea63e85c18f8fe7548" args="(int index, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::store_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Provide data for a point. This function does not actually send out the data, or associate the data with a timestamp; see <a class="el" href="class_v_c_data_source.html#adc4917cfeee8b75f451e31db8ebe67bc" title="Send the values of all points that have been updated since the last store_data() call.">send_data()</a>. If the data source is not currently in the VCDataSourceRunning state, this function will have no effect. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The id of the point to set data for. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the data to be set. Must be appropriate for the type of the data point. For instance, if the data point is of type sd_type_double, this parameter should be a pointer to a double. If the data point is of type sd_type_matrix, this paramter should be a pointer to a matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_v_c_data_source.html#adc4917cfeee8b75f451e31db8ebe67bc" title="Send the values of all points that have been updated since the last store_data() call.">send_data()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abd11a23ab778f75e497c722c640b4e5e"></a><!-- doxytag: member="VCDataSource::terminate" ref="abd11a23ab778f75e497c722c640b4e5e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::terminate </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform any cleanup that should happen when the data source is terminated. Terminated sources exit shortly thereafter. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success; false on fatal error </dd></dl>

</div>
</div>
<a class="anchor" id="adc3c023a1eedb9c10244aaa567d90752"></a><!-- doxytag: member="VCDataSource::throw_error" ref="adc3c023a1eedb9c10244aaa567d90752" args="(const char *msg,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VCDataSource::throw_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cause the data source to enter the VCDataSourceError state, and print an error message to the console. The message will also be sent to clients to be displayed to the user. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>A printf-style format string. </td></tr>
    <tr><td class="paramname">...</td><td>Arguments required by the format string. </td></tr>
  </table>
  </dd>
</dl>

<p><p>ds_dictionary *send_dict = new ds_dictionary(*data_dict); </p>
</p>

</div>
</div>
<a class="anchor" id="ab1c68f11c4994ac3d34caf98006ffafb"></a><!-- doxytag: member="VCDataSource::unpack_data" ref="ab1c68f11c4994ac3d34caf98006ffafb" args="(void *destination, int data_type, void *data, unsigned int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VCDataSource::unpack_data </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>data_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"> <em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unpack the raw data provided with a command into a usable location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>A pointer to the location where the unpacked data should go. For instance, if the data type is double, this parameter should point to valid, allocated space for a double. If the data type is matrix, this parameter should point to a valid ml_matrix object. </td></tr>
    <tr><td class="paramname">data_type</td><td>The data type for the data. </td></tr>
    <tr><td class="paramname">data</td><td>The raw data buffer to unpack. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the raw data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If the unpacking is successful, returns true; otherwise returns false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>VCDataSource.h</li>
<li>VCDataSource.cc</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 19 2011 13:54:23 for VisualCommander by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
