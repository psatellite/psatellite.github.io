<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DSim: Simulation Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="index.html">index</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Simulation Architecture </h1>  </div>
</div>
<div class="contents">
<p><a class="el" href="architecture.html#intro">Introduction</a><br/>
 <a class="el" href="architecture.html#loop">The Simulation Loop</a><br/>
 <a class="el" href="architecture.html#outlets">Model Connections</a><br/>
 <a class="el" href="architecture.html#interactions">Messaging</a><br/>
 <a class="el" href="architecture.html#variables">Variables</a><br/>
</p>
<h2><a class="anchor" id="intro"></a>
Introduction</h2>
<p>DSim is a <em>hierarchical</em>, <em>object-oriented</em> simulation framework. What this means that in practical terms is that a simulation is composed of <em>instantiations</em> of a set of reusable <em>models</em>, and that these objects can then be arranged in a hierarchical tree. For example, we might have an object called Satellite that represents the physical body of a spacecraft. One of its child objects would be the object for its thruster. We might also have another <em>top-level</em> object representing the Earth; this separate top-level object would be part of the simulation but would be at the same 'level' as the Satellite- neither would be hierarchically above the other.</p>
<p>Objects are instantiations of <em>models</em>. A model is a class in C++ that derives from the appropriately named <a class="el" href="classdsim__model.html" title="Superclass for all simulated objects.">dsim_model</a> class in the DSim framework. Models are generally organized into <em>libraries</em>. DSim knows how to load these external libraries and create objects from the models contained within. The model describes all of the attributes that objects instantiated from the model have: position, velocity, temperature, etc. Each model can have an entirely different set of <em>variables</em> associated with it. Each model also provides the code that updates the variables as the simulation progresses, both by providing derivatives of integrated variables (DSim then does the actual integration) and directly updating non-integrated variables that still need to change each timestep. Each object instantiated from a particular model thus has the same attributes and dynamics, but the particular values will be different in each case.</p>
<p>The setup and relationships of the objects in a simulation are specified in a simulation setup file (see <a class="el" href="setup.html">Setup Files</a>), also known as a ds2 file because of the extension used. Some simulation parameters, such as timestep, and the initial values for the objects' variables and states can be specified as well. These files are plain-text XML files. On Mac OS X, these setup files can be built using DSim Manager.</p>
<h2><a class="anchor" id="loop"></a>
The Simulation Loop</h2>
<p>As the physical simulation, DSim is strongly deterministic and does not allow for the more complicated programming structures available within ControlDeck. Models implement certain methods to update variables at specific times. The entire simulation operates on a single timestep, and the simulation engine will step through a specific sequence of function calls within a loop. You can investigate this API for more information on what the functions do, but the structure of the loop is shown below.</p>
<hr/>
 <ul>
<li>
Instantiate all objects; </li>
<li>
FOR ALL objects DO initialize_data(); </li>
<li>
FOR ALL objects DO initialization_complete(); </li>
</ul>
<ul>
<li>
REPEAT <ul>
<li>
FOR ALL objects DO initialize_timestep(); </li>
<li>
FOR ALL objects DO pre_calculate(); </li>
</ul>
<ul>
<li>
REPEAT - Enter the integration loop within this timestep <ul>
<li>
FOR ALL integrators DO start_integration(); </li>
<li>
FOR ALL objects DO rhs(); </li>
<li>
FOR ALL integrators DO complete_integration_step(); </li>
<li>
IF (integrator needs timestep restart) THEN update timestep and restart integration </li>
</ul>
</li>
</ul>
<ul>
<li>
UNTIL all integrators are complete </li>
<li>
FOR ALL objects DO post_calculate(); </li>
<li>
FOR ALL objects DO complete_timestep(); </li>
</ul>
</li>
<li>
UNTIL simulation is complete </li>
</ul>
<hr/>
<p>It is important to note that each object within the simulation is considered to be independent unless a dependency is created between two objects. When "foo" is marked as dependent upon "bar", DSim will ensure that, at each step of the simulation, methods are called on "bar" before they are called on "foo". This allows you to ensure that objects update in the proper order. If there are no dependencies between two objects, you cannot rely on the relative order of function calls between those objects.</p>
<h2><a class="anchor" id="outlets"></a>
Model Connections</h2>
<p>Outlets enable variable values from one model to be sent to another. Each outlet must be associated with a source component which provides the variable. The path to the parameter consists of the component hierarchy with components separated by a pipe (|) and the parameter separated by a colon. For instance, ParentObject|ChildObject:param1. Outlets are useful for connecting data between any objects with other than a simple parent-child relationship.</p>
<p>Outlets are configured in the setup file. See datamanagement and create_outlet().</p>
<h2><a class="anchor" id="interactions"></a>
Messaging</h2>
<p>Most inter-object communication within DSim happens by way of setting and reading variables. However, there are times when this is not the most appropriate form of communication. When something better is needed, messages can be used. Targets allow message destinations to be configurable via the setup file. See the <a class="el" href="group__model__messaging.html">Model Messaging</a> module.</p>
<h3><a class="anchor" id="Messages"></a>
Messages</h3>
<p>Messages allow an object to send a value, with a message name, to another object. The best example of this from the base DSim is the application of forces and torques to the built-in <a class="el" href="classdsim__rigid__body.html" title="Built-in example class for rigid body objects.This class provides variables for a physical object...">dsim_rigid_body</a> model. Objects which wish to apply a force to a <a class="el" href="classdsim__rigid__body.html" title="Built-in example class for rigid body objects.This class provides variables for a physical object...">dsim_rigid_body</a> object send it an apply_force message, along with the force that they wish to apply. The <a class="el" href="classdsim__rigid__body.html" title="Built-in example class for rigid body objects.This class provides variables for a physical object...">dsim_rigid_body</a> object records and aggregates all of these forces, and then applies them the next time its rhs() function is called to compute state derivatives. Any number of other objects can in this way apply forces to a single object. The message passing, and the recipient's handling of it, is immediate and synchronous: the recipient will have handled the message before the send_message call returns.</p>
<p>Messages may also receive return values. The message handler that is called when a message is received has the option of returning a value back to the sender. For instance, if object A applies a force to object B, object B might choose to return a force that it, in turn, applies to object A.</p>
<h3><a class="anchor" id="Targets"></a>
Targets</h3>
<p>Targets allow connections between objects to be specified within the simulation setup file, rather than hard-coded into the model. For example, consider a simple mass-spring simulation where we have two models: one representing the mass, and one representing the spring. In developing the model for the spring, we'd like it to be reusable; at the same time we know we need to send a message to the mass at each timestep to apply the appropriate force. How can we accomplish this?</p>
<p>The correct method is via a target. The spring model creates the target during initialization. The user who sets up the simulation, then, sees that the spring has a target and connects it to the mass object. At runtime, then, the spring looks up the position variable at whatever object the target points to, and simply sends its apply_force message to the same: the code doesn't care where the variable is located or where message is going; it just knows that its going to some other object that has a position variable and can respond to an apply_force message. Basically, you should never hard-code paths or object names into your model code: instead, use targets.</p>
<p>While the example above has a target pointing to a single destination, it's possible for a target to be multidirectional, in which case the target actually points to a set of objects rather than a single one. The general principle is the same, but the code would be written to iterate over the set of objects pointed to by the target rather than simply getting a single value from the target. This might be used to help model a broadcast communication system, for instance.</p>
<h2><a class="anchor" id="networks"></a>
Networks</h2>
<p>Networks allow you to connect multiple modules together so simulate power, thermal, electrical and other kinds of networks.</p>
<p>Connections are directed. In your power object that's managing the network, it iterates through the connections, looks up the object that is the destination of the connection, and asks that destination object for its "power" variable. Given that, you need to make sure that your dsim setup file has, for each of those connections, the power object as the *source* and the other object, the one in the network, as the destination.</p>
<h2><a class="anchor" id="variables"></a>
Variables</h2>
<p>All DSim objects interact with DSim variables in order to implement functionality and affect simulation step. These variables are distinct from the general member variables of the C++ programming language; instead, they are instances of the <a class="el" href="classdsim__variable.html" title="Rperesents a variable or outlet created and managed by an object in a simulation.">dsim_variable</a> objects. They represent inputs, outputs, and states of the objects being simulated.</p>
<p>It's important to note that DSim only makes a single distinction when it comes to variables: whether or not they are integrated. Integrated variables must be treated specially by the framework. However, there are a number of other possible variable types: inputs, outputs, parameters, etc. These other variable types are there simply to make the model more self-documenting, especially when using DSim Manager to construct a simulation.</p>
<p>Models create their own variables, and can get and set their values freely. Models may also request the variables that are created by other models; once these "remote" variables have been requested, the model can interact with them the same way that it can interact with "local" (self-created) variables. It is up to the model writer to avoid improperly setting the value of a remote object's variable.</p>
<p>Models must be aware of whether or not the variables with which they are interacting are co-integrated or not. A model, having requested a variable from another object, may either enable or disable co-integrated mode for the variable. While DSim is performing the integration loop within a timestamp, an integrated variables value may be changing over the course of the integration according to the integrator being used by that variable's creating model. When an object is looking at a variable in co-integrated mode, that object will always see the most recent value of the variable, and will see these changes over the course of integration. However, when an object is looking at a variable that is not in co-integrated mode, it will always see the value of the variable immediately prior to the beginning of the integration loop; it will not see updates over the course of integration.</p>
<p>Objects using different integrators should always be careful to avoid co-integrated mode on variables from the remote object, since updates during the course of integration may not have matching times or meaning. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 5 2013 16:46:48 for DSim by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
