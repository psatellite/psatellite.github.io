<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DSim: Developers Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="index.html">index</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Developers Guide </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="migration_models"></a>
Models</h2>
<p>A "model" is a class that derives from <a class="el" href="classdsim__model.html" title="Superclass for all simulated objects.">dsim_model</a> (the highest superclass). An "object" is an actual instance of a model inside a simulation.</p>
<p>All models must descend, either directly or indirectly, from <a class="el" href="classdsim__model.html" title="Superclass for all simulated objects.">dsim_model</a>. If you'd like to subclass from a model that provides rigid body dynamics, you can subclass from <a class="el" href="classdsim__rigid__body.html" title="Built-in example class for rigid body objects.This class provides variables for a physical object...">dsim_rigid_body</a>.</p>
<h2><a class="anchor" id="migration_variables"></a>
Variables and States</h2>
<p>All variables and states start out as a member variable of your class, of type "dsim_variable". For instance, to create a variable, state, or outlet called "foo", your class header file would contain "dsim_variable foo;" in your list of member variables in your class.</p>
<p>What you do with that variable during initialization will determine how DSim handles it. If you'd like it to be an integrated state, you call dsim_model::create_integrated_state() and store the result in your member variable. If you want to publish it as a variable, but not have it be integrated, you call one of the other create_* functions: <a class="el" href="group__model__datamanagement.html#ga1032ea1580992c97a4e592e7e889ed0d">dsim_model::create_parameter()</a>, <a class="el" href="group__model__datamanagement.html#gafed3a6b7fba06ff2a7425c74867c9073">dsim_model::create_input()</a>, <a class="el" href="group__model__datamanagement.html#ga69ece3aa09aba661e3c6658c17034d94">dsim_model::create_output()</a>, <a class="el" href="group__model__datamanagement.html#gac76bd30388f4d7a5be13d126454ff2f6">dsim_model::create_state()</a>. All of these are functionally identical; the only difference is that each marks the variable for different usage. The usages are merely hints to users of your model when it is being configured in a simulation (and potentially in whatever application is running the simulation, like VisualCommander); the variables are otherwise identical. (In fact, <a class="el" href="group__model__datamanagement.html#ga9e45c0da226c377fa9e6174deacf42fc">dsim_model::create_integrated_state()</a> is also nearly identical- it just sets a different usage and registers the variable with your object's integrator.) If you want a variable to be an outlet, you call <a class="el" href="group__model__datamanagement.html#ga9cc14772d4ec469daa90724697b40999">dsim_model::create_outlet()</a> with the variable as the first parameter.</p>
<p>Note that in all of these cases, the variable started life the same way: a <a class="el" href="classdsim__variable.html" title="Rperesents a variable or outlet created and managed by an object in a simulation.">dsim_variable</a> member variable of your class. This means that once you've set it up (an outlet, an integrated state, etc), you can interact with it in the same way regardless of what type you've chosen for it. Call the various set methods on it to set its value or derivative, and use the get functions to get its current value. This also means that (with the exception of outlets), all of your variables appear the same way to external entities: state or not, it can be logged, looked up by other objects, and marked as telemetry or as a command. The entire variable/state/outlet system has been unified, and all of the functionality is encapsulated by the create_* functions and by the member functions of <a class="el" href="classdsim__variable.html" title="Rperesents a variable or outlet created and managed by an object in a simulation.">dsim_variable</a>.</p>
<h2><a class="anchor" id="migration_initialization"></a>
Initialization</h2>
<p>You can initialize member variables in your constructor, but not <a class="el" href="classdsim__variable.html" title="Rperesents a variable or outlet created and managed by an object in a simulation.">dsim_variable</a>. Your <a class="el" href="group__model__initialization.html#ga499b530ceb3e95eb737d2aa1fa6c6c88">dsim_model::initialize_data()</a> function should take care of all of your initial DSim calls- notably, setting up your variables and outlets. Do not attempt to *use* the variables or outlets yet, or attempt to look up anything else; your custom setup parsing will not have been called yet, and not all of the objects in the simulation will have been initialized when initialize_data() is called.</p>
<p>The <a class="el" href="group__model__initialization.html#gac9ef83c74f584d1677e3326fefd9db71">dsim_model::initialization_complete()</a> function is the place to put any initialization that needs to happen at a time when the simulation is entirely constructed and set up. When this function is called, all of your custom setup lines will have been parsed, any outlets, targets, and networks will have been fully connected and populated, etc. This is also where you might call the configure_timestep() function, if you need to configure what timestep methods DSim calls on your object. (Turning off function calls is entirely a performance optimization, but it can be a very important one, especially in multithreaded or distributed environments.)</p>
<h2><a class="anchor" id="migration_integration"></a>
Integration</h2>
<p>Your model implements the rhs() function, and within that function the derivatives of your integrated variables are calculated and stored. You call <a class="el" href="classdsim__variable.html#a5254ad1019659c596863c7b5a02f2efe" title="Sets the current derivative of this variable by providing a data type and a raw value pointer...">dsim_variable::set_derivative()</a> on the variable for your state to store the derivative you have calculated. For model interactions affecting the right-hand-side such as forces and torques in a physical system, use a message to send the values to the destination object.</p>
<h3><a class="anchor" id="migration_whymessages"></a>
Why messages?</h3>
<p>The first question you might ask is, why messages? The simple answer is because they allow the receiving object to perform an action as many times per timestep as a message arrives, and to do so the moment the message arrives, rather than only being able to do so at predefined times during the timestep. By having the rigid body accept apply_force and apply_torque messages, each force and torque can be summed together, and then the sum can be used during the next rhs() call on the parent rigid body.</p>
<h3><a class="anchor" id="migration_messagehandling"></a>
How do I receive messages?</h3>
<p>Setting a model up to handle incoming messages is quite trivial: simply override the dsim_model::handle_message() function. Doing so is generally straightforward, and quite similar to overriding dsim_model::parse_setup() for handling setup commands. The following is the <a class="el" href="classdsim__rigid__body.html" title="Built-in example class for rigid body objects.This class provides variables for a physical object...">dsim_rigid_body</a> handle_message function, which allows it to handle apply_force and apply_torque commands:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="classdsim__value.html" title="Represents the value of a variable or message.">dsim_value</a> <a class="code" href="classdsim__rigid__body.html#aa528fe581e72943f538448ac026c127e">dsim_rigid_body::handle_message</a>(<span class="keyword">const</span> std::string &amp;sender_path,<span class="keyword">const</span> std::string &amp;message_name,<span class="keyword">const</span> <a class="code" href="classdsim__value.html" title="Represents the value of a variable or message.">dsim_value</a> &amp;argument)
{
    <span class="keywordflow">if</span> (message_name == <span class="stringliteral">&quot;apply_force&quot;</span>)
    {
        force+=argument.<a class="code" href="classdsim__value.html#ab176e2a5397b08eec4a2fb0309b0e27f" title="Returns the value of this object, if it holds a matrix data value.">matrix_value</a>();
        <span class="keywordflow">return</span> <a class="code" href="classdsim__value.html" title="Represents the value of a variable or message.">dsim_value</a>();
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (message_name == <span class="stringliteral">&quot;apply_torque&quot;</span>)
    {
        torque+=argument.<a class="code" href="classdsim__value.html#ab176e2a5397b08eec4a2fb0309b0e27f" title="Returns the value of this object, if it holds a matrix data value.">matrix_value</a>();
        <span class="keywordflow">return</span> <a class="code" href="classdsim__value.html" title="Represents the value of a variable or message.">dsim_value</a>();
    }
    <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="classdsim__rigid__body.html#aa528fe581e72943f538448ac026c127e">dsim_model::handle_message</a>(sender_path,message_name,argument);
}
</pre></div><h3><a class="anchor" id="migration_messagesending"></a>
How do I send messages?</h3>
<p>Sending messages is even more trivial than receiving them. Your model simply needs to know the path of the object to which the message should be sent. The easiest way to do that is to create a target with <a class="el" href="group__model__messaging.html#ga2018010e9cf7ceafd344f604d30278bc">dsim_model::create_target()</a>, and then have the target path be set up in the setup file. An example of sending messages via target is below, taken from the builtin <a class="el" href="classdsim__ideal__spring.html" title="Builtin model of a simple spring.Spring model that applies a force to a parent or other target object...">dsim_ideal_spring</a> object. (In the example, target_pos, spring_base and spring_k are all dsim_variables. The code is taken from the spring's rhs() function.)</p>
<div class="fragment"><pre class="fragment">ml_matrix p = target_pos.value_as_matrix();
ml_matrix force = (spring_base.value_as_matrix() - p) * spring_k.value_as_double();
<a class="code" href="classdsim__value.html" title="Represents the value of a variable or message.">dsim_value</a> fval(force);
<span class="keyword">const</span> <span class="keywordtype">char</span> *target_path = lookup_target(<span class="stringliteral">&quot;mass&quot;</span>);
send_message(target_path,<span class="stringliteral">&quot;apply_force&quot;</span>,fval);
</pre></div><h2><a class="anchor" id="migration_networks"></a>
Networks</h2>
<p>Managed networks enable models to create a web of connections, such as for a power network. See the <a class="el" href="group__model__networks.html">Model Networks</a> for the functions needed in the <a class="el" href="classdsim__model.html" title="Superclass for all simulated objects.">dsim_model</a> and the <a class="el" href="classdsim__network.html" title="Represents a network of simulation objects.">dsim_network</a> class page.</p>
<p>For example in your model's initialize_data() function, you would create the network and declare its variables.</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// The power network</span>
    power_network_dsim = create_managed_network(<span class="stringliteral">&quot;power&quot;</span>, <span class="stringliteral">&quot;Power system network&quot;</span> );

    <span class="comment">// The variable in the network</span>
    power_network_dsim-&gt;declare_variable(<span class="stringliteral">&quot;power&quot;</span>, sd_type_double, <span class="stringliteral">&quot;Power input or output&quot;</span>);
</pre></div><p>which creates the network and declares a variable in the network. Then to implement the network, you iterate over its elements. The nodes, in this case, are dsim_variables of type "power".</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classdsim__connection__iterator.html" title="Iterator for connections within a network.">dsim_connection_iterator</a> iterator = power_network_dsim-&gt;connection_iterator();

    <span class="keywordtype">double</span> net_power = 0;
    <span class="keywordtype">int</span> c_count = power_network_dsim-&gt;connection_count();

     <span class="comment">// If there are any connections find the power consumed or produced</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; c_count; k++ )
    {
        <a class="code" href="classdsim__connection.html" title="Represents a connection between two objects within a network.">dsim_connection</a> *c = iterator.<a class="code" href="classdsim__connection__iterator.html#acce73454d20f6fd8bbf1aa087dd636ab" title="Retrieves the connection associated with the iterator&amp;#39;s current state.">connection</a>();
        std::string variable_path = std::string(c-&gt;<a class="code" href="classdsim__connection.html#a6cecd1104c53b453b0ac62975a696357" title="Retrieve the destination model of this connection.">destination_path</a>()) + <span class="stringliteral">&quot;:power&quot;</span>;
        <a class="code" href="classdsim__variable.html" title="Rperesents a variable or outlet created and managed by an object in a simulation.">dsim_variable</a> var = request_variable(variable_path.c_str());
        <a class="code" href="classdsim__value.html" title="Represents the value of a variable or message.">dsim_value</a> v = var.value(); <span class="comment">// or var.cointegrated_value() if desired</span>
        <span class="keywordflow">if</span> (v.valid())
        {
            net_power += v.<a class="code" href="classdsim__value.html#a6feedc92cb12cf725e8b9840588fbe5d" title="Returns the value of this object, if it holds a double data value.">double_value</a>();
        }
        iterator.<a class="code" href="classdsim__connection__iterator.html#a5db1f0c4c0523886c92f64f7b8952cb6" title="Moves the iterator to the next connection in the set.">next</a>();
    }
</pre></div> </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 5 2013 16:46:48 for DSim by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
