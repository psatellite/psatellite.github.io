<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Spacecraft Control Framework: sc_formation.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sc_formation.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Holds the FFLib data structures and function definitions.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alfriend orbital elements data structure.  <a href="structalf__orb__data__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structteam__s.html">team_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Team data structure.  <a href="structteam__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstate__s.html">state_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">State data structure.  <a href="structstate__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgeom__s.html">geom_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Geometry data structure.  <a href="structgeom__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecc__geom__s.html">ecc_geom_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Eccentric geometry data structure.  <a href="structecc__geom__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecc__geom__xy__s.html">ecc_geom_xy_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Eccentric geometry data structure (xy)  <a href="structecc__geom__xy__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwindow__s.html">window_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Time window data structure.  <a href="structwindow__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplan__param__s.html">plan_param_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Planning parameters data structure.  <a href="structplan__param__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconstraints__s.html">constraints_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraints data structure.  <a href="structconstraints__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structteam__goals__s.html">team_goals_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Team goals data structure.  <a href="structteam__goals__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structecc__team__goals__s.html">ecc_team_goals_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Eccentric team goals data structure.  <a href="structecc__team__goals__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcost__s.html">cost_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost estimate data structure.  <a href="structcost__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structburn__s.html">burn_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Burn data structure.  <a href="structburn__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmaneuver__s.html">maneuver_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maneuver data structure.  <a href="structmaneuver__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdv__command__s.html">dv_command_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delta-V command data structure.  <a href="structdv__command__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structorientation__s.html">orientation_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Orientation data structure.  <a href="structorientation__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structassign__s.html">assign_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment data structure.  <a href="structassign__s.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcoll__mon__data__s.html">coll_mon_data_s</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision monitor data.  <a href="structcoll__mon__data__s.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fbf79fc1742c2a76ab253731892afb3"></a><!-- doxytag: member="sc_formation.h::FF_J2" ref="a8fbf79fc1742c2a76ab253731892afb3" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a8fbf79fc1742c2a76ab253731892afb3">FF_J2</a>&#160;&#160;&#160;0.001082</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">J2 perturbation is 0.001082. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a175ba4347f1786d726092db8c4954eb2"></a><!-- doxytag: member="sc_formation.h::FF_TOL" ref="a175ba4347f1786d726092db8c4954eb2" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a175ba4347f1786d726092db8c4954eb2">FF_TOL</a>&#160;&#160;&#160;1e-8</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the default tolerance to use in comparing doubles. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9e1a19d9bfaa77594eb62a3547375ce"></a><!-- doxytag: member="sc_formation.h::FF_MAX_ITER" ref="ab9e1a19d9bfaa77594eb62a3547375ce" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab9e1a19d9bfaa77594eb62a3547375ce">FF_MAX_ITER</a>&#160;&#160;&#160;100</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the default value for maximum number of iterations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a093f319e93de7d7f47a8520a5c7e806d"></a><!-- doxytag: member="sc_formation.h::FF_MAX_BURNS" ref="a093f319e93de7d7f47a8520a5c7e806d" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a093f319e93de7d7f47a8520a5c7e806d">FF_MAX_BURNS</a>&#160;&#160;&#160;10</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the maximum number of impulsive burns that can be included in a maneuver data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20226374291e7b458fd7aff076dd16fc"></a><!-- doxytag: member="sc_formation.h::FF_MAX_MEMBERS" ref="a20226374291e7b458fd7aff076dd16fc" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a20226374291e7b458fd7aff076dd16fc">FF_MAX_MEMBERS</a>&#160;&#160;&#160;8</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the maximum number of satellite members that can be on a given team. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a414c462abb643132484263a01165abeb"></a><!-- doxytag: member="sc_formation.h::SC_OS_MACOSX" ref="a414c462abb643132484263a01165abeb" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a414c462abb643132484263a01165abeb">SC_OS_MACOSX</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mac OS X. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d062c0ad0d0841a15dabaf3e8fc7252"></a><!-- doxytag: member="sc_formation.h::SC_OS_UNIX" ref="a9d062c0ad0d0841a15dabaf3e8fc7252" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a9d062c0ad0d0841a15dabaf3e8fc7252">SC_OS_UNIX</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIX OS. <br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a667e490f550eebb36a45da1a9ad29d52"></a><!-- doxytag: member="sc_formation.h::alf_orb_data_t" ref="a667e490f550eebb36a45da1a9ad29d52" args="" -->
typedef struct <a class="el" href="structalf__orb__data__s.html">alf_orb_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a667e490f550eebb36a45da1a9ad29d52">alf_orb_data_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Alfriend orbital elements data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2522508e5f23e40e8fcc92cd30b34744"></a><!-- doxytag: member="sc_formation.h::team_t" ref="a2522508e5f23e40e8fcc92cd30b34744" args="" -->
typedef struct <a class="el" href="structteam__s.html">team_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a2522508e5f23e40e8fcc92cd30b34744">team_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Team data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a1f5593e91c08333e9071cbb5a9495a"></a><!-- doxytag: member="sc_formation.h::state_t" ref="a2a1f5593e91c08333e9071cbb5a9495a" args="" -->
typedef struct <a class="el" href="structstate__s.html">state_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a2a1f5593e91c08333e9071cbb5a9495a">state_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">State data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dac7a8b1b02bc1e2fb8ec90983a5d94"></a><!-- doxytag: member="sc_formation.h::geom_t" ref="a0dac7a8b1b02bc1e2fb8ec90983a5d94" args="" -->
typedef struct <a class="el" href="structgeom__s.html">geom_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a0dac7a8b1b02bc1e2fb8ec90983a5d94">geom_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Geometry data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63702ca149e9a2ac3568acb236cfee8e"></a><!-- doxytag: member="sc_formation.h::ecc_geom_t" ref="a63702ca149e9a2ac3568acb236cfee8e" args="" -->
typedef struct <a class="el" href="structecc__geom__s.html">ecc_geom_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a63702ca149e9a2ac3568acb236cfee8e">ecc_geom_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Eccentric geometry data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5a36ef7041ac870fa24d2137d0ff661"></a><!-- doxytag: member="sc_formation.h::ecc_geom_xy_t" ref="ad5a36ef7041ac870fa24d2137d0ff661" args="" -->
typedef struct <a class="el" href="structecc__geom__xy__s.html">ecc_geom_xy_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ad5a36ef7041ac870fa24d2137d0ff661">ecc_geom_xy_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Eccentric geometry data structure (xy) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad84d422199d47144ddd72ad74be790b9"></a><!-- doxytag: member="sc_formation.h::window_t" ref="ad84d422199d47144ddd72ad74be790b9" args="" -->
typedef struct <a class="el" href="structwindow__s.html">window_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ad84d422199d47144ddd72ad74be790b9">window_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Time window data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe5222c2c1c6a0f5e2f3cc925e8650d1"></a><!-- doxytag: member="sc_formation.h::plan_param_t" ref="abe5222c2c1c6a0f5e2f3cc925e8650d1" args="" -->
typedef struct <a class="el" href="structplan__param__s.html">plan_param_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#abe5222c2c1c6a0f5e2f3cc925e8650d1">plan_param_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Planning parameters data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a438bdc649b74e38041a0a70b6225d4fb"></a><!-- doxytag: member="sc_formation.h::constraints_t" ref="a438bdc649b74e38041a0a70b6225d4fb" args="" -->
typedef struct <a class="el" href="structconstraints__s.html">constraints_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a438bdc649b74e38041a0a70b6225d4fb">constraints_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraints data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abadc123ca40320e75d4b8b605ceeaa7e"></a><!-- doxytag: member="sc_formation.h::team_goals_t" ref="abadc123ca40320e75d4b8b605ceeaa7e" args="" -->
typedef struct <a class="el" href="structteam__goals__s.html">team_goals_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#abadc123ca40320e75d4b8b605ceeaa7e">team_goals_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Team goals data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34404b4c05bf02c45e116d9ba9b28e63"></a><!-- doxytag: member="sc_formation.h::ecc_team_goals_t" ref="a34404b4c05bf02c45e116d9ba9b28e63" args="" -->
typedef struct <a class="el" href="structecc__team__goals__s.html">ecc_team_goals_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a34404b4c05bf02c45e116d9ba9b28e63">ecc_team_goals_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Eccentric team goals data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d5e4245f757e428d9d638a2a21bec9f"></a><!-- doxytag: member="sc_formation.h::cost_t" ref="a7d5e4245f757e428d9d638a2a21bec9f" args="" -->
typedef struct <a class="el" href="structcost__s.html">cost_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a7d5e4245f757e428d9d638a2a21bec9f">cost_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost estimate data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a552df6c7c811761669bd3689d7a8345d"></a><!-- doxytag: member="sc_formation.h::burn_t" ref="a552df6c7c811761669bd3689d7a8345d" args="" -->
typedef struct <a class="el" href="structburn__s.html">burn_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a552df6c7c811761669bd3689d7a8345d">burn_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Burn data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9afca134d42c7adaed9a49625924b92d"></a><!-- doxytag: member="sc_formation.h::maneuver_t" ref="a9afca134d42c7adaed9a49625924b92d" args="" -->
typedef struct <a class="el" href="structmaneuver__s.html">maneuver_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a9afca134d42c7adaed9a49625924b92d">maneuver_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maneuver data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb8e950113110e987531357c03da1fa3"></a><!-- doxytag: member="sc_formation.h::dv_command_t" ref="afb8e950113110e987531357c03da1fa3" args="" -->
typedef struct <a class="el" href="structdv__command__s.html">dv_command_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#afb8e950113110e987531357c03da1fa3">dv_command_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delta-V command data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadac85d13b2401ccb250dacaae7e5d0c"></a><!-- doxytag: member="sc_formation.h::orientation_t" ref="aadac85d13b2401ccb250dacaae7e5d0c" args="" -->
typedef struct <a class="el" href="structorientation__s.html">orientation_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aadac85d13b2401ccb250dacaae7e5d0c">orientation_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Orientation data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c0556c2a6bdebdbabeddd5d85ac54e6"></a><!-- doxytag: member="sc_formation.h::assign_t" ref="a9c0556c2a6bdebdbabeddd5d85ac54e6" args="" -->
typedef struct <a class="el" href="structassign__s.html">assign_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a9c0556c2a6bdebdbabeddd5d85ac54e6">assign_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69fd016ddfcc739e104b843190c6910a"></a><!-- doxytag: member="sc_formation.h::coll_mon_data_t" ref="a69fd016ddfcc739e104b843190c6910a" args="" -->
typedef struct <a class="el" href="structcoll__mon__data__s.html">coll_mon_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a69fd016ddfcc739e104b843190c6910a">coll_mon_data_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision monitor data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fa4abb0140a90beae0fc1558175e342"></a><!-- doxytag: member="sc_formation.h::nr_function" ref="a1fa4abb0140a90beae0fc1558175e342" args=")(double x, double e, const ml_matrix &amp;D, double dH)" -->
typedef double(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a1fa4abb0140a90beae0fc1558175e342">nr_function</a> )(double x, double e, const ml_matrix &amp;D, double dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton-Raphson function. <br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#adeef5cd747bd2af449438b91d4aecd93">ff_error_codes</a> { <a class="el" href="sc__formation_8h.html#adeef5cd747bd2af449438b91d4aecd93a35d14b8c6dbc4dc4d465f246238ce6a1">FF_NO_ERROR</a> =  0, 
<a class="el" href="sc__formation_8h.html#adeef5cd747bd2af449438b91d4aecd93a41c90786cdf6d472deaa2a3b1481ad8f">FF_NO_SOLN</a> =  1, 
<a class="el" href="sc__formation_8h.html#adeef5cd747bd2af449438b91d4aecd93a153b7c87c9b2de9b99d6872e00658033">FF_MAX_ITER</a> =  2, 
<a class="el" href="sc__formation_8h.html#adeef5cd747bd2af449438b91d4aecd93a81c1d0b02ea5b8bcd6594105e74b0c78">FF_BAD_VALUE</a> =  3
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Error codes for invalid matrix operations. </p>
 <a href="sc__formation_8h.html#adeef5cd747bd2af449438b91d4aecd93">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5a">ff_formation_types</a> { <br/>
&#160;&#160;<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa06b2fd15913aea7e8bb4430081d9163c">FF_IPLF</a> =  1, 
<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa0a7cee1fde4b78838173a2d9d987edd3">FF_OOPLF_RGT</a> =  2, 
<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa0eb99898ac2f91ce66481a8b6af967c3">FF_CIPE_REF_CENTER</a> =  3, 
<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa19140e073540c844fe704a7a430ecb20">FF_CIPE_REF_ON</a> =  4, 
<br/>
&#160;&#160;<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa83b8268d7866574ec605bf6d13351ca3">FF_POS_PROJ_CIRC_REF_CENTER</a> =  5, 
<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aaaf3c8172172f0d49b1a1a7f54c82c607">FF_POS_PROJ_CIRC_REF_ON</a> =  6, 
<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa3cfb553f361551d1fb68db4db78c390b">FF_NEG_PROJ_CIRC_REF_CENTER</a> =  7, 
<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa3cbf08946a76fc33cfdf83a96993a6b1">FF_NEG_PROJ_CIRC_REF_ON</a> =  8, 
<br/>
&#160;&#160;<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa8aa6e1395a03bd126d7931a85185be36">FF_DUAL_PROJ_CIRC_REF_CENTER</a> =  9, 
<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa20d3747960ede74dfa42cf338bd26ab8">FF_DUAL_PROJ_CIRC_REF_ON</a> =  10, 
<a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa740a8f83f7b13bc8ff4b5dd098c1ea15">FF_TETRA</a> =  11
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Formation type enumerations. </p>
 <a href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5a">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmaneuver__s.html">maneuver_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a30c9f1e37d57cd594e66160db9fcd093">IterativeImpulsiveManeuver</a> (<a class="el" href="structstate__s.html">state_t</a> state, <a class="el" href="structgeom__s.html">geom_t</a> goals_circ, <a class="el" href="structwindow__s.html">window_t</a> window, <a class="el" href="structplan__param__s.html">plan_param_t</a> param, bool &amp;foundSoln)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the delta-v's required to implement a formation flying maneuver for a single spacecraft.(circular orbit)  <a href="#a30c9f1e37d57cd594e66160db9fcd093"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmaneuver__s.html">maneuver_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a7258386f66622481494fd32e80e9b629">IterativeImpulsiveManeuver</a> (<a class="el" href="structstate__s.html">state_t</a> state, <a class="el" href="structecc__geom__s.html">ecc_geom_t</a> goals_ecc, <a class="el" href="structwindow__s.html">window_t</a> window, <a class="el" href="structplan__param__s.html">plan_param_t</a> param, bool &amp;foundSoln)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the delta-v's required to implement a formation flying maneuver for a single spacecraft. (eccentric orbit)  <a href="#a7258386f66622481494fd32e80e9b629"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmaneuver__s.html">maneuver_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#acc03013381ed38925f4d8c30306947bd">ImpulsiveLPManeuver</a> (<a class="el" href="structstate__s.html">state_t</a> state, <a class="el" href="structgeom__s.html">geom_t</a> goals_circ, <a class="el" href="structwindow__s.html">window_t</a> window, <a class="el" href="structplan__param__s.html">plan_param_t</a> param, double &amp;maxDV)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Plans an impulsive burn sequence (using simplex) to achieve the specified trajectory within the given time window. (circular orbit)  <a href="#acc03013381ed38925f4d8c30306947bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmaneuver__s.html">maneuver_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a6c899192f10d7382ca7565e8bf687415">ImpulsiveLPManeuver</a> (<a class="el" href="structstate__s.html">state_t</a> state, <a class="el" href="structecc__geom__s.html">ecc_geom_t</a> goals_ecc, <a class="el" href="structwindow__s.html">window_t</a> window, <a class="el" href="structplan__param__s.html">plan_param_t</a> param, double &amp;maxDV)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Plans an impulsive burn sequence (using simplex) to achieve the specified trajectory within the given time window. (eccentric orbit)  <a href="#a6c899192f10d7382ca7565e8bf687415"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmaneuver__s.html">maneuver_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a951e3474f7bd274a346612114eb267cf">ImpulsiveManeuver</a> (<a class="el" href="structstate__s.html">state_t</a> state, <a class="el" href="structgeom__s.html">geom_t</a> goals, <a class="el" href="structwindow__s.html">window_t</a> window, <a class="el" href="structplan__param__s.html">plan_param_t</a> param, double &amp;maxDV)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Plans an impulsive burn sequence (using closed-form equations) to achieve the specified trajectory within the given time window. For circular orbits only.  <a href="#a951e3474f7bd274a346612114eb267cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a10ee61229ddc70166d599d9bd2467918">OptimalInPlaneDeltaV</a> (double nOrbMin, double nOrbMax, double a, double th0, double th1, double delta_a, double delta_th0, double delta_q1, double delta_q2, double &amp;dV1, double &amp;dV2, double &amp;dV3, unsigned short &amp;M, unsigned short &amp;N)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the in-plane delta-v sequence for the given time window that achieves the desired element differences and results in the minimum total delta-v. For circular orbits only.  <a href="#a10ee61229ddc70166d599d9bd2467918"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structburn__s.html">burn_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a216b5b48c8c522698ee933b60b633327">InPlane</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> meas_elem, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> delta_elem, double accNom, double dTMin, double nOrbMin, double nOrbMax, double horizon, double &amp;t0, double &amp;tF, unsigned short &amp;nBurns)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the in-plane burn sequence for the given time window that achieves the desired element differences. For circular orbits only.  <a href="#a216b5b48c8c522698ee933b60b633327"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structburn__s.html">burn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af9298ec71d7c8e0a7fb5ffc7b8566dbf">OutOfPlane</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> meas_elem, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> delta_elem, double accNom, double dTMin, unsigned short &amp;nBurns, double &amp;th1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the out-of-plane burn sequence for the given time window that achieves the desired element differences. For circular orbits only.  <a href="#af9298ec71d7c8e0a7fb5ffc7b8566dbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af930b71e18e6b78114c0c39f833bf784">AutoFormGeometry</a> (<a class="el" href="structstate__s.html">state_t</a> state, <a class="el" href="structgeom__s.html">geom_t</a> memberGoals[], int num, double minSepDist, double maxSepDist)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define new geometric goals for a single satellite, such that any semi-major axis difference is eliminated, any radial oscillation is eliminated, and the new trajectory maintains a minimum separation distance from all other known trajectories.  <a href="#af930b71e18e6b78114c0c39f833bf784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a28b93c9072fd60838af01674cd057933">AutoFormGeometry</a> (<a class="el" href="structstate__s.html">state_t</a> state, <a class="el" href="structecc__geom__s.html">ecc_geom_t</a> memberGoals[], int num, double minSepDist, double maxSepDist)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define new geometric goals for a single satellite, such that any semi-major axis difference is eliminated, any radial oscillation is eliminated, and the new trajectory maintains a minimum separation distance from all other known trajectories.  <a href="#a28b93c9072fd60838af01674cd057933"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a8d39238a2a2799ae7038e815ef4bb232">NearestOffset</a> (double y0, double width, ml_matrix extrema, double minSepDistance, double maxSepDistance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the nearest along-track offset for a trajectory that is safe such that the minimum and maximum required separation distances are respected.  <a href="#a8d39238a2a2799ae7038e815ef4bb232"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#afaf543479a5967f9521b3a274579e40a">InitializeCostMatrix</a> (<a class="el" href="structteam__goals__s.html">team_goals_t</a> teamGoals, int nRelatives)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the team goals, initialize the cost matrix "f" with the right size.  <a href="#afaf543479a5967f9521b3a274579e40a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af912829996c2000172d4a2cf3edca62b">InitializeCostMatrix</a> (<a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a> teamGoals, int nRelatives)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the team goals, initialize the cost matrix "f" with the right size.  <a href="#af912829996c2000172d4a2cf3edca62b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab8e538e646e8f96b5fa313af66048a36">PopulateCostMatrix</a> (ml_matrix &amp;f, <a class="el" href="structcost__s.html">cost_t</a> costEstimate, <a class="el" href="structteam__goals__s.html">team_goals_t</a> teamGoals, ml_int_array relativeIDs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in a single column of the cost matrix.  <a href="#ab8e538e646e8f96b5fa313af66048a36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a6884c557f39bc424ebe582c2b1d9d5bd">PopulateCostMatrix</a> (ml_matrix &amp;f, <a class="el" href="structcost__s.html">cost_t</a> costEstimate, <a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a> teamGoals, ml_int_array relativeIDs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in a single column of the cost matrix.  <a href="#a6884c557f39bc424ebe582c2b1d9d5bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a0248dbd54b96c64abd565cb81a45f211">CostMatrixRows</a> (<a class="el" href="structteam__goals__s.html">team_goals_t</a> teamGoals, int index, int &amp;a, int &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the starting and ending rows in the cost matrix that correspond to a give target state index.  <a href="#a0248dbd54b96c64abd565cb81a45f211"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab76be5097545f7cd3a175f13e0f3edf2">CostMatrixRows</a> (<a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a> teamGoals, int index, int &amp;a, int &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the starting and ending rows in the cost matrix that correspond to a give target state index.  <a href="#ab76be5097545f7cd3a175f13e0f3edf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcost__s.html">cost_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aa52b1836b8d186d129d18cba49a482b0">EstimateCost</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> dEl, <a class="el" href="structteam__goals__s.html">team_goals_t</a> teamGoals, int memID, <a class="el" href="structwindow__s.html">window_t</a> window, double weight)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the (weighted) cost to achieve all specified unique target states.  <a href="#aa52b1836b8d186d129d18cba49a482b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcost__s.html">cost_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab66122ef6116f062c130de9acfcba88f">FFEccEstimateCost</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el0, const ml_matrix &amp;xH0, <a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a> teamGoals, int memID, <a class="el" href="structwindow__s.html">window_t</a> window, double weight, int nSPO)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the (weighted) cost to achieve all specified unique target states.  <a href="#ab66122ef6116f062c130de9acfcba88f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structteam__goals__s.html">team_goals_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab42994a20f26ea6113a919b40354d9e8">GenerateTeamGoals</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, int fType, double fSize, unsigned short nRels, int teamID, double angRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a set of team goals given the formation type and size.  <a href="#ab42994a20f26ea6113a919b40354d9e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structecc__team__goals__s.html">ecc_team_goals_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a8b1b3f8e516edd6d33bea91fb1d5e537">FFEccGenerateTeamGoals</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el0, int fType, double fSize, unsigned short nRels, int teamID, double nu, const ml_matrix &amp;eul)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a set of team goals given the formation type, size, location and orientation.  <a href="#a8b1b3f8e516edd6d33bea91fb1d5e537"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structecc__geom__xy__s.html">ecc_geom_xy_s</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a6c338f9f99f758e76674c45e3ca839f5">FFEccTetrahedronGeometry</a> (double nu, double d, const ml_matrix &amp;eul)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the geometric goals for a formation that achieves a tetrahedron shape at a given true anomaly in an eccentric reference orbit.  <a href="#a6c338f9f99f758e76674c45e3ca839f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgeom__s.html">geom_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ac5beb849cb29ec5e7dd2632579c93f80">PCGoals</a> (double R, double alpha0, double sgn, double y0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the geometric goals for a projected circular formation.  <a href="#ac5beb849cb29ec5e7dd2632579c93f80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a5585fe0ed259d281f2454761fe746168">SortTeamGoals</a> (<a class="el" href="structteam__goals__s.html">team_goals_t</a> &amp;teamGoals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the team goals with fixed states listed before variable states.  <a href="#a5585fe0ed259d281f2454761fe746168"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a0f21d2e3a549f8688f110fd126ce13a8">SortTeamGoals</a> (<a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a> &amp;teamGoals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the team goals with fixed states listed before variable states.  <a href="#a0f21d2e3a549f8688f110fd126ce13a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structassign__s.html">assign_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a9b3120cc29ce3074c6872310ecaedc0b">SetupAssignmentProblem</a> (<a class="el" href="structteam__goals__s.html">team_goals_t</a> teamGoals, double orbFrac=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the assignment problem given the team goals by computing the number of fixed, variable and unique variable states, plus with the phases and indices of repeated variable states.  <a href="#a9b3120cc29ce3074c6872310ecaedc0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structassign__s.html">assign_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a472bc30f4862e40be59b37c498346670">SetupAssignmentProblem</a> (<a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a> teamGoals, double orbFrac=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the assignment problem given the team goals by computing the number of fixed, variable and unique variable states, plus with the phases and indices of repeated variable states.  <a href="#a472bc30f4862e40be59b37c498346670"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ad17160ce9f2717876eb989e3bd810b60">RestrictIDSet</a> (ml_int_array &amp;relIDs, <a class="el" href="structconstraints__s.html">constraints_t</a> constraints[], int numC)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict the set of relative IDs to respect the specified assignment constraints.  <a href="#ad17160ce9f2717876eb989e3bd810b60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a1e74029b97a3d04254f9d44c9ceb121a">VerifyAssignmentParams</a> (<a class="el" href="structassign__s.html">assign_t</a> a, const ml_matrix &amp;f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for inconsistencies in the assignment parameters.  <a href="#a1e74029b97a3d04254f9d44c9ceb121a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a52c4bcfb6e87b41a2606c65e1780fcc6">PrivilegedAssignment</a> (<a class="el" href="structassign__s.html">assign_t</a> assign, const ml_matrix &amp;f, int method, ml_int_array &amp;optOrder, ml_matrix &amp;optPhi, double &amp;optCost)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign N targets to N satellites one at a time, so that the satellite with the largest minimum cost is assigned its min-cost target first.  <a href="#a52c4bcfb6e87b41a2606c65e1780fcc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a98a303c88974196ee0e215a7bb164138">OptimalAssignment</a> (<a class="el" href="structassign__s.html">assign_t</a> assign, ml_matrix f, ml_int_array &amp;optOrder, ml_matrix &amp;optPhi, double &amp;optCost)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign N targets to N satellites so that the weighted sum of costs to reach all targets is minimized.  <a href="#a98a303c88974196ee0e215a7bb164138"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a411a8c05331985be3c45211f792b0fdb">EquallyPhased</a> (const ml_matrix &amp;phi, ml_int_array u, int Pu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the phase angles are equally phased.  <a href="#a411a8c05331985be3c45211f792b0fdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_int_array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ad276ce09ff58f8f7dd05327ee7774069">FindMinSet</a> (ml_matrix &amp;mat, double &amp;minSum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the order in which to arrange the columns so that the matrix diagonal sum is minimized.  <a href="#ad276ce09ff58f8f7dd05327ee7774069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a9c903c68b432e7aca90c57e477070ddd">permute</a> (ml_int_array arr, int start, int num, const ml_matrix &amp;mat, double &amp;cost, ml_int_array &amp;best)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute the supplied array, called recursively by FindMinSet.  <a href="#a9c903c68b432e7aca90c57e477070ddd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aa165b9de82bf050ded6dd53352dd799c">LPCircular</a> (const ml_matrix &amp;x0, const ml_matrix &amp;xF, double n, double duration, double dT, unsigned short constraintType, double maxConstraint, ml_matrix &amp;aC, ml_matrix &amp;t, bool &amp;exitFlag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the thrust trajectory to go from an initial state to a final state in Hills frame. For circular orbits.  <a href="#aa165b9de82bf050ded6dd53352dd799c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a5ead824efc9428da0cb1e8023b5fd761">LPEccentric</a> (double e, double n, const ml_matrix &amp;x0, const ml_matrix &amp;xF, double nu0, double nuF, int nS, ml_matrix cW, unsigned short constraintType, double maxConstraint, ml_matrix &amp;aC, ml_matrix &amp;t, bool &amp;exitFlag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the thrust trajectory to go from an initial state to a final state in Hills frame. For eccentric orbits.  <a href="#a5ead824efc9428da0cb1e8023b5fd761"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab961861643ad0f1186069723a18f1c79">LPCircularTimeWeight</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el0, const ml_matrix &amp;xH0, <a class="el" href="structgeom__s.html">geom_t</a> goals, <a class="el" href="structwindow__s.html">window_t</a> window, int nSPO, ml_matrix &amp;xHF, double &amp;nOrbMvr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the target state on the desired trajectory that gives the minimum time-weighted cost. For circular orbits.  <a href="#ab961861643ad0f1186069723a18f1c79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a081c2fc0a578a90371d8a6199f4d16bb">LPEccentricTimeWeight</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el0, const ml_matrix &amp;xH0, <a class="el" href="structecc__geom__s.html">ecc_geom_t</a> goals, <a class="el" href="structwindow__s.html">window_t</a> window, int nSPO, ml_matrix &amp;xHF, double &amp;nOrbMvr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the target state on the desired trajectory that gives the minimum time-weighted cost. For eccentric orbits.  <a href="#a081c2fc0a578a90371d8a6199f4d16bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a2e9942b93f740ad8ed4097e477eb531a">GVEErrorDynamics</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el0, ml_matrix &amp;A, ml_matrix &amp;B)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute continuous-time dynamics for Gauss' variational equations.  <a href="#a2e9942b93f740ad8ed4097e477eb531a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a6911a76749b442360db753dd12d365c0">LPEccentricGVE</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el0, const ml_matrix &amp;x0, const ml_matrix &amp;xF, double MF, int nS, ml_matrix cW, unsigned short constraintType, double maxConstraint, ml_matrix &amp;aC, ml_matrix &amp;t, bool &amp;exitFlag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the thrust trajectory to go from an initial state to a final state in Hills frame. For eccentric orbits.  <a href="#a6911a76749b442360db753dd12d365c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a6ef69c05f45e459118ff0778cffadf51">FFEccLinOrb</a> (double n, double nu, double e, ml_matrix &amp;a, ml_matrix &amp;b, double dT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the continous A,B matrices for linearized relative motion in an eccentric reference orbit, discretized with a zero-order hold with timestep dT. *sctlib (overload LinOrb)  <a href="#a6ef69c05f45e459118ff0778cffadf51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ad01a98f5ad95b7ca287ce5f2a242a150">FFEccLinOrb</a> (const ml_matrix &amp;x, const ml_matrix &amp;acc, double n, double nu, double e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the right-hand-side for linearized relative motion in an eccentric reference orbit.  <a href="#ad01a98f5ad95b7ca287ce5f2a242a150"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a4e1657c150786b80e441832f4d662064">FFEccProp</a> (const ml_matrix &amp;D, const ml_matrix &amp;nu, double e, double dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Hills frame state at specified true anomaly given integration constants and eccentricity.  <a href="#a4e1657c150786b80e441832f4d662064"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ac2368592676604a20b02d9372dab8c13">FFEccProp</a> (const ml_matrix &amp;D, double nu, double e, double dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Hills frame state at specified true anomaly given integration constants and eccentricity.  <a href="#ac2368592676604a20b02d9372dab8c13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a62ff4add984cc2d3aa0e0c8fc3f631af">FFEccDH</a> (double nu0, double e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integration constant dH for homogeneous solution to LTV differential equations of relative orbit motion. Found by setting H=0 at initial true anomaly.  <a href="#a62ff4add984cc2d3aa0e0c8fc3f631af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#adf11e013a2d7bad6cbf3d9bf5fa71074">FFEccGoals</a> (double e, <a class="el" href="structecc__geom__s.html">ecc_geom_t</a> goals, ml_matrix &amp;D, ml_matrix &amp;xH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integration constants and initial state from the geometric goals.  <a href="#adf11e013a2d7bad6cbf3d9bf5fa71074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#abcff535d1c9e30fc1e6e5d7d9d532214">FFEccGoals</a> (double e, <a class="el" href="structecc__geom__xy__s.html">ecc_geom_xy_t</a> goals, ml_matrix &amp;D, ml_matrix &amp;xH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integration constants and initial state from the geometric goals.  <a href="#abcff535d1c9e30fc1e6e5d7d9d532214"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a9e0f1b7836dedc9f4343368d344e94e6">FFEccIntConst</a> (const ml_matrix &amp;xH0, double nu0, double e, ml_matrix &amp;D, double &amp;dH, ml_matrix &amp;R)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integration constants for homogeneous solution to LTV differential equations of relative orbit motion.  <a href="#a9e0f1b7836dedc9f4343368d344e94e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af1d0e51664a6b8b09737414836db87ef">FFEccRMat</a> (double nu, double e, double dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the state-transition matrix, R, given the eccentricity and true anomaly so that xH = R*D, where D is the vector of integration constants found from initial conditions.  <a href="#af1d0e51664a6b8b09737414836db87ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af029a5969ec9790f27aeb038df6e0032">FFEccRMat</a> (double nu, double e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the state-transition matrix, R, given the eccentricity and true anomaly so that xH = R*D, where D is the vector of integration constants found from initial conditions. Here, the integration constant "dH" is computed using the first element of the "nu" matrix.  <a href="#af029a5969ec9790f27aeb038df6e0032"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a75faeb0429eab7512b6e5e2458d2a618">FFEccXExt</a> (double e, const ml_matrix &amp;D, double dH, double epsilon, int nMax, ml_matrix &amp;x, ml_matrix &amp;nu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute extreme x-values and associated true anomalies for given relative motion.  <a href="#a75faeb0429eab7512b6e5e2458d2a618"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af00eb88837a7f890c75064dff5974fd8">FFEccYExt</a> (double e, const ml_matrix &amp;D, double dH, double epsilon, int nMax, ml_matrix &amp;y, ml_matrix &amp;nu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute extreme y-values and associated true anomalies for given relative motion.  <a href="#af00eb88837a7f890c75064dff5974fd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af96777fa5393feabf332a79ac9e0be4f">FFEccZExt</a> (double e, const ml_matrix &amp;D, double dH, double epsilon, int nMax, ml_matrix &amp;z, ml_matrix &amp;nu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute extreme z-values and associated true anomalies for given relative motion.  <a href="#af96777fa5393feabf332a79ac9e0be4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a7030e5a861767b0c64dd84d30b2a5b0d">NuDot</a> (double n, double e, double nu, double &amp;nuDot, double &amp;nuDotDot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the time-derivative of the true anomaly. *sctlib.  <a href="#a7030e5a861767b0c64dd84d30b2a5b0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ace303f8cb6c83adceea58471e1301632">FFEccDX</a> (double nu, double e, const ml_matrix &amp;D, double dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first derivative of x with respect to true anomaly.  <a href="#ace303f8cb6c83adceea58471e1301632"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a1ff4dcf0b6ddc66d39ce412db326a94c">FFEccDY</a> (double nu, double e, const ml_matrix &amp;D, double dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first derivative of y with respect to true anomaly.  <a href="#a1ff4dcf0b6ddc66d39ce412db326a94c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aebd1bb2c9142a87119b3d7d22e3510fd">FFEccDZ</a> (double nu, double e, const ml_matrix &amp;D, double dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first derivative of z with respect to true anomaly.  <a href="#aebd1bb2c9142a87119b3d7d22e3510fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a163ad7ee5ad0e7b7de525a9ec91723e0">FFEccDDX</a> (double nu, double e, const ml_matrix &amp;D, double dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the second derivative of x with respect to true anomaly.  <a href="#a163ad7ee5ad0e7b7de525a9ec91723e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a6ea4108936beea376ac35d6baf5aeb2a">FFEccDDY</a> (double nu, double e, const ml_matrix &amp;D, double dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the second derivative of y with respect to true anomaly.  <a href="#a6ea4108936beea376ac35d6baf5aeb2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af5568bd9358f1b1e3eb193ac9e2456eb">FFEccDDZ</a> (double nu, double e, const ml_matrix &amp;D, double dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the second derivative of z with respect to true anomaly.  <a href="#af5568bd9358f1b1e3eb193ac9e2456eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ac029bcc162f6ef28aba78fdc9a29a496">Alfriend2El</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> elA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Alfriend orbital element set into the standard orbital element set *sctlib.  <a href="#ac029bcc162f6ef28aba78fdc9a29a496"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a06eb69feb5e3aa8490cdeaf8b3389d0c">El2Alfriend</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a standard orbital element set into the Alfriend orbital element set *sctlib.  <a href="#a06eb69feb5e3aa8490cdeaf8b3389d0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af7386ce835b40bc83f5a834f6f853db7">El2Alfriend</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el, double true_anom)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a standard orbital element set into the Alfriend orbital element set *sctlib.  <a href="#af7386ce835b40bc83f5a834f6f853db7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a57482495205fea590003e98e1700ba70">add_elements</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el1, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two sets of orbital elements *sctlib.  <a href="#a57482495205fea590003e98e1700ba70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structorb__data__s.html">orb_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aee211c4c69d77f2daf6db4dc54f20871">add_elements</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el1, <a class="el" href="structorb__data__s.html">orb_data_t</a> el2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two sets of orbital elements *sctlib.  <a href="#aee211c4c69d77f2daf6db4dc54f20871"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab23f9e3835efcc79ad4a5f32657df282">sub_elements</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el1, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one element set from another.  <a href="#ab23f9e3835efcc79ad4a5f32657df282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structorb__data__s.html">orb_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a475a2c55e89f2406b0d3fdbb0cea5065">sub_elements</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el1, <a class="el" href="structorb__data__s.html">orb_data_t</a> el2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one element set from another.  <a href="#a475a2c55e89f2406b0d3fdbb0cea5065"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ae519a81dfda96292fb3731b43d607931">CirclePhase</a> (double beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the desired phase on a circle from the desired phase on the ellipse. The circle is superscribed about the ellipse.  <a href="#ae519a81dfda96292fb3731b43d607931"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a29f78590c86bcdb8aef3a1788fcf0d09">EllipsePhase</a> (double alpha)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the desired phase on an ellipse from the desired phase on the circle. The circle is superscribed about the ellipse.  <a href="#a29f78590c86bcdb8aef3a1788fcf0d09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a485faa11ebfca7d63747281d1a893236">OrbElemDiff</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between Alfriend orbital element vectors.  <a href="#a485faa11ebfca7d63747281d1a893236"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a9f4f410ad833b1fb9de80e97f1ec3a05">OrbElemDiff</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el0, <a class="el" href="structorb__data__s.html">orb_data_t</a> el)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differences between standard orbital element vectors.  <a href="#a9f4f410ad833b1fb9de80e97f1ec3a05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aa2b4abf5c66ab1aa8059fca9ffe50853">Goals2DeltaElem</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, <a class="el" href="structgeom__s.html">geom_t</a> goals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the desired element differences, given the geometric goals and the measured orbital elements.  <a href="#aa2b4abf5c66ab1aa8059fca9ffe50853"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ae8162926b5ec625c56a90f1391c7f3d0">DeltaElem2Goals</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> dEl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the geoemtric goals, given the desired element differences and the measured orbital elements.  <a href="#ae8162926b5ec625c56a90f1391c7f3d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a5ca4b5a1b39f869dfbf1178c95dea5be">DeltaElem2Hills</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> elA, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> dEl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Hills frame state from the element differences and reference elements.  <a href="#a5ca4b5a1b39f869dfbf1178c95dea5be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a6ff4bbae07d407ca9977e9336f0dbbb4">Hills2DeltaElem</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, const ml_matrix &amp;xH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the element differences from the Hills frame state and reference elements.  <a href="#a6ff4bbae07d407ca9977e9336f0dbbb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgeom__s.html">geom_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a2e26b2c9b2e1dde172982705a67ccd78">Hills2Goals</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, const ml_matrix &amp;xH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the geometric goals from the Hills frame state and reference elements.  <a href="#a2e26b2c9b2e1dde172982705a67ccd78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aa8ef9602cb80c49bc50d8de0eb22ba94">Goals2Hills</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, <a class="el" href="structgeom__s.html">geom_t</a> goals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Hills frame state from the geometric goals and reference elements.  <a href="#aa8ef9602cb80c49bc50d8de0eb22ba94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structorb__data__s.html">orb_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af0cbc0cbba25da28734a8495e4edd905">FFEccHills2DeltaElem</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el0, const ml_matrix &amp;xH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the orbital element differences from the Hills frame state and the reference orbital elements.  <a href="#af0cbc0cbba25da28734a8495e4edd905"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aabc32e5518972b7a946dced3e16897ff">FFEccHills2DeltaElem</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, const ml_matrix &amp;xH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the orbital element differences from the Hills frame state and the reference orbital elements.  <a href="#aabc32e5518972b7a946dced3e16897ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aa27ce5873c82f32850e87fa1055a56be">FFEccDeltaElem2Hills</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> dEl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert element differences to Hills frame coordinates in an eccentric orbit.  <a href="#aa27ce5873c82f32850e87fa1055a56be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ae5fb4ac3b55ddb8363123f4902e2c3c0">FFEccDeltaElem2Goals</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el0, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> dEl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert element differences to eccentric geometric goals.  <a href="#ae5fb4ac3b55ddb8363123f4902e2c3c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a5c8af9ea03481cbf6d589eaa40e296fc">FFEccGoals2Hills</a> (double e, double nu, <a class="el" href="structecc__geom__s.html">ecc_geom_t</a> g, double n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Hills frame state (in time-domain) given geometric goals and orbit data.  <a href="#a5c8af9ea03481cbf6d589eaa40e296fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#af457b46906d8d73604d153f92fe35712">FFEccGoals2Hills</a> (double e, double nu, <a class="el" href="structecc__geom__xy__s.html">ecc_geom_xy_t</a> g, double n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Hills frame state (in time-domain) given geometric goals and orbit data.  <a href="#af457b46906d8d73604d153f92fe35712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab439a030d850ec9c3322191c3cbd3a15">FFEccGoals2Hills</a> (double e, double nu, <a class="el" href="structecc__geom__s.html">ecc_geom_t</a> g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Hills frame state (in nu-domain) given geometric goals and orbit data.  <a href="#ab439a030d850ec9c3322191c3cbd3a15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab0cc4b1a81146ebc7cfa942136a43a56">FFEccHills2Goals</a> (double e, double nu, ml_matrix xH, double n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geometric goals given Hills frame state (in time-domain) and orbit data.  <a href="#ab0cc4b1a81146ebc7cfa942136a43a56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#afc07affc19e45b20d0924d3649c12cf8">FFEccHills2Goals</a> (double e, double nu, const ml_matrix &amp;xH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute geometric goals given Hills frame state (in nu-domain) and orbit data.  <a href="#afc07affc19e45b20d0924d3649c12cf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a3dd68e9224032941b4f12c12ef11f169">Nu2TimeDomain</a> (ml_matrix &amp;x, double n, double e, double nu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a relative orbit state from the nu-domain to the time-domain.  <a href="#a3dd68e9224032941b4f12c12ef11f169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ad2a6dd2eec7f5c203035040dc6ce733a">Time2NuDomain</a> (ml_matrix &amp;x, double n, double e, double nu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a relative orbit state from the time-domain to the nu-domain.  <a href="#ad2a6dd2eec7f5c203035040dc6ce733a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ad9dd8a7da4eab83519601473daa0e66c">GeometryCirc2Ecc</a> (double w, <a class="el" href="structgeom__s.html">geom_t</a> gCirc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a circular geometry structure to an eccentric geometry structure.  <a href="#ad9dd8a7da4eab83519601473daa0e66c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a7f61891744974fcef7be2c91ac0d6784">GeometryEcc2Circ</a> (double w, <a class="el" href="structecc__geom__s.html">ecc_geom_t</a> gEcc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an eccentric geometry structure to a circular geometry structure.  <a href="#a7f61891744974fcef7be2c91ac0d6784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ad62bd4537ef6531f493c38ef6f8dd9c2">RotateState</a> (<a class="el" href="structgeom__s.html">geom_t</a> goals, double phi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a geometric goal set to the circular phase angle phi.  <a href="#ad62bd4537ef6531f493c38ef6f8dd9c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aea7fb7cd659e41e1ad86cd6776e3641d">MeanAnom2TrueLat</a> (double e, double w, double M)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert mean anomlay to true latitude.  <a href="#aea7fb7cd659e41e1ad86cd6776e3641d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aaf6aa7f06996f687a4435386d275d323">GetHillsMats</a> (const ml_matrix &amp;r0, const ml_matrix &amp;v0, ml_matrix &amp;A, ml_matrix &amp;Adot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the A and Adot matrices used for transformation to Hills frame.  <a href="#aaf6aa7f06996f687a4435386d275d323"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab9d76e85be1767f1af1b3ac42737d0a7">AbsRelECI2Hills</a> (ml_matrix r0, ml_matrix v0, ml_matrix dr, ml_matrix dv, ml_matrix &amp;rH, ml_matrix &amp;vH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the relative position and velocity in Hills frame given an absolute ECI position &amp; velocity and a relative inertial position &amp; velocity.  <a href="#ab9d76e85be1767f1af1b3ac42737d0a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a52608ce1578fb0afa42dcc232d489d46">Osc2Mean</a> (<a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> el, double J2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms osculating orbital elements to mean orbital elements.  <a href="#a52608ce1578fb0afa42dcc232d489d46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a05ddff0f7463567683125614b02628a5">ECI2MeanElements</a> (const ml_matrix &amp;xRefECI, const ml_matrix &amp;xRelECI, double J2, <a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> &amp;elRefMean)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes mean orbital elements and mean orbital element differences from reference and relative ECI position and velocity.  <a href="#a05ddff0f7463567683125614b02628a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a2dcb66087cfc6b7acc2b30c685c06ac9">AlignThruster</a> (const ml_matrix &amp;aH, const ml_matrix &amp;bTh, ml_matrix &amp;qHB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes desired Hills-to-body quaternion for a thruster firing. Rotation about thruster-axis is ignored.  <a href="#a2dcb66087cfc6b7acc2b30c685c06ac9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a23de1c7d74b468ac67be46087f8de531">AlignThruster</a> (const ml_matrix &amp;aH, const ml_matrix &amp;bTh, const ml_matrix &amp;bST, const ml_matrix &amp;r, const ml_matrix &amp;v, double jD, double sep, ml_matrix &amp;qHB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes desired Hills-to-body quaternion for a thruster firing such that the star tracker is pointed as far away as possible from the sun, earth and moon.  <a href="#a23de1c7d74b468ac67be46087f8de531"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aaa80f05cfcadacc8e4bdfe0cbbc371b7">Hills2Frenet</a> (const ml_matrix &amp;xH, const double &amp;e, const double &amp;nu, const double &amp;n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms from the Hills frame to the Frenet frame.  <a href="#aaa80f05cfcadacc8e4bdfe0cbbc371b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a113d0887a185af1d98d5c7c3083af728">HillsEqns</a> (const ml_matrix &amp;xH0, double n, double t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closed form solution of relative orbital motion using Hills equations. For circular orbits only.  <a href="#a113d0887a185af1d98d5c7c3083af728"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ad3e1547c50125821e91ee4b0cc06a226">FFEccHillsEqns</a> (ml_matrix xH0, double nu0, const ml_matrix &amp;nu, double e, double n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Hills frame state (in time-domain) at future true anomaly(s). For eccentric or circular orbits.  <a href="#ad3e1547c50125821e91ee4b0cc06a226"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a17d76c90f5d0f67d7fe572a1bec83b7d">FFEccHillsEqns</a> (const ml_matrix &amp;xH0, double nu0, const ml_matrix &amp;nu, double e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Hills frame state (in nu-domain) at future true anomaly(s). For eccentric or circular orbits.  <a href="#a17d76c90f5d0f67d7fe572a1bec83b7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ae29b964554c262131987077a7df69ef8">DiscreteHills</a> (const ml_matrix &amp;x0, double n, const ml_matrix &amp;aC, double dT)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the force relative trajectory from the initial state and time-history of applied accelerations. For circular orbits only.  <a href="#ae29b964554c262131987077a7df69ef8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ae50102b6e2dd5ec0b0c1145d45d5632a">FFEccDiscreteHills</a> (double e, double n, const ml_matrix &amp;x0, double nu0, const ml_matrix &amp;aC, const ml_matrix &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the force relative trajectory from the initial state and time-history of applied accelerations. For circular orbits only.  <a href="#ae50102b6e2dd5ec0b0c1145d45d5632a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a1b85fd2da3460e7794679940cdb08157">CollProbSet</a> (double sigma, const ml_matrix &amp;S, const ml_matrix &amp;xc, const ml_matrix &amp;Ssc, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision probability calculation using sets of ellipsoids.  <a href="#a1b85fd2da3460e7794679940cdb08157"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a73346e35edc9d53d4e0adbee560e6c19">MonitoringAlg</a> (ml_matrix &amp;y, ml_matrix &amp;t, ml_matrix &amp;M, ml_matrix &amp;nu, ml_matrix &amp;accel, ml_matrix &amp;aDiff, <a class="el" href="structcoll__mon__data__s.html">coll_mon_data_t</a> d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision monitoring algorithm implementation used for both modes, monitoring and surveying.  <a href="#a73346e35edc9d53d4e0adbee560e6c19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a44af0a6d9034450fa2c3332cf0cc7614">CollisionSurvey</a> (ml_matrix &amp;y, double t0, <a class="el" href="structmaneuver__s.html">maneuver_t</a> mvr1, <a class="el" href="structmaneuver__s.html">maneuver_t</a> mvr2[], int n_points, <a class="el" href="structcoll__mon__data__s.html">coll_mon_data_s</a> d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Collision survey implementation which changes maneuvers to acceleration vectors and calls monitoring algorithm.  <a href="#a44af0a6d9034450fa2c3332cf0cc7614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#adf5caccba55c9d373562ef82893034d7">DeltaElem2HillsMat</a> (const ml_matrix &amp;elA)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute transformation matrix from delta elements to Hills.  <a href="#adf5caccba55c9d373562ef82893034d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#abe169cee43dffe3de13a2c269f9fdfc4">DeltaEl2AlfriendMat</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> el)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute transformation matrix from standard differential elements to Alfriend differential elements.  <a href="#abe169cee43dffe3de13a2c269f9fdfc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a8ad27dc7f035f9254f39364c3e012ca8">distant_pt_ell</a> (const ml_matrix &amp;S, const ml_matrix &amp;U, const ml_matrix &amp;xc, const ml_matrix &amp;x0, ml_matrix &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute minimum distance from a distance point to an ellipsoid's surface.  <a href="#a8ad27dc7f035f9254f39364c3e012ca8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ad7d9b77c90526541327fc731ebad00b6">Laguerre</a> (const ml_matrix &amp;a, double x_guess)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Laguerre root finding algorithm adapted to real roots.  <a href="#ad7d9b77c90526541327fc731ebad00b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aec672562e3bbe14ed91c73ceb717ccc3">GenerateTimeVector</a> (<a class="el" href="structorb__data__s.html">orb_data_t</a> d, const double tF, const int nPts, ml_matrix &amp;M, ml_matrix &amp;nu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a time vector evenly spaced over true anomaly.  <a href="#aec672562e3bbe14ed91c73ceb717ccc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a6c2c06571dc741c8f5d5ea99829cec08">ManeuverStruct2AccelVector</a> (<a class="el" href="structmaneuver__s.html">maneuver_t</a> mvr, const ml_matrix &amp;tProp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a 3xN acceleration vector from a maneuver data structure.  <a href="#a6c2c06571dc741c8f5d5ea99829cec08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ab36ab3e7e5a968d0643ed0846eb2516d">TeamLevels</a> (<a class="el" href="structteam__s.html">team_t</a> teams[], int num, ml_int_array &amp;levels)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a hierarchical level to each team in the array.  <a href="#ab36ab3e7e5a968d0643ed0846eb2516d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a6a24bd3783b9e7ffb11cf49caef25b05">IsRelative</a> (int iD, <a class="el" href="structteam__s.html">team_t</a> teams[], int num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the given satellite ID is a relative of any team.  <a href="#a6a24bd3783b9e7ffb11cf49caef25b05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a7b3ce146c7c14b88e51cefa8d9229ced">FindUpperTeams</a> (int kBot, <a class="el" href="structteam__s.html">team_t</a> teams[], int num, ml_int_array &amp;kUpper)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find teams above this one in the hierarchy.  <a href="#a7b3ce146c7c14b88e51cefa8d9229ced"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a433ff3d1142ba6cda80abcfd2729fc4b">TimeUntilTheta</a> (double a, double w, double e, double theta0, double &amp;theta1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the time in seconds until the new latitude is reached from the original latitude.  <a href="#a433ff3d1142ba6cda80abcfd2729fc4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#acfb0e7fc17aef36aefcf58d3ed20b3c1">AccelVector2ManeuverStruct</a> (const ml_matrix &amp;aC, ml_matrix t, double tRef, double nomAccel, double minSepTime, <a class="el" href="structmaneuver__s.html">maneuver_t</a> &amp;mvr, ml_matrix &amp;dV)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a maneuver structure from acceleration and time vectors.  <a href="#acfb0e7fc17aef36aefcf58d3ed20b3c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a81b318794c86fdb508faf7c8d092f821">ManeuverStruct2AccelVector</a> (<a class="el" href="structmaneuver__s.html">maneuver_t</a> mvr, double dT, ml_matrix &amp;aC, ml_matrix &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a 3xN acceleration vector from a maneuver data structure.  <a href="#a81b318794c86fdb508faf7c8d092f821"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aa222645204b5f7e8667f1832b4c0edba">NOrbVector</a> (<a class="el" href="structwindow__s.html">window_t</a> window)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a vector of maneuver durations (in orbits) from time window data.  <a href="#aa222645204b5f7e8667f1832b4c0edba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#afdc393a137c52e6b1abca417661bb652">TargetTrueAnom</a> (double e, double nu0, ml_matrix nOrb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the future true anomaly (unwrapped) at the specified number of orbits after the initial true anomaly.  <a href="#afdc393a137c52e6b1abca417661bb652"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#ac5e3fd35bc1c5d2df3bef7874e4505b6">Tetrahedron</a> (double d, const ml_matrix &amp;eul)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 4 points of a regular tetrahedron, the surface area and volume.  <a href="#ac5e3fd35bc1c5d2df3bef7874e4505b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa08441e660361bce5a9bf2ad921024ef"></a><!-- doxytag: member="sc_formation.h::vsum" ref="aa08441e660361bce5a9bf2ad921024ef" args="(const ml_matrix &amp;a)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aa08441e660361bce5a9bf2ad921024ef">vsum</a> (const ml_matrix &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of all elements in a row or column vector. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa187e8ccb8728967833ad11ae27e6594"></a><!-- doxytag: member="sc_formation.h::newton_raphson" ref="aa187e8ccb8728967833ad11ae27e6594" args="(nr_function f, nr_function df, double x, double epsilon, int &amp;n_max, double e, const ml_matrix &amp;D, const double &amp;dH)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#aa187e8ccb8728967833ad11ae27e6594">newton_raphson</a> (<a class="el" href="sc__formation_8h.html#a1fa4abb0140a90beae0fc1558175e342">nr_function</a> f, <a class="el" href="sc__formation_8h.html#a1fa4abb0140a90beae0fc1558175e342">nr_function</a> df, double x, double epsilon, int &amp;n_max, double e, const ml_matrix &amp;D, const double &amp;dH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton-Raphson (optimized for FFEccXExt and similar) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__formation_8h.html#a362f1d91de681694cb8f88123fec8735">matout</a> (ml_matrix mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a matrix to a string with higher precision than built-in "to_string" function.  <a href="#a362f1d91de681694cb8f88123fec8735"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="adeef5cd747bd2af449438b91d4aecd93"></a><!-- doxytag: member="sc_formation.h::ff_error_codes" ref="adeef5cd747bd2af449438b91d4aecd93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sc__formation_8h.html#adeef5cd747bd2af449438b91d4aecd93">ff_error_codes</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="adeef5cd747bd2af449438b91d4aecd93a35d14b8c6dbc4dc4d465f246238ce6a1"></a><!-- doxytag: member="FF_NO_ERROR" ref="adeef5cd747bd2af449438b91d4aecd93a35d14b8c6dbc4dc4d465f246238ce6a1" args="" -->FF_NO_ERROR</em>&nbsp;</td><td>
<p>No error reported. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adeef5cd747bd2af449438b91d4aecd93a41c90786cdf6d472deaa2a3b1481ad8f"></a><!-- doxytag: member="FF_NO_SOLN" ref="adeef5cd747bd2af449438b91d4aecd93a41c90786cdf6d472deaa2a3b1481ad8f" args="" -->FF_NO_SOLN</em>&nbsp;</td><td>
<p>No solution was found. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adeef5cd747bd2af449438b91d4aecd93a153b7c87c9b2de9b99d6872e00658033"></a><!-- doxytag: member="FF_MAX_ITER" ref="adeef5cd747bd2af449438b91d4aecd93a153b7c87c9b2de9b99d6872e00658033" args="" -->FF_MAX_ITER</em>&nbsp;</td><td>
<p>The maximum number of iterations was reached. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adeef5cd747bd2af449438b91d4aecd93a81c1d0b02ea5b8bcd6594105e74b0c78"></a><!-- doxytag: member="FF_BAD_VALUE" ref="adeef5cd747bd2af449438b91d4aecd93a81c1d0b02ea5b8bcd6594105e74b0c78" args="" -->FF_BAD_VALUE</em>&nbsp;</td><td>
<p>Occurs when a supplied value is physically impossible (ie, SMA &lt; 0). </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5a"></a><!-- doxytag: member="sc_formation.h::ff_formation_types" ref="aa6fe0c996902e6cf5de765184ebd8c5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5a">ff_formation_types</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aa06b2fd15913aea7e8bb4430081d9163c"></a><!-- doxytag: member="FF_IPLF" ref="aa6fe0c996902e6cf5de765184ebd8c5aa06b2fd15913aea7e8bb4430081d9163c" args="" -->FF_IPLF</em>&nbsp;</td><td>
<p>Equally spaced in-plane leader-follower. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aa0a7cee1fde4b78838173a2d9d987edd3"></a><!-- doxytag: member="FF_OOPLF_RGT" ref="aa6fe0c996902e6cf5de765184ebd8c5aa0a7cee1fde4b78838173a2d9d987edd3" args="" -->FF_OOPLF_RGT</em>&nbsp;</td><td>
<p>Equally spaced out-of-plane leader-follower with right ascen. </p>
<p>diff. for repeated ground track </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aa0eb99898ac2f91ce66481a8b6af967c3"></a><!-- doxytag: member="FF_CIPE_REF_CENTER" ref="aa6fe0c996902e6cf5de765184ebd8c5aa0eb99898ac2f91ce66481a8b6af967c3" args="" -->FF_CIPE_REF_CENTER</em>&nbsp;</td><td>
<p>Equqlly phased centered in-plane ellipse, reference at center of ellipse. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aa19140e073540c844fe704a7a430ecb20"></a><!-- doxytag: member="FF_CIPE_REF_ON" ref="aa6fe0c996902e6cf5de765184ebd8c5aa19140e073540c844fe704a7a430ecb20" args="" -->FF_CIPE_REF_ON</em>&nbsp;</td><td>
<p>Equqlly phased centered in-plane ellipse, reference on ellipse. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aa83b8268d7866574ec605bf6d13351ca3"></a><!-- doxytag: member="FF_POS_PROJ_CIRC_REF_CENTER" ref="aa6fe0c996902e6cf5de765184ebd8c5aa83b8268d7866574ec605bf6d13351ca3" args="" -->FF_POS_PROJ_CIRC_REF_CENTER</em>&nbsp;</td><td>
<p>Equqlly phased positive-plane projected circle, reference at center of circle. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aaaf3c8172172f0d49b1a1a7f54c82c607"></a><!-- doxytag: member="FF_POS_PROJ_CIRC_REF_ON" ref="aa6fe0c996902e6cf5de765184ebd8c5aaaf3c8172172f0d49b1a1a7f54c82c607" args="" -->FF_POS_PROJ_CIRC_REF_ON</em>&nbsp;</td><td>
<p>Equqlly phased positive-plane projected circle, reference on circle. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aa3cfb553f361551d1fb68db4db78c390b"></a><!-- doxytag: member="FF_NEG_PROJ_CIRC_REF_CENTER" ref="aa6fe0c996902e6cf5de765184ebd8c5aa3cfb553f361551d1fb68db4db78c390b" args="" -->FF_NEG_PROJ_CIRC_REF_CENTER</em>&nbsp;</td><td>
<p>Equqlly phased negative-plane projected circle, reference at center of circle. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aa3cbf08946a76fc33cfdf83a96993a6b1"></a><!-- doxytag: member="FF_NEG_PROJ_CIRC_REF_ON" ref="aa6fe0c996902e6cf5de765184ebd8c5aa3cbf08946a76fc33cfdf83a96993a6b1" args="" -->FF_NEG_PROJ_CIRC_REF_ON</em>&nbsp;</td><td>
<p>Equqlly phased negative-plane projected circle, reference on circle. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aa8aa6e1395a03bd126d7931a85185be36"></a><!-- doxytag: member="FF_DUAL_PROJ_CIRC_REF_CENTER" ref="aa6fe0c996902e6cf5de765184ebd8c5aa8aa6e1395a03bd126d7931a85185be36" args="" -->FF_DUAL_PROJ_CIRC_REF_CENTER</em>&nbsp;</td><td>
<p>Equally phased dual-plane projected circle, reference at center of circle. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aa20d3747960ede74dfa42cf338bd26ab8"></a><!-- doxytag: member="FF_DUAL_PROJ_CIRC_REF_ON" ref="aa6fe0c996902e6cf5de765184ebd8c5aa20d3747960ede74dfa42cf338bd26ab8" args="" -->FF_DUAL_PROJ_CIRC_REF_ON</em>&nbsp;</td><td>
<p>Equally phased dual-plane projected circle, reference on circle. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa6fe0c996902e6cf5de765184ebd8c5aa740a8f83f7b13bc8ff4b5dd098c1ea15"></a><!-- doxytag: member="FF_TETRA" ref="aa6fe0c996902e6cf5de765184ebd8c5aa740a8f83f7b13bc8ff4b5dd098c1ea15" args="" -->FF_TETRA</em>&nbsp;</td><td>
<p>Repeating tetrahedron geometry at a specified true anomaly, any orientation. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a30c9f1e37d57cd594e66160db9fcd093"></a><!-- doxytag: member="sc_formation.h::IterativeImpulsiveManeuver" ref="a30c9f1e37d57cd594e66160db9fcd093" args="(state_t state, geom_t goals_circ, window_t window, plan_param_t param, bool &amp;foundSoln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmaneuver__s.html">maneuver_s</a> IterativeImpulsiveManeuver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstate__s.html">state_t</a>&#160;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals_circ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwindow__s.html">window_t</a>&#160;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplan__param__s.html">plan_param_t</a>&#160;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>foundSoln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the delta-v's required to implement a formation flying maneuver for a single spacecraft.(circular orbit)</p>
<p>(circular orbit) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Absolute and relative state information </td></tr>
    <tr><td class="paramname">goals_circ</td><td>Geometric goals for relative trajectory (circular) </td></tr>
    <tr><td class="paramname">window</td><td>Time window for the maneuver </td></tr>
    <tr><td class="paramname">param</td><td>Planning parameters for maneuver </td></tr>
    <tr><td class="paramname">foundSoln</td><td>Flag indicating whether a solution was found or not. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maneuver Maneuver data consisting of a series of impulsive burns </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structstate__s.html#afaf9f81399b6c3e1ce40574ca2a7ac9a">state_s::el</a>, <a class="el" href="structstate__s.html#a9aef1e85bc3d7fa51577896024afb4bf">state_s::elA</a>, <a class="el" href="structplan__param__s.html#af53524422716818c1fe4b79c536d26ad">plan_param_s::eTol</a>, <a class="el" href="structplan__param__s.html#aa590510c471ecfe839dfef53657f5207">plan_param_s::maxDeltaV</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, and <a class="el" href="structstate__s.html#a5064e9ff9b13b4a8cb0325497ee0e032">state_s::xH</a>.</p>

</div>
</div>
<a class="anchor" id="a7258386f66622481494fd32e80e9b629"></a><!-- doxytag: member="sc_formation.h::IterativeImpulsiveManeuver" ref="a7258386f66622481494fd32e80e9b629" args="(state_t state, ecc_geom_t goals_ecc, window_t window, plan_param_t param, bool &amp;foundSoln)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmaneuver__s.html">maneuver_s</a> IterativeImpulsiveManeuver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstate__s.html">state_t</a>&#160;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals_ecc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwindow__s.html">window_t</a>&#160;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplan__param__s.html">plan_param_t</a>&#160;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>foundSoln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the delta-v's required to implement a formation flying maneuver for a single spacecraft. (eccentric orbit)</p>
<p>(eccentric orbit) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Absolute and relative state information </td></tr>
    <tr><td class="paramname">goals_ecc</td><td>Geometric goals for relative trajectory (eccentric) </td></tr>
    <tr><td class="paramname">window</td><td>Time window for the maneuver </td></tr>
    <tr><td class="paramname">param</td><td>Planning parameters for maneuver </td></tr>
    <tr><td class="paramname">foundSoln</td><td>Flag indicating whether a solution was found or not. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maneuver Maneuver data consisting of a series of impulsive burns </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structstate__s.html#afaf9f81399b6c3e1ce40574ca2a7ac9a">state_s::el</a>, <a class="el" href="structstate__s.html#a9aef1e85bc3d7fa51577896024afb4bf">state_s::elA</a>, <a class="el" href="structplan__param__s.html#af53524422716818c1fe4b79c536d26ad">plan_param_s::eTol</a>, <a class="el" href="structplan__param__s.html#aa590510c471ecfe839dfef53657f5207">plan_param_s::maxDeltaV</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, and <a class="el" href="structstate__s.html#a5064e9ff9b13b4a8cb0325497ee0e032">state_s::xH</a>.</p>

</div>
</div>
<a class="anchor" id="acc03013381ed38925f4d8c30306947bd"></a><!-- doxytag: member="sc_formation.h::ImpulsiveLPManeuver" ref="acc03013381ed38925f4d8c30306947bd" args="(state_t state, geom_t goals_circ, window_t window, plan_param_t param, double &amp;maxDV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmaneuver__s.html">maneuver_s</a> ImpulsiveLPManeuver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstate__s.html">state_t</a>&#160;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals_circ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwindow__s.html">window_t</a>&#160;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplan__param__s.html">plan_param_t</a>&#160;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>maxDV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Plans an impulsive burn sequence (using simplex) to achieve the specified trajectory within the given time window. (circular orbit)</p>
<p>For circular orbits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Data structure of Orbit state </td></tr>
    <tr><td class="paramname">goals_circ</td><td>Data structure of geometric goal information </td></tr>
    <tr><td class="paramname">window</td><td>Data structure of commanded time window </td></tr>
    <tr><td class="paramname">param</td><td>Data structure of planning parameters </td></tr>
    <tr><td class="paramname">maxDV</td><td>The maximum delta-V of the sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maneuver Maneuver data structure </dd></dl>

<p>References <a class="el" href="structmaneuver__s.html#a0e27a8845c0028dcad62ef6fc6c3cc24">maneuver_s::achieve</a>, <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structstate__s.html#afaf9f81399b6c3e1ce40574ca2a7ac9a">state_s::el</a>, <a class="el" href="structplan__param__s.html#af53524422716818c1fe4b79c536d26ad">plan_param_s::eTol</a>, <a class="el" href="structplan__param__s.html#a76a7cc8566f8944ae2fd732bc9f6a2e2">plan_param_s::fNom</a>, <a class="el" href="structplan__param__s.html#a1de1c25241ae5c37061641f6614968fd">plan_param_s::horizon</a>, <a class="el" href="structstate__s.html#a115a862131dd01b59673cd75655e924b">state_s::mass</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structplan__param__s.html#a0a6d501ebb06d2fa13eb3291bcf220f7">plan_param_s::nSPOCoarse</a>, <a class="el" href="structplan__param__s.html#abe6220629477a8afe3ab2cc24bd44499">plan_param_s::nSPOFine</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, <a class="el" href="structwindow__s.html#a153f8468ddb98b6f4f309f35c9799909">window_s::startTime</a>, <a class="el" href="structstate__s.html#a5422ee5e1d435f49ec8fe5b19f714fc9">state_s::tM</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, and <a class="el" href="structstate__s.html#a5064e9ff9b13b4a8cb0325497ee0e032">state_s::xH</a>.</p>

</div>
</div>
<a class="anchor" id="a6c899192f10d7382ca7565e8bf687415"></a><!-- doxytag: member="sc_formation.h::ImpulsiveLPManeuver" ref="a6c899192f10d7382ca7565e8bf687415" args="(state_t state, ecc_geom_t goals_ecc, window_t window, plan_param_t param, double &amp;maxDV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmaneuver__s.html">maneuver_s</a> ImpulsiveLPManeuver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstate__s.html">state_t</a>&#160;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals_ecc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwindow__s.html">window_t</a>&#160;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplan__param__s.html">plan_param_t</a>&#160;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>maxDV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Plans an impulsive burn sequence (using simplex) to achieve the specified trajectory within the given time window. (eccentric orbit)</p>
<p>For eccentric orbits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Data structure of Orbit state </td></tr>
    <tr><td class="paramname">goals_ecc</td><td>Data structure of geometric goal information </td></tr>
    <tr><td class="paramname">window</td><td>Data structure of commanded time window </td></tr>
    <tr><td class="paramname">param</td><td>Data structure of planning parameters </td></tr>
    <tr><td class="paramname">maxDV</td><td>The maximum delta-V of the sequence. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maneuver Maneuver data structure </dd></dl>

<p>References <a class="el" href="structmaneuver__s.html#a0e27a8845c0028dcad62ef6fc6c3cc24">maneuver_s::achieve</a>, <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structstate__s.html#afaf9f81399b6c3e1ce40574ca2a7ac9a">state_s::el</a>, <a class="el" href="structplan__param__s.html#af53524422716818c1fe4b79c536d26ad">plan_param_s::eTol</a>, <a class="el" href="structplan__param__s.html#a76a7cc8566f8944ae2fd732bc9f6a2e2">plan_param_s::fNom</a>, <a class="el" href="structplan__param__s.html#a1de1c25241ae5c37061641f6614968fd">plan_param_s::horizon</a>, <a class="el" href="structstate__s.html#a115a862131dd01b59673cd75655e924b">state_s::mass</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structplan__param__s.html#a0a6d501ebb06d2fa13eb3291bcf220f7">plan_param_s::nSPOCoarse</a>, <a class="el" href="structplan__param__s.html#abe6220629477a8afe3ab2cc24bd44499">plan_param_s::nSPOFine</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, <a class="el" href="structwindow__s.html#a153f8468ddb98b6f4f309f35c9799909">window_s::startTime</a>, <a class="el" href="structstate__s.html#a5422ee5e1d435f49ec8fe5b19f714fc9">state_s::tM</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, and <a class="el" href="structstate__s.html#a5064e9ff9b13b4a8cb0325497ee0e032">state_s::xH</a>.</p>

</div>
</div>
<a class="anchor" id="a951e3474f7bd274a346612114eb267cf"></a><!-- doxytag: member="sc_formation.h::ImpulsiveManeuver" ref="a951e3474f7bd274a346612114eb267cf" args="(state_t state, geom_t goals, window_t window, plan_param_t param, double &amp;maxDV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmaneuver__s.html">maneuver_s</a> ImpulsiveManeuver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstate__s.html">state_t</a>&#160;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwindow__s.html">window_t</a>&#160;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplan__param__s.html">plan_param_t</a>&#160;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>maxDV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Plans an impulsive burn sequence (using closed-form equations) to achieve the specified trajectory within the given time window. For circular orbits only.</p>
<p>For circular orbits only. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Data structure of Orbit state </td></tr>
    <tr><td class="paramname">goals</td><td>Data structure of geometric goal information </td></tr>
    <tr><td class="paramname">window</td><td>Data structure of commanded time window </td></tr>
    <tr><td class="paramname">param</td><td>Data structure of planning parameters </td></tr>
    <tr><td class="paramname">maxDV</td><td>The maximum delta-V of the sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maneuver Maneuver data structure </dd></dl>

<p>References <a class="el" href="structmaneuver__s.html#a0e27a8845c0028dcad62ef6fc6c3cc24">maneuver_s::achieve</a>, <a class="el" href="structmaneuver__s.html#a41a2958b6682ce07df65a74401ee7d47">maneuver_s::burnData</a>, <a class="el" href="structburn__s.html#a3dd38fed38426c459c1d64f491571fce">burn_s::dT</a>, <a class="el" href="structplan__param__s.html#a89596d179ea0535259817b575ace61d9">plan_param_s::dTMin</a>, <a class="el" href="structburn__s.html#a732ba2516c2a463b63cd2eacb3b37162">burn_s::dV</a>, <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structstate__s.html#afaf9f81399b6c3e1ce40574ca2a7ac9a">state_s::el</a>, <a class="el" href="structstate__s.html#a9aef1e85bc3d7fa51577896024afb4bf">state_s::elA</a>, <a class="el" href="structplan__param__s.html#a76a7cc8566f8944ae2fd732bc9f6a2e2">plan_param_s::fNom</a>, <a class="el" href="structplan__param__s.html#a1de1c25241ae5c37061641f6614968fd">plan_param_s::horizon</a>, <a class="el" href="structmaneuver__s.html#aacfff05d905da791dd23e4bbc33a4bcb">maneuver_s::iD</a>, <a class="el" href="structburn__s.html#a60124cd02a54a246701f2a6f42910acb">burn_s::iD</a>, <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structorb__data__s.html#aca78dbce742ffcd14bec44f404628e3b">orb_data_s::inc</a>, <a class="el" href="structstate__s.html#a115a862131dd01b59673cd75655e924b">state_s::mass</a>, <a class="el" href="sc__constants_8h.html#a671dcd512fb29ca4ef7fa99998fb2088">MU_EARTH</a>, <a class="el" href="structmaneuver__s.html#addbeae89d2eb15e2528f17937647f919">maneuver_s::nBurns</a>, <a class="el" href="structwindow__s.html#a528b04b5c3fdba6aa16747733dc7351b">window_s::nOrbMin</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, <a class="el" href="structwindow__s.html#a153f8468ddb98b6f4f309f35c9799909">window_s::startTime</a>, <a class="el" href="structburn__s.html#ad75a1ccd786c12d8c7ff246b22b6b0ff">burn_s::t</a>, <a class="el" href="structmaneuver__s.html#a61ffefc85c55ad7847276fe1cac28dd2">maneuver_s::t0</a>, <a class="el" href="structmaneuver__s.html#abeafa7fa5859039c6720f23ff5e262ca">maneuver_s::tF</a>, <a class="el" href="structwindow__s.html#ae329e76ebc8f0866d66a24a42c4bd9f2">window_s::timeWeightExp</a>, <a class="el" href="structstate__s.html#a5422ee5e1d435f49ec8fe5b19f714fc9">state_s::tM</a>, <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, <a class="el" href="structburn__s.html#a671c7bd4e478d7b52cfb036b63c80aaf">burn_s::uZ</a>, and <a class="el" href="structstate__s.html#a5064e9ff9b13b4a8cb0325497ee0e032">state_s::xH</a>.</p>

</div>
</div>
<a class="anchor" id="a10ee61229ddc70166d599d9bd2467918"></a><!-- doxytag: member="sc_formation.h::OptimalInPlaneDeltaV" ref="a10ee61229ddc70166d599d9bd2467918" args="(double nOrbMin, double nOrbMax, double a, double th0, double th1, double delta_a, double delta_th0, double delta_q1, double delta_q2, double &amp;dV1, double &amp;dV2, double &amp;dV3, unsigned short &amp;M, unsigned short &amp;N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OptimalInPlaneDeltaV </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nOrbMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nOrbMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>th0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>th1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>delta_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>delta_th0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>delta_q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>delta_q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>dV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>dV2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>dV3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"> <em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the in-plane delta-v sequence for the given time window that achieves the desired element differences and results in the minimum total delta-v. For circular orbits only.</p>
<p>For circular orbits only. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nOrbMin</td><td>Minimum number of orbits the maneuver may last </td></tr>
    <tr><td class="paramname">nOrbMax</td><td>Maximum number of orbits the maneuver may last </td></tr>
    <tr><td class="paramname">a</td><td>Mean semi-major axis of reference [km] </td></tr>
    <tr><td class="paramname">th0</td><td>Latitude of reference at measurement [rad] </td></tr>
    <tr><td class="paramname">th1</td><td>Latitude at first burn [rad] </td></tr>
    <tr><td class="paramname">delta_a</td><td>Error in semi-major axis difference [km] </td></tr>
    <tr><td class="paramname">delta_th0</td><td>Error in latitude difference [rad] </td></tr>
    <tr><td class="paramname">delta_q1</td><td>Error in q1 difference </td></tr>
    <tr><td class="paramname">delta_q2</td><td>Error in q2 difference </td></tr>
    <tr><td class="paramname">dV1</td><td>First delta-v [km/s]. Passed by reference. </td></tr>
    <tr><td class="paramname">dV2</td><td>Second delta-v [km/s]. Passed by reference. </td></tr>
    <tr><td class="paramname">dV3</td><td>Third delta-v [km/s]. Passed by reference. </td></tr>
    <tr><td class="paramname">M</td><td>Number of half-orbits between burn 1 and burn 2. Passed by reference. </td></tr>
    <tr><td class="paramname">N</td><td>Number of half-orbits between burn 1 and burn 3. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bool indicating status </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a671dcd512fb29ca4ef7fa99998fb2088">MU_EARTH</a>, and <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="a216b5b48c8c522698ee933b60b633327"></a><!-- doxytag: member="sc_formation.h::InPlane" ref="a216b5b48c8c522698ee933b60b633327" args="(alf_orb_data_t meas_elem, alf_orb_data_t delta_elem, double accNom, double dTMin, double nOrbMin, double nOrbMax, double horizon, double &amp;t0, double &amp;tF, unsigned short &amp;nBurns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structburn__s.html">burn_t</a>* InPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>meas_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>delta_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>accNom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dTMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nOrbMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nOrbMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>horizon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>tF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"> <em>nBurns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the in-plane burn sequence for the given time window that achieves the desired element differences. For circular orbits only.</p>
<p>For circular orbits only. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">meas_elem</td><td>Reference orbital elements (Alfriend format) </td></tr>
    <tr><td class="paramname">delta_elem</td><td>Error in orbital element differences (Alfriend format) </td></tr>
    <tr><td class="paramname">accNom</td><td>Nominal acceleration [km/s/s] </td></tr>
    <tr><td class="paramname">dTMin</td><td>Minimum achievable burn duration [sec] </td></tr>
    <tr><td class="paramname">nOrbMin</td><td>Minimum number of orbits maneuver may last </td></tr>
    <tr><td class="paramname">nOrbMax</td><td>Maximum number of orbits maneuver may last </td></tr>
    <tr><td class="paramname">horizon</td><td>Minimum amount of time required prior to first burn [sec] </td></tr>
    <tr><td class="paramname">t0</td><td>First burn time [sec from meas time]. Passed by reference. </td></tr>
    <tr><td class="paramname">tF</td><td>Final burn time [sec from meas time]. Passed by reference. </td></tr>
    <tr><td class="paramname">nBurns</td><td>Number of burns required. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>burn_t Burn Data structure </dd></dl>

<p>References <a class="el" href="structburn__s.html#a3dd38fed38426c459c1d64f491571fce">burn_s::dT</a>, <a class="el" href="structburn__s.html#a732ba2516c2a463b63cd2eacb3b37162">burn_s::dV</a>, <a class="el" href="sc__constants_8h.html#a671dcd512fb29ca4ef7fa99998fb2088">MU_EARTH</a>, <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structburn__s.html#ad75a1ccd786c12d8c7ff246b22b6b0ff">burn_s::t</a>, <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, <a class="el" href="structburn__s.html#ac1cecd41ced16122540106b43a451db6">burn_s::uX</a>, <a class="el" href="structburn__s.html#a222019ec604c14b1351f2662d69d8806">burn_s::uY</a>, and <a class="el" href="structburn__s.html#a671c7bd4e478d7b52cfb036b63c80aaf">burn_s::uZ</a>.</p>

</div>
</div>
<a class="anchor" id="af9298ec71d7c8e0a7fb5ffc7b8566dbf"></a><!-- doxytag: member="sc_formation.h::OutOfPlane" ref="af9298ec71d7c8e0a7fb5ffc7b8566dbf" args="(alf_orb_data_t meas_elem, alf_orb_data_t delta_elem, double accNom, double dTMin, unsigned short &amp;nBurns, double &amp;th1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structburn__s.html">burn_t</a> OutOfPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>meas_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>delta_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>accNom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dTMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"> <em>nBurns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>th1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the out-of-plane burn sequence for the given time window that achieves the desired element differences. For circular orbits only.</p>
<p>For circular orbits only. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">meas_elem</td><td>Reference orbital elements (Alfriend format) </td></tr>
    <tr><td class="paramname">delta_elem</td><td>Error in orbital element differences (Alfriend format) </td></tr>
    <tr><td class="paramname">accNom</td><td>Nominal acceleration [km/s/s] </td></tr>
    <tr><td class="paramname">dTMin</td><td>Minimum achievable burn duration [sec] </td></tr>
    <tr><td class="paramname">nBurns</td><td>Number of burns required. Passed by reference. </td></tr>
    <tr><td class="paramname">th1</td><td>Argument of latitude at which burn is applied. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>burn_t Burn Data structure </dd></dl>

<p>References <a class="el" href="structburn__s.html#a3dd38fed38426c459c1d64f491571fce">burn_s::dT</a>, <a class="el" href="structburn__s.html#a732ba2516c2a463b63cd2eacb3b37162">burn_s::dV</a>, <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="sc__constants_8h.html#a671dcd512fb29ca4ef7fa99998fb2088">MU_EARTH</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structburn__s.html#ad75a1ccd786c12d8c7ff246b22b6b0ff">burn_s::t</a>, <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, <a class="el" href="structburn__s.html#ac1cecd41ced16122540106b43a451db6">burn_s::uX</a>, <a class="el" href="structburn__s.html#a222019ec604c14b1351f2662d69d8806">burn_s::uY</a>, and <a class="el" href="structburn__s.html#a671c7bd4e478d7b52cfb036b63c80aaf">burn_s::uZ</a>.</p>

</div>
</div>
<a class="anchor" id="af930b71e18e6b78114c0c39f833bf784"></a><!-- doxytag: member="sc_formation.h::AutoFormGeometry" ref="af930b71e18e6b78114c0c39f833bf784" args="(state_t state, geom_t memberGoals[], int num, double minSepDist, double maxSepDist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgeom__s.html">geom_t</a> AutoFormGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstate__s.html">state_t</a>&#160;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td>
          <td class="paramname"> <em>memberGoals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>minSepDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>maxSepDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Orbital state data structure </td></tr>
    <tr><td class="paramname">memberGoals</td><td>Geometric goals for all other members in the cluster </td></tr>
    <tr><td class="paramname">num</td><td>Number of samples to use </td></tr>
    <tr><td class="paramname">minSepDist</td><td>Minimum allowable separation distance between satellites </td></tr>
    <tr><td class="paramname">maxSepDist</td><td>Maximum allowable separation distance between satellites </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>goals Geometric goals </dd></dl>

<p>References <a class="el" href="structgeom__s.html#adbab6299d3a80e8b379109f27090a53e">geom_s::aE</a>, <a class="el" href="structstate__s.html#a03d04ef0a4b8ef87ddab45a42ac86df1">state_s::dEl</a>, <a class="el" href="structstate__s.html#a9aef1e85bc3d7fa51577896024afb4bf">state_s::elA</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, and <a class="el" href="structgeom__s.html#a77ae63a3565f10d54abb66f795c59fed">geom_s::y0</a>.</p>

</div>
</div>
<a class="anchor" id="a28b93c9072fd60838af01674cd057933"></a><!-- doxytag: member="sc_formation.h::AutoFormGeometry" ref="a28b93c9072fd60838af01674cd057933" args="(state_t state, ecc_geom_t memberGoals[], int num, double minSepDist, double maxSepDist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a> AutoFormGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstate__s.html">state_t</a>&#160;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td>
          <td class="paramname"> <em>memberGoals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>minSepDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>maxSepDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Orbital state data structure </td></tr>
    <tr><td class="paramname">memberGoals</td><td>Geometric goals for all other members in the cluster </td></tr>
    <tr><td class="paramname">num</td><td>Number of samples to use </td></tr>
    <tr><td class="paramname">minSepDist</td><td>Minimum allowable separation distance between satellites </td></tr>
    <tr><td class="paramname">maxSepDist</td><td>Maximum allowable separation distance between satellites </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>goals Geometric goals </dd></dl>

<p>References <a class="el" href="structstate__s.html#a03d04ef0a4b8ef87ddab45a42ac86df1">state_s::dEl</a>, <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structstate__s.html#afaf9f81399b6c3e1ce40574ca2a7ac9a">state_s::el</a>, <a class="el" href="structstate__s.html#a9aef1e85bc3d7fa51577896024afb4bf">state_s::elA</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structecc__geom__s.html#a1aaa582416e17189a9fc5a93813f11f2">ecc_geom_s::xMax</a>, and <a class="el" href="structecc__geom__s.html#a3d8183a44331649433736f42373959c2">ecc_geom_s::y0</a>.</p>

</div>
</div>
<a class="anchor" id="a8d39238a2a2799ae7038e815ef4bb232"></a><!-- doxytag: member="sc_formation.h::NearestOffset" ref="a8d39238a2a2799ae7038e815ef4bb232" args="(double y0, double width, ml_matrix extrema, double minSepDistance, double maxSepDistance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double NearestOffset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>extrema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>minSepDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>maxSepDistance</em> = <code>1e9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">y0</td><td>Original along-track offset (on y-axis) </td></tr>
    <tr><td class="paramname">width</td><td>Width of trajectory on y-axis </td></tr>
    <tr><td class="paramname">extrema</td><td>Extrema pairs (min, max) on y-axis for N other trajectories </td></tr>
    <tr><td class="paramname">minSepDistance</td><td>Minimum separation distance between trajectories </td></tr>
    <tr><td class="paramname">maxSepDistance</td><td>Maximum separation distance between trajectories </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>y0 Nearest along-track offset that meets separation objectives </dd></dl>

</div>
</div>
<a class="anchor" id="afaf543479a5967f9521b3a274579e40a"></a><!-- doxytag: member="sc_formation.h::InitializeCostMatrix" ref="afaf543479a5967f9521b3a274579e40a" args="(team_goals_t teamGoals, int nRelatives)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix InitializeCostMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteam__goals__s.html">team_goals_t</a>&#160;</td>
          <td class="paramname"> <em>teamGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nRelatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure </td></tr>
    <tr><td class="paramname">nRelatives</td><td>Number of relatives in the team </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>f Cost matrix of the appropriate size, filled with zeros </dd></dl>

<p>References <a class="el" href="structteam__goals__s.html#ac8a71612bfd464a2f18cde825b875baf">team_goals_s::constraints</a>, <a class="el" href="structteam__goals__s.html#ade4986c696a100b094956c75c523ecf9">team_goals_s::dPhi</a>, <a class="el" href="structteam__goals__s.html#a92e96f5b7fdb990794e764be8736ee93">team_goals_s::nU</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, and <a class="el" href="structconstraints__s.html#aaff21687a20f718abfb9e7c10769daad">constraints_s::variable</a>.</p>

</div>
</div>
<a class="anchor" id="af912829996c2000172d4a2cf3edca62b"></a><!-- doxytag: member="sc_formation.h::InitializeCostMatrix" ref="af912829996c2000172d4a2cf3edca62b" args="(ecc_team_goals_t teamGoals, int nRelatives)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix InitializeCostMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a>&#160;</td>
          <td class="paramname"> <em>teamGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nRelatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure </td></tr>
    <tr><td class="paramname">nRelatives</td><td>Number of relatives in the team </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>f Cost matrix of the appropriate size, filled with zeros </dd></dl>

<p>References <a class="el" href="structecc__team__goals__s.html#a20536770d4b16d45e8e6eb9d13cb98d9">ecc_team_goals_s::constraints</a>, <a class="el" href="structecc__team__goals__s.html#a3c997b931898c2b026266e00e47896c4">ecc_team_goals_s::dPhi</a>, <a class="el" href="structconstraints__s.html#aac03121e4b2a3cd216ed0bbf8959586b">constraints_s::nDuplicates</a>, <a class="el" href="structecc__team__goals__s.html#a490e0c75869a74a95c1c01e747a28005">ecc_team_goals_s::nU</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, and <a class="el" href="structconstraints__s.html#aaff21687a20f718abfb9e7c10769daad">constraints_s::variable</a>.</p>

</div>
</div>
<a class="anchor" id="ab8e538e646e8f96b5fa313af66048a36"></a><!-- doxytag: member="sc_formation.h::PopulateCostMatrix" ref="ab8e538e646e8f96b5fa313af66048a36" args="(ml_matrix &amp;f, cost_t costEstimate, team_goals_t teamGoals, ml_int_array relativeIDs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PopulateCostMatrix </td>
          <td>(</td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcost__s.html">cost_t</a>&#160;</td>
          <td class="paramname"> <em>costEstimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteam__goals__s.html">team_goals_t</a>&#160;</td>
          <td class="paramname"> <em>teamGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_int_array&#160;</td>
          <td class="paramname"> <em>relativeIDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Initial cost matrix </td></tr>
    <tr><td class="paramname">costEstimate</td><td>Cost estimate data structure supplied from a team member </td></tr>
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure used to generate the cost estimates </td></tr>
    <tr><td class="paramname">relativeIDs</td><td>Array of member IDs for all relatives in the team </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>f Updated cost matrix </dd>
<dd>
col Index of the cost matrix column that was filled in. Returns -1 if the member ID occurs multiple times in the relativeIDs array. Returns -2 if the target index list has repeated elements. Returns -3 if the size of the cost estimate to be inserted does not match the size of the matrix </dd></dl>

<p>References <a class="el" href="structcost__s.html#aa153af6e8488a3f9a24d89012081156c">cost_s::cost</a>, <a class="el" href="structcost__s.html#a78448f053fb66a7b2d3814b0d5a62338">cost_s::costLength</a>, <a class="el" href="structteam__goals__s.html#ade4986c696a100b094956c75c523ecf9">team_goals_s::dPhi</a>, <a class="el" href="structcost__s.html#abed5e03416ea643f51a78afded50e8e4">cost_s::memID</a>, <a class="el" href="structcost__s.html#a8e416f036ecfd9f863ca114c198fb450">cost_s::nU</a>, <a class="el" href="structteam__goals__s.html#a92e96f5b7fdb990794e764be8736ee93">team_goals_s::nU</a>, <a class="el" href="structcost__s.html#a804333a269e2e1cf82c541467d6ad717">cost_s::targetIndex</a>, and <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="a6884c557f39bc424ebe582c2b1d9d5bd"></a><!-- doxytag: member="sc_formation.h::PopulateCostMatrix" ref="a6884c557f39bc424ebe582c2b1d9d5bd" args="(ml_matrix &amp;f, cost_t costEstimate, ecc_team_goals_t teamGoals, ml_int_array relativeIDs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PopulateCostMatrix </td>
          <td>(</td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcost__s.html">cost_t</a>&#160;</td>
          <td class="paramname"> <em>costEstimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a>&#160;</td>
          <td class="paramname"> <em>teamGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_int_array&#160;</td>
          <td class="paramname"> <em>relativeIDs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Initial cost matrix </td></tr>
    <tr><td class="paramname">costEstimate</td><td>Cost estimate data structure supplied from a team member </td></tr>
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure used to generate the cost estimates </td></tr>
    <tr><td class="paramname">relativeIDs</td><td>Array of member IDs for all relatives in the team </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>f Updated cost matrix </dd>
<dd>
col Index of the cost matrix column that was filled in. Returns -1 if the member ID occurs multiple times in the relativeIDs array. Returns -2 if the target index list has repeated elements. Returns -3 if the size of the cost estimate to be inserted does not match the size of the matrix </dd></dl>

<p>References <a class="el" href="structcost__s.html#aa153af6e8488a3f9a24d89012081156c">cost_s::cost</a>, <a class="el" href="structcost__s.html#a78448f053fb66a7b2d3814b0d5a62338">cost_s::costLength</a>, <a class="el" href="structecc__team__goals__s.html#a3c997b931898c2b026266e00e47896c4">ecc_team_goals_s::dPhi</a>, <a class="el" href="structcost__s.html#abed5e03416ea643f51a78afded50e8e4">cost_s::memID</a>, <a class="el" href="structcost__s.html#a8e416f036ecfd9f863ca114c198fb450">cost_s::nU</a>, <a class="el" href="structecc__team__goals__s.html#a490e0c75869a74a95c1c01e747a28005">ecc_team_goals_s::nU</a>, <a class="el" href="structcost__s.html#a804333a269e2e1cf82c541467d6ad717">cost_s::targetIndex</a>, and <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="a0248dbd54b96c64abd565cb81a45f211"></a><!-- doxytag: member="sc_formation.h::CostMatrixRows" ref="a0248dbd54b96c64abd565cb81a45f211" args="(team_goals_t teamGoals, int index, int &amp;a, int &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CostMatrixRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteam__goals__s.html">team_goals_t</a>&#160;</td>
          <td class="paramname"> <em>teamGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"> <em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the starting and ending rows in the cost matrix that correspond to a give target state index.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure </td></tr>
    <tr><td class="paramname">index</td><td>Target state index </td></tr>
    <tr><td class="paramname">a</td><td>Starting row. Passed by reference. </td></tr>
    <tr><td class="paramname">b</td><td>Ending row. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structteam__goals__s.html#ac8a71612bfd464a2f18cde825b875baf">team_goals_s::constraints</a>, <a class="el" href="structteam__goals__s.html#ade4986c696a100b094956c75c523ecf9">team_goals_s::dPhi</a>, <a class="el" href="structteam__goals__s.html#a92e96f5b7fdb990794e764be8736ee93">team_goals_s::nU</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, and <a class="el" href="structconstraints__s.html#aaff21687a20f718abfb9e7c10769daad">constraints_s::variable</a>.</p>

</div>
</div>
<a class="anchor" id="ab76be5097545f7cd3a175f13e0f3edf2"></a><!-- doxytag: member="sc_formation.h::CostMatrixRows" ref="ab76be5097545f7cd3a175f13e0f3edf2" args="(ecc_team_goals_t teamGoals, int index, int &amp;a, int &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CostMatrixRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a>&#160;</td>
          <td class="paramname"> <em>teamGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"> <em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the starting and ending rows in the cost matrix that correspond to a give target state index.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure </td></tr>
    <tr><td class="paramname">index</td><td>Target state index </td></tr>
    <tr><td class="paramname">a</td><td>Starting row. Passed by reference. </td></tr>
    <tr><td class="paramname">b</td><td>Ending row. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structecc__team__goals__s.html#a20536770d4b16d45e8e6eb9d13cb98d9">ecc_team_goals_s::constraints</a>, <a class="el" href="structecc__team__goals__s.html#a3c997b931898c2b026266e00e47896c4">ecc_team_goals_s::dPhi</a>, <a class="el" href="structecc__team__goals__s.html#a490e0c75869a74a95c1c01e747a28005">ecc_team_goals_s::nU</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, and <a class="el" href="structconstraints__s.html#aaff21687a20f718abfb9e7c10769daad">constraints_s::variable</a>.</p>

</div>
</div>
<a class="anchor" id="aa52b1836b8d186d129d18cba49a482b0"></a><!-- doxytag: member="sc_formation.h::EstimateCost" ref="aa52b1836b8d186d129d18cba49a482b0" args="(alf_orb_data_t el0, alf_orb_data_t dEl, team_goals_t teamGoals, int memID, window_t window, double weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcost__s.html">cost_s</a> EstimateCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>dEl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteam__goals__s.html">team_goals_t</a>&#160;</td>
          <td class="paramname"> <em>teamGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>memID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwindow__s.html">window_t</a>&#160;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Initial reference orbital elements (Alfriend format) [a,theta,i,q1,q2,W] </td></tr>
    <tr><td class="paramname">dEl</td><td>Initial orbital element differences (Alfriend format) </td></tr>
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure defining desired relative motion for team </td></tr>
    <tr><td class="paramname">memID</td><td>Unique member ID </td></tr>
    <tr><td class="paramname">window</td><td>Time window data structure </td></tr>
    <tr><td class="paramname">weight</td><td>Scalar weight to be applied to all costs for this spacecraft </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>costEstimate Data structure including weighted cost to achieve all specified unique target states. </dd></dl>

<p>References <a class="el" href="structteam__goals__s.html#ac8a71612bfd464a2f18cde825b875baf">team_goals_s::constraints</a>, <a class="el" href="structcost__s.html#aa153af6e8488a3f9a24d89012081156c">cost_s::cost</a>, <a class="el" href="structcost__s.html#a78448f053fb66a7b2d3814b0d5a62338">cost_s::costLength</a>, <a class="el" href="structteam__goals__s.html#ade4986c696a100b094956c75c523ecf9">team_goals_s::dPhi</a>, <a class="el" href="structteam__goals__s.html#aa90b851cb34cbec0717586a11870d5c2">team_goals_s::geometry</a>, <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structassign__s.html#a0e281d17f095584685754c034c24c828">assign_s::M</a>, <a class="el" href="structcost__s.html#abed5e03416ea643f51a78afded50e8e4">cost_s::memID</a>, <a class="el" href="sc__constants_8h.html#a671dcd512fb29ca4ef7fa99998fb2088">MU_EARTH</a>, <a class="el" href="structwindow__s.html#a37982aa244a9c36d996c7b085d71eec0">window_s::nOrbMax</a>, <a class="el" href="structwindow__s.html#a528b04b5c3fdba6aa16747733dc7351b">window_s::nOrbMin</a>, <a class="el" href="structconstraints__s.html#ae02a521669b816eb4ceea491110e28be">constraints_s::nRestrict</a>, <a class="el" href="structcost__s.html#a8e416f036ecfd9f863ca114c198fb450">cost_s::nU</a>, <a class="el" href="structteam__goals__s.html#a92e96f5b7fdb990794e764be8736ee93">team_goals_s::nU</a>, <a class="el" href="structassign__s.html#a10beb97c36e4237e232f8fdcb3638f05">assign_s::Pu</a>, <a class="el" href="structassign__s.html#a8c991751e19640ac66161e12dab26349">assign_s::Q</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structconstraints__s.html#a4096ee054ae1ddb17c86b3faa1afb12d">constraints_s::restrictID</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structcost__s.html#a804333a269e2e1cf82c541467d6ad717">cost_s::targetIndex</a>, <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>, and <a class="el" href="structconstraints__s.html#aaff21687a20f718abfb9e7c10769daad">constraints_s::variable</a>.</p>

</div>
</div>
<a class="anchor" id="ab66122ef6116f062c130de9acfcba88f"></a><!-- doxytag: member="sc_formation.h::FFEccEstimateCost" ref="ab66122ef6116f062c130de9acfcba88f" args="(orb_data_t el0, const ml_matrix &amp;xH0, ecc_team_goals_t teamGoals, int memID, window_t window, double weight, int nSPO)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcost__s.html">cost_s</a> FFEccEstimateCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a>&#160;</td>
          <td class="paramname"> <em>teamGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>memID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwindow__s.html">window_t</a>&#160;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nSPO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Initial reference orbital elements (Alfriend format) [a,theta,i,q1,q2,W] </td></tr>
    <tr><td class="paramname">xH0</td><td>Initial relative state, Hills frame </td></tr>
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure defining desired relative motion for team </td></tr>
    <tr><td class="paramname">memID</td><td>Unique member ID </td></tr>
    <tr><td class="paramname">window</td><td>Time window data structure </td></tr>
    <tr><td class="paramname">weight</td><td>Scalar weight to be applied to all costs for this spacecraft </td></tr>
    <tr><td class="paramname">nSPO</td><td>Number of samples to use per orbit for LP algorithm </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>costEstimate Data structure including weighted cost to achieve all specified unique target states. </dd></dl>

<p>References <a class="el" href="structecc__team__goals__s.html#a20536770d4b16d45e8e6eb9d13cb98d9">ecc_team_goals_s::constraints</a>, <a class="el" href="structcost__s.html#aa153af6e8488a3f9a24d89012081156c">cost_s::cost</a>, <a class="el" href="structcost__s.html#a78448f053fb66a7b2d3814b0d5a62338">cost_s::costLength</a>, <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structecc__team__goals__s.html#a0db82e83115beda6dccb21de30edfee4">ecc_team_goals_s::geometry</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structcost__s.html#abed5e03416ea643f51a78afded50e8e4">cost_s::memID</a>, <a class="el" href="structwindow__s.html#a37982aa244a9c36d996c7b085d71eec0">window_s::nOrbMax</a>, <a class="el" href="structconstraints__s.html#ae02a521669b816eb4ceea491110e28be">constraints_s::nRestrict</a>, <a class="el" href="structcost__s.html#a8e416f036ecfd9f863ca114c198fb450">cost_s::nU</a>, <a class="el" href="structecc__team__goals__s.html#a490e0c75869a74a95c1c01e747a28005">ecc_team_goals_s::nU</a>, <a class="el" href="structconstraints__s.html#a4096ee054ae1ddb17c86b3faa1afb12d">constraints_s::restrictID</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, <a class="el" href="structcost__s.html#a804333a269e2e1cf82c541467d6ad717">cost_s::targetIndex</a>, and <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="ab42994a20f26ea6113a919b40354d9e8"></a><!-- doxytag: member="sc_formation.h::GenerateTeamGoals" ref="ab42994a20f26ea6113a919b40354d9e8" args="(alf_orb_data_t el0, int fType, double fSize, unsigned short nRels, int teamID, double angRes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structteam__goals__s.html">team_goals_s</a> GenerateTeamGoals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>fType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>fSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"> <em>nRels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>teamID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>angRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>reference orbital elements [a,th,i,q1,q2,W] </td></tr>
    <tr><td class="paramname">fType</td><td>formation type </td></tr>
    <tr><td class="paramname">fSize</td><td>formation size </td></tr>
    <tr><td class="paramname">nRels</td><td>number of relatives in the team </td></tr>
    <tr><td class="paramname">teamID</td><td>unique integer team ID </td></tr>
    <tr><td class="paramname">angRes</td><td>angular resolution for discretized search with variable states [rad] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>teamGoals Team Goals data structure, with geometric goals for all unique states, and corresponding constraints </dd></dl>

<p>References <a class="el" href="structgeom__s.html#adbab6299d3a80e8b379109f27090a53e">geom_s::aE</a>, <a class="el" href="structgeom__s.html#a9e8abc825a605849d01aa190ccf31912">geom_s::beta</a>, <a class="el" href="structteam__goals__s.html#ac8a71612bfd464a2f18cde825b875baf">team_goals_s::constraints</a>, <a class="el" href="structteam__goals__s.html#ade4986c696a100b094956c75c523ecf9">team_goals_s::dPhi</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa0eb99898ac2f91ce66481a8b6af967c3">FF_CIPE_REF_CENTER</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa19140e073540c844fe704a7a430ecb20">FF_CIPE_REF_ON</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa8aa6e1395a03bd126d7931a85185be36">FF_DUAL_PROJ_CIRC_REF_CENTER</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa20d3747960ede74dfa42cf338bd26ab8">FF_DUAL_PROJ_CIRC_REF_ON</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa06b2fd15913aea7e8bb4430081d9163c">FF_IPLF</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa3cfb553f361551d1fb68db4db78c390b">FF_NEG_PROJ_CIRC_REF_CENTER</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa3cbf08946a76fc33cfdf83a96993a6b1">FF_NEG_PROJ_CIRC_REF_ON</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa0a7cee1fde4b78838173a2d9d987edd3">FF_OOPLF_RGT</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa83b8268d7866574ec605bf6d13351ca3">FF_POS_PROJ_CIRC_REF_CENTER</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aaaf3c8172172f0d49b1a1a7f54c82c607">FF_POS_PROJ_CIRC_REF_ON</a>, <a class="el" href="structteam__goals__s.html#aa90b851cb34cbec0717586a11870d5c2">team_goals_s::geometry</a>, <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structconstraints__s.html#aac03121e4b2a3cd216ed0bbf8959586b">constraints_s::nDuplicates</a>, <a class="el" href="structconstraints__s.html#ae02a521669b816eb4ceea491110e28be">constraints_s::nRestrict</a>, <a class="el" href="structteam__goals__s.html#a92e96f5b7fdb990794e764be8736ee93">team_goals_s::nU</a>, <a class="el" href="structconstraints__s.html#a17ce90507a7a226bdcb5be44634ff308">constraints_s::phase</a>, <a class="el" href="sc__constants_8h.html#af55edb638dc6bf2a7d395ad2b34563ad">SECS_TO_DAYS</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structteam__goals__s.html#a840420a08b077e78250db5d63646d2e2">team_goals_s::teamID</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, <a class="el" href="structconstraints__s.html#aaff21687a20f718abfb9e7c10769daad">constraints_s::variable</a>, <a class="el" href="structgeom__s.html#a77ae63a3565f10d54abb66f795c59fed">geom_s::y0</a>, <a class="el" href="structgeom__s.html#ab27c76d41aabc8d362636f7e9be1cc16">geom_s::zInc</a>, and <a class="el" href="structgeom__s.html#a65ef88a8b5f6de3bb8616e8d87611e2c">geom_s::zLan</a>.</p>

</div>
</div>
<a class="anchor" id="a8b1b3f8e516edd6d33bea91fb1d5e537"></a><!-- doxytag: member="sc_formation.h::FFEccGenerateTeamGoals" ref="a8b1b3f8e516edd6d33bea91fb1d5e537" args="(orb_data_t el0, int fType, double fSize, unsigned short nRels, int teamID, double nu, const ml_matrix &amp;eul)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structecc__team__goals__s.html">ecc_team_goals_s</a> FFEccGenerateTeamGoals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>fType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>fSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"> <em>nRels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>teamID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>eul</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Orbital elements </td></tr>
    <tr><td class="paramname">fType</td><td>Formation type </td></tr>
    <tr><td class="paramname">fSize</td><td>Formation size </td></tr>
    <tr><td class="paramname">nRels</td><td>Number of relatives </td></tr>
    <tr><td class="paramname">teamID</td><td>Team ID </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly </td></tr>
    <tr><td class="paramname">eul</td><td>Euler angles </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Eccentric team goals </dd></dl>

<p>References <a class="el" href="structecc__team__goals__s.html#a20536770d4b16d45e8e6eb9d13cb98d9">ecc_team_goals_s::constraints</a>, <a class="el" href="structteam__goals__s.html#ac8a71612bfd464a2f18cde825b875baf">team_goals_s::constraints</a>, <a class="el" href="structecc__team__goals__s.html#a3c997b931898c2b026266e00e47896c4">ecc_team_goals_s::dPhi</a>, <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="sc__formation_8h.html#aa6fe0c996902e6cf5de765184ebd8c5aa740a8f83f7b13bc8ff4b5dd098c1ea15">FF_TETRA</a>, <a class="el" href="structecc__team__goals__s.html#a0db82e83115beda6dccb21de30edfee4">ecc_team_goals_s::geometry</a>, <a class="el" href="structteam__goals__s.html#aa90b851cb34cbec0717586a11870d5c2">team_goals_s::geometry</a>, <a class="el" href="structconstraints__s.html#aac03121e4b2a3cd216ed0bbf8959586b">constraints_s::nDuplicates</a>, <a class="el" href="structconstraints__s.html#ae02a521669b816eb4ceea491110e28be">constraints_s::nRestrict</a>, <a class="el" href="structteam__goals__s.html#a92e96f5b7fdb990794e764be8736ee93">team_goals_s::nU</a>, <a class="el" href="structecc__team__goals__s.html#a490e0c75869a74a95c1c01e747a28005">ecc_team_goals_s::nU</a>, <a class="el" href="structecc__geom__xy__s.html#a33da68d4e2ad9ff954d79abb7478b6de">ecc_geom_xy_s::nu_xy</a>, <a class="el" href="structecc__geom__xy__s.html#a4031c8b518aae57404ba68f17f05f6db">ecc_geom_xy_s::nu_zMax</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structconstraints__s.html#a17ce90507a7a226bdcb5be44634ff308">constraints_s::phase</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, <a class="el" href="structecc__team__goals__s.html#a60f4ae27337dd6e8af9f4ab4ee661b64">ecc_team_goals_s::teamID</a>, <a class="el" href="structconstraints__s.html#aaff21687a20f718abfb9e7c10769daad">constraints_s::variable</a>, <a class="el" href="structecc__geom__xy__s.html#a25e867b82a46593378c0299ae3d465fe">ecc_geom_xy_s::x</a>, <a class="el" href="structecc__geom__xy__s.html#a5e11810e03d8304f99bbd37bc3333b1c">ecc_geom_xy_s::y</a>, <a class="el" href="structgeom__s.html#a77ae63a3565f10d54abb66f795c59fed">geom_s::y0</a>, <a class="el" href="structecc__geom__xy__s.html#a13d9b9dfe6ca0fa2b9830431cb34cdd0">ecc_geom_xy_s::y0</a>, and <a class="el" href="structecc__geom__xy__s.html#a4ba598cb63616fd7322680b958d94eda">ecc_geom_xy_s::zMax</a>.</p>

</div>
</div>
<a class="anchor" id="a6c338f9f99f758e76674c45e3ca839f5"></a><!-- doxytag: member="sc_formation.h::FFEccTetrahedronGeometry" ref="a6c338f9f99f758e76674c45e3ca839f5" args="(double nu, double d, const ml_matrix &amp;eul)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structecc__geom__xy__s.html">ecc_geom_xy_s</a>* FFEccTetrahedronGeometry </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>eul</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>True anomaly where tetrahedron occurs </td></tr>
    <tr><td class="paramname">d</td><td>Length of each side </td></tr>
    <tr><td class="paramname">eul</td><td>Euler angles defining the orientation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>g Geometric goals data structure </dd></dl>

<p>References <a class="el" href="structecc__geom__xy__s.html#a33da68d4e2ad9ff954d79abb7478b6de">ecc_geom_xy_s::nu_xy</a>, <a class="el" href="structecc__geom__xy__s.html#a4031c8b518aae57404ba68f17f05f6db">ecc_geom_xy_s::nu_zMax</a>, <a class="el" href="structecc__geom__xy__s.html#a25e867b82a46593378c0299ae3d465fe">ecc_geom_xy_s::x</a>, <a class="el" href="structecc__geom__xy__s.html#a5e11810e03d8304f99bbd37bc3333b1c">ecc_geom_xy_s::y</a>, <a class="el" href="structecc__geom__xy__s.html#a13d9b9dfe6ca0fa2b9830431cb34cdd0">ecc_geom_xy_s::y0</a>, and <a class="el" href="structecc__geom__xy__s.html#a4ba598cb63616fd7322680b958d94eda">ecc_geom_xy_s::zMax</a>.</p>

</div>
</div>
<a class="anchor" id="ac5beb849cb29ec5e7dd2632579c93f80"></a><!-- doxytag: member="sc_formation.h::PCGoals" ref="ac5beb849cb29ec5e7dd2632579c93f80" args="(double R, double alpha0, double sgn, double y0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgeom__s.html">geom_s</a> PCGoals </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>alpha0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>sgn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>y0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>radius of the projected circle [km] </td></tr>
    <tr><td class="paramname">alpha0</td><td>angular offset around circle [rad] </td></tr>
    <tr><td class="paramname">sgn</td><td>orientation of plane </td></tr>
    <tr><td class="paramname">y0</td><td>along-track offset [km] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>g geomtric goals data structures </dd></dl>

<p>References <a class="el" href="structgeom__s.html#adbab6299d3a80e8b379109f27090a53e">geom_s::aE</a>, <a class="el" href="structgeom__s.html#a9e8abc825a605849d01aa190ccf31912">geom_s::beta</a>, <a class="el" href="structgeom__s.html#a77ae63a3565f10d54abb66f795c59fed">geom_s::y0</a>, <a class="el" href="structgeom__s.html#ab27c76d41aabc8d362636f7e9be1cc16">geom_s::zInc</a>, and <a class="el" href="structgeom__s.html#a65ef88a8b5f6de3bb8616e8d87611e2c">geom_s::zLan</a>.</p>

</div>
</div>
<a class="anchor" id="a5585fe0ed259d281f2454761fe746168"></a><!-- doxytag: member="sc_formation.h::SortTeamGoals" ref="a5585fe0ed259d281f2454761fe746168" args="(team_goals_t &amp;teamGoals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SortTeamGoals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteam__goals__s.html">team_goals_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>teamGoals</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure, supplied from ground. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structteam__goals__s.html#ac8a71612bfd464a2f18cde825b875baf">team_goals_s::constraints</a>, <a class="el" href="structteam__goals__s.html#aa90b851cb34cbec0717586a11870d5c2">team_goals_s::geometry</a>, <a class="el" href="structteam__goals__s.html#a92e96f5b7fdb990794e764be8736ee93">team_goals_s::nU</a>, and <a class="el" href="structconstraints__s.html#aaff21687a20f718abfb9e7c10769daad">constraints_s::variable</a>.</p>

</div>
</div>
<a class="anchor" id="a0f21d2e3a549f8688f110fd126ce13a8"></a><!-- doxytag: member="sc_formation.h::SortTeamGoals" ref="a0f21d2e3a549f8688f110fd126ce13a8" args="(ecc_team_goals_t &amp;teamGoals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SortTeamGoals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>teamGoals</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure, supplied from ground. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structecc__team__goals__s.html#a20536770d4b16d45e8e6eb9d13cb98d9">ecc_team_goals_s::constraints</a>, <a class="el" href="structecc__team__goals__s.html#a0db82e83115beda6dccb21de30edfee4">ecc_team_goals_s::geometry</a>, <a class="el" href="structecc__team__goals__s.html#a490e0c75869a74a95c1c01e747a28005">ecc_team_goals_s::nU</a>, and <a class="el" href="structconstraints__s.html#aaff21687a20f718abfb9e7c10769daad">constraints_s::variable</a>.</p>

</div>
</div>
<a class="anchor" id="a9b3120cc29ce3074c6872310ecaedc0b"></a><!-- doxytag: member="sc_formation.h::SetupAssignmentProblem" ref="a9b3120cc29ce3074c6872310ecaedc0b" args="(team_goals_t teamGoals, double orbFrac=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structassign__s.html">assign_s</a> SetupAssignmentProblem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteam__goals__s.html">team_goals_t</a>&#160;</td>
          <td class="paramname"> <em>teamGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>orbFrac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure </td></tr>
    <tr><td class="paramname">orbFrac</td><td>fraction of orbit </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>assign assignment parameters data structure </dd></dl>

<p>References <a class="el" href="structgeom__s.html#a9e8abc825a605849d01aa190ccf31912">geom_s::beta</a>, <a class="el" href="structteam__goals__s.html#ac8a71612bfd464a2f18cde825b875baf">team_goals_s::constraints</a>, <a class="el" href="structteam__goals__s.html#ade4986c696a100b094956c75c523ecf9">team_goals_s::dPhi</a>, <a class="el" href="structteam__goals__s.html#aa90b851cb34cbec0717586a11870d5c2">team_goals_s::geometry</a>, <a class="el" href="structassign__s.html#a0e281d17f095584685754c034c24c828">assign_s::M</a>, <a class="el" href="structassign__s.html#a7bff46d146353bd56b15680e94b95eed">assign_s::N</a>, <a class="el" href="structconstraints__s.html#aac03121e4b2a3cd216ed0bbf8959586b">constraints_s::nDuplicates</a>, <a class="el" href="structteam__goals__s.html#a92e96f5b7fdb990794e764be8736ee93">team_goals_s::nU</a>, <a class="el" href="structassign__s.html#a3b50bf737563fbcfeefa6f3f6332efc2">assign_s::P</a>, <a class="el" href="structconstraints__s.html#a17ce90507a7a226bdcb5be44634ff308">constraints_s::phase</a>, <a class="el" href="structassign__s.html#a1bfcd63806f793eb0042f005896e3268">assign_s::phi</a>, <a class="el" href="structassign__s.html#a10beb97c36e4237e232f8fdcb3638f05">assign_s::Pu</a>, <a class="el" href="structassign__s.html#a8c991751e19640ac66161e12dab26349">assign_s::Q</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, <a class="el" href="structassign__s.html#ad380cf6fe6fb4610fd4cb9c544f906e5">assign_s::u</a>, and <a class="el" href="structconstraints__s.html#aaff21687a20f718abfb9e7c10769daad">constraints_s::variable</a>.</p>

</div>
</div>
<a class="anchor" id="a472bc30f4862e40be59b37c498346670"></a><!-- doxytag: member="sc_formation.h::SetupAssignmentProblem" ref="a472bc30f4862e40be59b37c498346670" args="(ecc_team_goals_t teamGoals, double orbFrac=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structassign__s.html">assign_s</a> SetupAssignmentProblem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structecc__team__goals__s.html">ecc_team_goals_t</a>&#160;</td>
          <td class="paramname"> <em>teamGoals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>orbFrac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">teamGoals</td><td>Team goals data structure </td></tr>
    <tr><td class="paramname">orbFrac</td><td>fraction of orbit </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>assign assignment parameters data structure </dd></dl>

<p>References <a class="el" href="structassign__s.html#a0e281d17f095584685754c034c24c828">assign_s::M</a>, <a class="el" href="structassign__s.html#a7bff46d146353bd56b15680e94b95eed">assign_s::N</a>, <a class="el" href="structecc__team__goals__s.html#a490e0c75869a74a95c1c01e747a28005">ecc_team_goals_s::nU</a>, <a class="el" href="structassign__s.html#a3b50bf737563fbcfeefa6f3f6332efc2">assign_s::P</a>, <a class="el" href="structassign__s.html#a10beb97c36e4237e232f8fdcb3638f05">assign_s::Pu</a>, and <a class="el" href="structassign__s.html#a8c991751e19640ac66161e12dab26349">assign_s::Q</a>.</p>

</div>
</div>
<a class="anchor" id="ad17160ce9f2717876eb989e3bd810b60"></a><!-- doxytag: member="sc_formation.h::RestrictIDSet" ref="ad17160ce9f2717876eb989e3bd810b60" args="(ml_int_array &amp;relIDs, constraints_t constraints[], int numC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RestrictIDSet </td>
          <td>(</td>
          <td class="paramtype">ml_int_array &amp;&#160;</td>
          <td class="paramname"> <em>relIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structconstraints__s.html">constraints_t</a>&#160;</td>
          <td class="paramname"> <em>constraints</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">relIDs</td><td>Unique set of relative IDs. There must be no repeated IDs in this list. </td></tr>
    <tr><td class="paramname">constraints</td><td>Array of constraint data structures. Each one contains a list of IDs </td></tr>
    <tr><td class="paramname">numC</td><td>Number of constraint data structures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>relIDs Updated set of relative IDs. </dd>
<dd>
status If relIDs is not unique, the function immediately returns 0. Otherwise, it returns 1. </dd></dl>

<p>References <a class="el" href="structconstraints__s.html#ae02a521669b816eb4ceea491110e28be">constraints_s::nRestrict</a>.</p>

</div>
</div>
<a class="anchor" id="a1e74029b97a3d04254f9d44c9ceb121a"></a><!-- doxytag: member="sc_formation.h::VerifyAssignmentParams" ref="a1e74029b97a3d04254f9d44c9ceb121a" args="(assign_t a, const ml_matrix &amp;f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VerifyAssignmentParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structassign__s.html">assign_t</a>&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Assignment parameters structure </td></tr>
    <tr><td class="paramname">f</td><td>Cost matrix, with N columns for N satellites </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>status 0 if all parameters consistent, negative integer for error -1 Cost matrix does not have N columns -2 P is greater than N -3 Pu is greater than P -4 Q is not positive -5 Phase vector "phi" is not the right length -6 Index vector "u" is not the right length -7 One or more elements of "u" is greater than P -8 One or more elements of "u" is not positive </dd></dl>

<p>References <a class="el" href="structassign__s.html#a7bff46d146353bd56b15680e94b95eed">assign_s::N</a>, <a class="el" href="structassign__s.html#a3b50bf737563fbcfeefa6f3f6332efc2">assign_s::P</a>, <a class="el" href="structassign__s.html#a1bfcd63806f793eb0042f005896e3268">assign_s::phi</a>, <a class="el" href="structassign__s.html#a10beb97c36e4237e232f8fdcb3638f05">assign_s::Pu</a>, <a class="el" href="structassign__s.html#a8c991751e19640ac66161e12dab26349">assign_s::Q</a>, and <a class="el" href="structassign__s.html#ad380cf6fe6fb4610fd4cb9c544f906e5">assign_s::u</a>.</p>

</div>
</div>
<a class="anchor" id="a52c4bcfb6e87b41a2606c65e1780fcc6"></a><!-- doxytag: member="sc_formation.h::PrivilegedAssignment" ref="a52c4bcfb6e87b41a2606c65e1780fcc6" args="(assign_t assign, const ml_matrix &amp;f, int method, ml_int_array &amp;optOrder, ml_matrix &amp;optPhi, double &amp;optCost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PrivilegedAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structassign__s.html">assign_t</a>&#160;</td>
          <td class="paramname"> <em>assign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_int_array &amp;&#160;</td>
          <td class="paramname"> <em>optOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>optPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>optCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">assign</td><td>Assignment parameters, dictated by the team goals. </td></tr>
    <tr><td class="paramname">f</td><td>Cost matrix, with N columns for N satellites </td></tr>
    <tr><td class="paramname">method</td><td>Indicates whether to use the minimum cost (1) or the average cost (not 1) as the cost metric. </td></tr>
    <tr><td class="paramname">optOrder</td><td>The order in which the target states should be assigned to each satellite. Passed by reference. </td></tr>
    <tr><td class="paramname">optPhi</td><td>The corresponding phase angles associated with each target. Passed by reference. </td></tr>
    <tr><td class="paramname">optCost</td><td>The total cost to achieve all target states. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>errorFlag Returns 0 if algorithm runs nominally. Returns a negative integer if an error is found with the supplied assignment structure. </dd></dl>

<p>References <a class="el" href="structassign__s.html#a7bff46d146353bd56b15680e94b95eed">assign_s::N</a>, <a class="el" href="structassign__s.html#a3b50bf737563fbcfeefa6f3f6332efc2">assign_s::P</a>, <a class="el" href="structassign__s.html#a1bfcd63806f793eb0042f005896e3268">assign_s::phi</a>, <a class="el" href="structassign__s.html#a8c991751e19640ac66161e12dab26349">assign_s::Q</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, and <a class="el" href="structassign__s.html#ad380cf6fe6fb4610fd4cb9c544f906e5">assign_s::u</a>.</p>

</div>
</div>
<a class="anchor" id="a98a303c88974196ee0e215a7bb164138"></a><!-- doxytag: member="sc_formation.h::OptimalAssignment" ref="a98a303c88974196ee0e215a7bb164138" args="(assign_t assign, ml_matrix f, ml_int_array &amp;optOrder, ml_matrix &amp;optPhi, double &amp;optCost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OptimalAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structassign__s.html">assign_t</a>&#160;</td>
          <td class="paramname"> <em>assign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_int_array &amp;&#160;</td>
          <td class="paramname"> <em>optOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>optPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>optCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">assign</td><td>Assignment parameters data structure </td></tr>
    <tr><td class="paramname">f</td><td>Set of weighted cost vectors </td></tr>
    <tr><td class="paramname">optOrder</td><td>Optimal order of the target states. Passed by reference. </td></tr>
    <tr><td class="paramname">optPhi</td><td>Optimal phases for variable states. Passed by reference. </td></tr>
    <tr><td class="paramname">optCost</td><td>Total cost to achieve the optimal configuration. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>status Indicates status of assignment parameters, &lt;0 if poorly defined, 0 if okay. </dd></dl>

<p>References <a class="el" href="structassign__s.html#a7bff46d146353bd56b15680e94b95eed">assign_s::N</a>, <a class="el" href="structassign__s.html#a3b50bf737563fbcfeefa6f3f6332efc2">assign_s::P</a>, <a class="el" href="structassign__s.html#a1bfcd63806f793eb0042f005896e3268">assign_s::phi</a>, <a class="el" href="structassign__s.html#a10beb97c36e4237e232f8fdcb3638f05">assign_s::Pu</a>, <a class="el" href="structassign__s.html#a8c991751e19640ac66161e12dab26349">assign_s::Q</a>, <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>, and <a class="el" href="structassign__s.html#ad380cf6fe6fb4610fd4cb9c544f906e5">assign_s::u</a>.</p>

</div>
</div>
<a class="anchor" id="a411a8c05331985be3c45211f792b0fdb"></a><!-- doxytag: member="sc_formation.h::EquallyPhased" ref="a411a8c05331985be3c45211f792b0fdb" args="(const ml_matrix &amp;phi, ml_int_array u, int Pu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool EquallyPhased </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_int_array&#160;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>Pu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine if the phase angles are equally phased.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Phase angle array </td></tr>
    <tr><td class="paramname">u</td><td>Unique variable indices </td></tr>
    <tr><td class="paramname">Pu</td><td>Number of unique variable states </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the variable states are equally phased </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, and <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="ad276ce09ff58f8f7dd05327ee7774069"></a><!-- doxytag: member="sc_formation.h::FindMinSet" ref="ad276ce09ff58f8f7dd05327ee7774069" args="(ml_matrix &amp;mat, double &amp;minSum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_int_array FindMinSet </td>
          <td>(</td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>minSum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix of costs. Passed by reference. </td></tr>
    <tr><td class="paramname">minSum</td><td>Minimum sum solution. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Array of matrix columns for optimal assignment. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c903c68b432e7aca90c57e477070ddd"></a><!-- doxytag: member="sc_formation.h::permute" ref="a9c903c68b432e7aca90c57e477070ddd" args="(ml_int_array arr, int start, int num, const ml_matrix &amp;mat, double &amp;cost, ml_int_array &amp;best)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void permute </td>
          <td>(</td>
          <td class="paramtype">ml_int_array&#160;</td>
          <td class="paramname"> <em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_int_array &amp;&#160;</td>
          <td class="paramname"> <em>best</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Array to be permuted </td></tr>
    <tr><td class="paramname">num</td><td>Number of remaining rows to permute. </td></tr>
    <tr><td class="paramname">start</td><td>Starting row for current permutation. </td></tr>
    <tr><td class="paramname">mat</td><td>Matrix of costs. Passed by reference. </td></tr>
    <tr><td class="paramname">cost</td><td>Current cost. </td></tr>
    <tr><td class="paramname">best</td><td>Best cost thus far. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa165b9de82bf050ded6dd53352dd799c"></a><!-- doxytag: member="sc_formation.h::LPCircular" ref="aa165b9de82bf050ded6dd53352dd799c" args="(const ml_matrix &amp;x0, const ml_matrix &amp;xF, double n, double duration, double dT, unsigned short constraintType, double maxConstraint, ml_matrix &amp;aC, ml_matrix &amp;t, bool &amp;exitFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPCircular </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"> <em>constraintType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>maxConstraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>aC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>exitFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the thrust trajectory to go from an initial state to a final state in Hills frame. For circular orbits.</p>
<p>For circular orbits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>Initial state in Hill's frame </td></tr>
    <tr><td class="paramname">xF</td><td>Final state in Hill's frame </td></tr>
    <tr><td class="paramname">n</td><td>Reference orbit rate (rad/sec) </td></tr>
    <tr><td class="paramname">duration</td><td>Maneuver duration (secs) </td></tr>
    <tr><td class="paramname">dT</td><td>Thruster time step </td></tr>
    <tr><td class="paramname">constraintType</td><td>Flag [0: Equality; 1: Inequality constraint] </td></tr>
    <tr><td class="paramname">maxConstraint</td><td>Maximum constraint on u </td></tr>
    <tr><td class="paramname">aC</td><td>Commanded acceleration in Hill's frame </td></tr>
    <tr><td class="paramname">t</td><td>Time vector (secs) </td></tr>
    <tr><td class="paramname">exitFlag</td><td>Flag [0: No feasible solution; 1: Feasible solution] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ead824efc9428da0cb1e8023b5fd761"></a><!-- doxytag: member="sc_formation.h::LPEccentric" ref="a5ead824efc9428da0cb1e8023b5fd761" args="(double e, double n, const ml_matrix &amp;x0, const ml_matrix &amp;xF, double nu0, double nuF, int nS, ml_matrix cW, unsigned short constraintType, double maxConstraint, ml_matrix &amp;aC, ml_matrix &amp;t, bool &amp;exitFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPEccentric </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nuF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>cW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"> <em>constraintType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>maxConstraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>aC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>exitFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the thrust trajectory to go from an initial state to a final state in Hills frame. For eccentric orbits.</p>
<p>For eccentric orbits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Orbit eccentricity </td></tr>
    <tr><td class="paramname">n</td><td>Mean orbit rate (rad/sec) </td></tr>
    <tr><td class="paramname">x0</td><td>Initial state in Hill's frame </td></tr>
    <tr><td class="paramname">xF</td><td>Final state in Hill's frame </td></tr>
    <tr><td class="paramname">nu0</td><td>Initial true anomaly (rad) </td></tr>
    <tr><td class="paramname">nuF</td><td>Final true anomaly (rad) </td></tr>
    <tr><td class="paramname">nS</td><td>Number of samples to use for control vector </td></tr>
    <tr><td class="paramname">cW</td><td>Cost weighting vector </td></tr>
    <tr><td class="paramname">constraintType</td><td>Flag [0: Equality; 1: Inequality constraint] </td></tr>
    <tr><td class="paramname">maxConstraint</td><td>Maximum constraint on u </td></tr>
    <tr><td class="paramname">aC</td><td>Commanded acceleration in Hill's frame. Passed by reference. </td></tr>
    <tr><td class="paramname">t</td><td>Time vector (secs). Passed by reference. </td></tr>
    <tr><td class="paramname">exitFlag</td><td>Flag [0: No feasible solution; 1: Feasible solution]. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab961861643ad0f1186069723a18f1c79"></a><!-- doxytag: member="sc_formation.h::LPCircularTimeWeight" ref="ab961861643ad0f1186069723a18f1c79" args="(orb_data_t el0, const ml_matrix &amp;xH0, geom_t goals, window_t window, int nSPO, ml_matrix &amp;xHF, double &amp;nOrbMvr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPCircularTimeWeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwindow__s.html">window_t</a>&#160;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nSPO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xHF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>nOrbMvr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine the target state on the desired trajectory that gives the minimum time-weighted cost. For circular orbits.</p>
<p>For circular orbits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Initial orbital element set [a,i,W,w,e,M] </td></tr>
    <tr><td class="paramname">xH0</td><td>Initial state in Hill's frame </td></tr>
    <tr><td class="paramname">goals</td><td>Geometric goals data structure </td></tr>
    <tr><td class="paramname">window</td><td>Maneuver time window data structure, containing:</p>
<ul>
<li>nOrbMin Minimum number of orbits</li>
<li>nOrbMax Maximum number of orbits</li>
<li>nManeuvers Number of maneuvers to search over</li>
<li>timeWeightExp Time-weighting exponent </li>
</ul>
</td></tr>
    <tr><td class="paramname">nSPO</td><td>Number of samples to use for control vector (per orbit of maneuver duration) </td></tr>
    <tr><td class="paramname">xHF</td><td>Target Hills-frame state (at maneuver completion). Passed by reference. </td></tr>
    <tr><td class="paramname">nOrbMvr</td><td>Chosen maneuver duration (in orbits). Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, <a class="el" href="structwindow__s.html#ae329e76ebc8f0866d66a24a42c4bd9f2">window_s::timeWeightExp</a>, <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>, and <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="a081c2fc0a578a90371d8a6199f4d16bb"></a><!-- doxytag: member="sc_formation.h::LPEccentricTimeWeight" ref="a081c2fc0a578a90371d8a6199f4d16bb" args="(orb_data_t el0, const ml_matrix &amp;xH0, ecc_geom_t goals, window_t window, int nSPO, ml_matrix &amp;xHF, double &amp;nOrbMvr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPEccentricTimeWeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwindow__s.html">window_t</a>&#160;</td>
          <td class="paramname"> <em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nSPO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xHF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>nOrbMvr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine the target state on the desired trajectory that gives the minimum time-weighted cost. For eccentric orbits.</p>
<p>For eccentric orbits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Initial orbital element set [a,i,W,w,e,M] </td></tr>
    <tr><td class="paramname">xH0</td><td>Initial state in Hill's frame </td></tr>
    <tr><td class="paramname">goals</td><td>Geometric goals data structure </td></tr>
    <tr><td class="paramname">window</td><td>Maneuver time window data structure, containing: </td></tr>
    <tr><td class="paramname">nSPO</td><td>Number of samples to use for control vector (per orbit of maneuver duration) </td></tr>
    <tr><td class="paramname">xHF</td><td>Target Hills-frame state (at maneuver completion). Passed by reference. </td></tr>
    <tr><td class="paramname">nOrbMvr</td><td>Chosen maneuver duration (in orbits). Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, and <a class="el" href="structwindow__s.html#ae329e76ebc8f0866d66a24a42c4bd9f2">window_s::timeWeightExp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e9942b93f740ad8ed4097e477eb531a"></a><!-- doxytag: member="sc_formation.h::GVEErrorDynamics" ref="a2e9942b93f740ad8ed4097e477eb531a" args="(orb_data_t el0, ml_matrix &amp;A, ml_matrix &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GVEErrorDynamics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Standard orbital elements </td></tr>
    <tr><td class="paramname">A</td><td>State dynamics. Passed by reference. </td></tr>
    <tr><td class="paramname">B</td><td>Input effect matrix. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#aca78dbce742ffcd14bec44f404628e3b">orb_data_s::inc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, and <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>.</p>

</div>
</div>
<a class="anchor" id="a6911a76749b442360db753dd12d365c0"></a><!-- doxytag: member="sc_formation.h::LPEccentricGVE" ref="a6911a76749b442360db753dd12d365c0" args="(orb_data_t el0, const ml_matrix &amp;x0, const ml_matrix &amp;xF, double MF, int nS, ml_matrix cW, unsigned short constraintType, double maxConstraint, ml_matrix &amp;aC, ml_matrix &amp;t, bool &amp;exitFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPEccentricGVE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>MF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>cW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"> <em>constraintType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>maxConstraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>aC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"> <em>exitFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the thrust trajectory to go from an initial state to a final state in Hills frame. For eccentric orbits.</p>
<p>For eccentric orbits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Initial orbital elements </td></tr>
    <tr><td class="paramname">x0</td><td>Initial state in Hill's frame </td></tr>
    <tr><td class="paramname">xF</td><td>Final state in Hill's frame </td></tr>
    <tr><td class="paramname">MF</td><td>Final mean anomaly (rad) </td></tr>
    <tr><td class="paramname">nS</td><td>Number of samples to use for control vector </td></tr>
    <tr><td class="paramname">cW</td><td>Cost weighting vector </td></tr>
    <tr><td class="paramname">constraintType</td><td>Flag [0: Equality; 1: Inequality constraint] </td></tr>
    <tr><td class="paramname">maxConstraint</td><td>Maximum constraint on u </td></tr>
    <tr><td class="paramname">aC</td><td>Commanded acceleration in Hill's frame. Passed by reference. </td></tr>
    <tr><td class="paramname">t</td><td>Time vector (secs). Passed by reference. </td></tr>
    <tr><td class="paramname">exitFlag</td><td>Flag [0: No feasible solution; 1: Feasible solution]. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, and <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>.</p>

</div>
</div>
<a class="anchor" id="a6ef69c05f45e459118ff0778cffadf51"></a><!-- doxytag: member="sc_formation.h::FFEccLinOrb" ref="a6ef69c05f45e459118ff0778cffadf51" args="(double n, double nu, double e, ml_matrix &amp;a, ml_matrix &amp;b, double dT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FFEccLinOrb </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the continous A,B matrices for linearized relative motion in an eccentric reference orbit, discretized with a zero-order hold with timestep dT. *sctlib (overload LinOrb)</p>
<p>*sctlib (overload LinOrb) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Mean orbit rate [rad/s] </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">a</td><td>Plant matrix. Passed by reference. </td></tr>
    <tr><td class="paramname">b</td><td>Input matrix. Passed by reference. </td></tr>
    <tr><td class="paramname">dT</td><td>Time-step for discretization </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad01a98f5ad95b7ca287ce5f2a242a150"></a><!-- doxytag: member="sc_formation.h::FFEccLinOrb" ref="ad01a98f5ad95b7ca287ce5f2a242a150" args="(const ml_matrix &amp;x, const ml_matrix &amp;acc, double n, double nu, double e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccLinOrb </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the right-hand-side for linearized relative motion in an eccentric reference orbit.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>State vector </td></tr>
    <tr><td class="paramname">acc</td><td>Acceleration vector </td></tr>
    <tr><td class="paramname">n</td><td>Mean orbit rate [rad/s] </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xDot </dd></dl>

</div>
</div>
<a class="anchor" id="a4e1657c150786b80e441832f4d662064"></a><!-- doxytag: member="sc_formation.h::FFEccProp" ref="a4e1657c150786b80e441832f4d662064" args="(const ml_matrix &amp;D, const ml_matrix &amp;nu, double e, double dH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccProp </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant found by setting H = 0 at nu0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH Hills frame state computed at nu </dd></dl>

</div>
</div>
<a class="anchor" id="ac2368592676604a20b02d9372dab8c13"></a><!-- doxytag: member="sc_formation.h::FFEccProp" ref="ac2368592676604a20b02d9372dab8c13" args="(const ml_matrix &amp;D, double nu, double e, double dH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccProp </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant found by setting H = 0 at nu0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH Hills frame state computed at nu </dd></dl>

</div>
</div>
<a class="anchor" id="a62ff4add984cc2d3aa0e0c8fc3f631af"></a><!-- doxytag: member="sc_formation.h::FFEccDH" ref="a62ff4add984cc2d3aa0e0c8fc3f631af" args="(double nu0, double e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FFEccDH </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute integration constant dH for homogeneous solution to LTV differential equations of relative orbit motion. Found by setting H=0 at initial true anomaly.</p>
<p>Found by setting H=0 at initial true anomaly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nu0</td><td>True Anomaly (at initial state) [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dH Integration constant found by setting H = 0 at nu0 </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="adf11e013a2d7bad6cbf3d9bf5fa71074"></a><!-- doxytag: member="sc_formation.h::FFEccGoals" ref="adf11e013a2d7bad6cbf3d9bf5fa71074" args="(double e, ecc_geom_t goals, ml_matrix &amp;D, ml_matrix &amp;xH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FFEccGoals </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">goals</td><td>Eccentric geometric goals </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s. Passed by reference. </td></tr>
    <tr><td class="paramname">xH</td><td>Hills frame state at nu = 0. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structecc__geom__s.html#a398f35f6155784ec5f781f0f66dc4eea">ecc_geom_s::nu_xMax</a>, <a class="el" href="structecc__geom__s.html#a4100fce06537099120e1b1d6e24043c5">ecc_geom_s::nu_zMax</a>, <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, <a class="el" href="structecc__geom__s.html#a1aaa582416e17189a9fc5a93813f11f2">ecc_geom_s::xMax</a>, <a class="el" href="structecc__geom__s.html#a3d8183a44331649433736f42373959c2">ecc_geom_s::y0</a>, and <a class="el" href="structecc__geom__s.html#aafe2063745a1f38342af826046f1c309">ecc_geom_s::zMax</a>.</p>

</div>
</div>
<a class="anchor" id="abcff535d1c9e30fc1e6e5d7d9d532214"></a><!-- doxytag: member="sc_formation.h::FFEccGoals" ref="abcff535d1c9e30fc1e6e5d7d9d532214" args="(double e, ecc_geom_xy_t goals, ml_matrix &amp;D, ml_matrix &amp;xH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FFEccGoals </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__geom__xy__s.html">ecc_geom_xy_t</a>&#160;</td>
          <td class="paramname"> <em>goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">goals</td><td>Eccentric geometric goals (xy) </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s. Passed by reference. </td></tr>
    <tr><td class="paramname">xH</td><td>Hills frame state at nu = 0. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structecc__geom__xy__s.html#a33da68d4e2ad9ff954d79abb7478b6de">ecc_geom_xy_s::nu_xy</a>, <a class="el" href="structecc__geom__xy__s.html#a4031c8b518aae57404ba68f17f05f6db">ecc_geom_xy_s::nu_zMax</a>, <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, <a class="el" href="structecc__geom__xy__s.html#a25e867b82a46593378c0299ae3d465fe">ecc_geom_xy_s::x</a>, <a class="el" href="structecc__geom__xy__s.html#a5e11810e03d8304f99bbd37bc3333b1c">ecc_geom_xy_s::y</a>, <a class="el" href="structecc__geom__xy__s.html#a13d9b9dfe6ca0fa2b9830431cb34cdd0">ecc_geom_xy_s::y0</a>, and <a class="el" href="structecc__geom__xy__s.html#a4ba598cb63616fd7322680b958d94eda">ecc_geom_xy_s::zMax</a>.</p>

</div>
</div>
<a class="anchor" id="a9e0f1b7836dedc9f4343368d344e94e6"></a><!-- doxytag: member="sc_formation.h::FFEccIntConst" ref="a9e0f1b7836dedc9f4343368d344e94e6" args="(const ml_matrix &amp;xH0, double nu0, double e, ml_matrix &amp;D, double &amp;dH, ml_matrix &amp;R)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FFEccIntConst </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>dH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xH0</td><td>Initial state in Hills frame </td></tr>
    <tr><td class="paramname">nu0</td><td>True anomaly (at initial state) [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">D</td><td>Vector of integration constants. Passed by reference. </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant found by setting H = 0 at nu0. Passed by reference. </td></tr>
    <tr><td class="paramname">R</td><td>State transition matrix. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1d0e51664a6b8b09737414836db87ef"></a><!-- doxytag: member="sc_formation.h::FFEccRMat" ref="af1d0e51664a6b8b09737414836db87ef" args="(double nu, double e, double dH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccRMat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>True Anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant found by setting H = 0 at nu0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>matrix Transformation matrix for equation xH = R*D </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="af029a5969ec9790f27aeb038df6e0032"></a><!-- doxytag: member="sc_formation.h::FFEccRMat" ref="af029a5969ec9790f27aeb038df6e0032" args="(double nu, double e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccRMat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the state-transition matrix, R, given the eccentricity and true anomaly so that xH = R*D, where D is the vector of integration constants found from initial conditions. Here, the integration constant "dH" is computed using the first element of the "nu" matrix.</p>
<p>Here, the integration constant "dH" is computed using the first element of the "nu" matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>True Anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>matrix Transformation matrix for equation xH = R*D </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="a75faeb0429eab7512b6e5e2458d2a618"></a><!-- doxytag: member="sc_formation.h::FFEccXExt" ref="a75faeb0429eab7512b6e5e2458d2a618" args="(double e, const ml_matrix &amp;D, double dH, double epsilon, int nMax, ml_matrix &amp;x, ml_matrix &amp;nu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FFEccXExt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant found by setting H = 0 at nu0 </td></tr>
    <tr><td class="paramname">epsilon</td><td>Angular tolerance [rad] </td></tr>
    <tr><td class="paramname">nMax</td><td>Maximum number of iterations </td></tr>
    <tr><td class="paramname">x</td><td>Extreme values of radial oscillations [km]. Passed by reference. </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly where extreme values occur [rad]. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="af00eb88837a7f890c75064dff5974fd8"></a><!-- doxytag: member="sc_formation.h::FFEccYExt" ref="af00eb88837a7f890c75064dff5974fd8" args="(double e, const ml_matrix &amp;D, double dH, double epsilon, int nMax, ml_matrix &amp;y, ml_matrix &amp;nu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FFEccYExt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant found by setting H = 0 at nu0 </td></tr>
    <tr><td class="paramname">epsilon</td><td>Angular tolerance [rad] </td></tr>
    <tr><td class="paramname">nMax</td><td>Maximum number of iterations </td></tr>
    <tr><td class="paramname">y</td><td>Extreme values of along-track offsets [km]. Passed by reference. </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly where extreme along-track offsets occur [rad]. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="af96777fa5393feabf332a79ac9e0be4f"></a><!-- doxytag: member="sc_formation.h::FFEccZExt" ref="af96777fa5393feabf332a79ac9e0be4f" args="(double e, const ml_matrix &amp;D, double dH, double epsilon, int nMax, ml_matrix &amp;z, ml_matrix &amp;nu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FFEccZExt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>nMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant found by setting H = 0 at nu0 </td></tr>
    <tr><td class="paramname">epsilon</td><td>Angular tolerance [rad] </td></tr>
    <tr><td class="paramname">nMax</td><td>Maximum number of iterations </td></tr>
    <tr><td class="paramname">z</td><td>Extreme values of cross track amplitude [km]. Passed by reference. </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly where extreme amplitudes occur [rad]. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="a7030e5a861767b0c64dd84d30b2a5b0d"></a><!-- doxytag: member="sc_formation.h::NuDot" ref="a7030e5a861767b0c64dd84d30b2a5b0d" args="(double n, double e, double nu, double &amp;nuDot, double &amp;nuDotDot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NuDot </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>nuDot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>nuDotDot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the time-derivative of the true anomaly. *sctlib.</p>
<p>*sctlib </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Mean orbit rate [rad/s] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">nu</td><td>True Anomaly [rad] </td></tr>
    <tr><td class="paramname">nuDot</td><td>Time derivative of true anomaly [rad/s]. Passed by reference. </td></tr>
    <tr><td class="paramname">nuDotDot</td><td>Second time derivative of true anomaly [rad/s]. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace303f8cb6c83adceea58471e1301632"></a><!-- doxytag: member="sc_formation.h::FFEccDX" ref="ace303f8cb6c83adceea58471e1301632" args="(double nu, double e, const ml_matrix &amp;D, double dH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FFEccDX </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant computed from H(nu0)=0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dx First derivative of x with respect to true anomaly </dd></dl>

</div>
</div>
<a class="anchor" id="a1ff4dcf0b6ddc66d39ce412db326a94c"></a><!-- doxytag: member="sc_formation.h::FFEccDY" ref="a1ff4dcf0b6ddc66d39ce412db326a94c" args="(double nu, double e, const ml_matrix &amp;D, double dH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FFEccDY </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant computed from H(nu0)=0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dy First derivative of y with respect to true anomaly </dd></dl>

</div>
</div>
<a class="anchor" id="aebd1bb2c9142a87119b3d7d22e3510fd"></a><!-- doxytag: member="sc_formation.h::FFEccDZ" ref="aebd1bb2c9142a87119b3d7d22e3510fd" args="(double nu, double e, const ml_matrix &amp;D, double dH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FFEccDZ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant computed from H(nu0)=0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dz First derivative of x with respect to true anomaly </dd></dl>

</div>
</div>
<a class="anchor" id="a163ad7ee5ad0e7b7de525a9ec91723e0"></a><!-- doxytag: member="sc_formation.h::FFEccDDX" ref="a163ad7ee5ad0e7b7de525a9ec91723e0" args="(double nu, double e, const ml_matrix &amp;D, double dH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FFEccDDX </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant computed from H(nu0)=0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ddx Second derivative of x with respect to true anomaly </dd></dl>

</div>
</div>
<a class="anchor" id="a6ea4108936beea376ac35d6baf5aeb2a"></a><!-- doxytag: member="sc_formation.h::FFEccDDY" ref="a6ea4108936beea376ac35d6baf5aeb2a" args="(double nu, double e, const ml_matrix &amp;D, double dH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FFEccDDY </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant computed from H(nu0)=0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ddy Second derivative of y with respect to true anomaly </dd></dl>

</div>
</div>
<a class="anchor" id="af5568bd9358f1b1e3eb193ac9e2456eb"></a><!-- doxytag: member="sc_formation.h::FFEccDDZ" ref="af5568bd9358f1b1e3eb193ac9e2456eb" args="(double nu, double e, const ml_matrix &amp;D, double dH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FFEccDDZ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">D</td><td>Integration constants computed from i.c.'s </td></tr>
    <tr><td class="paramname">dH</td><td>Integration constant computed from H(nu0)=0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ddz Second derivative of z with respect to true anomaly </dd></dl>

</div>
</div>
<a class="anchor" id="ac029bcc162f6ef28aba78fdc9a29a496"></a><!-- doxytag: member="sc_formation.h::Alfriend2El" ref="ac029bcc162f6ef28aba78fdc9a29a496" args="(alf_orb_data_t elA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structorb__data__s.html">orb_data_t</a> Alfriend2El </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>elA</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">elA</td><td>Alfriend orbital elements [a,theta,i,q1,q2,W] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>el Standard orbital elements [a,i,W,w,e,M] </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structorb__data__s.html#aca78dbce742ffcd14bec44f404628e3b">orb_data_s::inc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structorb__data__s.html#aa75fe6236be33bcd092bc1501efff903">orb_data_s::raan</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, <a class="el" href="structorb__data__s.html#ad84e7310f41e43a6bf92e31213e35e18">orb_data_s::true_anom</a>, and <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>.</p>

</div>
</div>
<a class="anchor" id="a06eb69feb5e3aa8490cdeaf8b3389d0c"></a><!-- doxytag: member="sc_formation.h::El2Alfriend" ref="a06eb69feb5e3aa8490cdeaf8b3389d0c" args="(orb_data_t el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> El2Alfriend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a standard orbital element set into the Alfriend orbital element set *sctlib.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>Standard orbital elements [a,i,W,w,e,M] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>elA Alfriend orbital elements [a,theta,i,q1,q2,W] </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#aca78dbce742ffcd14bec44f404628e3b">orb_data_s::inc</a>, <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structorb__data__s.html#aa75fe6236be33bcd092bc1501efff903">orb_data_s::raan</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>, and <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="af7386ce835b40bc83f5a834f6f853db7"></a><!-- doxytag: member="sc_formation.h::El2Alfriend" ref="af7386ce835b40bc83f5a834f6f853db7" args="(orb_data_t el, double true_anom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> El2Alfriend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>true_anom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a standard orbital element set into the Alfriend orbital element set *sctlib.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>Standard orbital elements [a,i,W,w,e,M] </td></tr>
    <tr><td class="paramname">true_anom</td><td>True anomaly </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>elA Alfriend orbital elements [a,theta,i,q1,q2,W] </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#aca78dbce742ffcd14bec44f404628e3b">orb_data_s::inc</a>, <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structorb__data__s.html#aa75fe6236be33bcd092bc1501efff903">orb_data_s::raan</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>, and <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="a57482495205fea590003e98e1700ba70"></a><!-- doxytag: member="sc_formation.h::add_elements" ref="a57482495205fea590003e98e1700ba70" args="(alf_orb_data_t el1, alf_orb_data_t el2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_s</a> add_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add two sets of orbital elements *sctlib.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el1</td><td>First element set </td></tr>
    <tr><td class="paramname">el2</td><td>Second element set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>el Sum of two element sets (all angles are wrapped between -PI and +PI) </dd></dl>

<p>References <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, and <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>.</p>

</div>
</div>
<a class="anchor" id="aee211c4c69d77f2daf6db4dc54f20871"></a><!-- doxytag: member="sc_formation.h::add_elements" ref="aee211c4c69d77f2daf6db4dc54f20871" args="(orb_data_t el1, orb_data_t el2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structorb__data__s.html">orb_data_s</a> add_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add two sets of orbital elements *sctlib.</p>
<p>epoch and orb_rate are not set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el1</td><td>First element set </td></tr>
    <tr><td class="paramname">el2</td><td>Second element set </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>el Sum of two element sets (all angles are wrapped between -PI and +PI) </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#aca78dbce742ffcd14bec44f404628e3b">orb_data_s::inc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structorb__data__s.html#aa75fe6236be33bcd092bc1501efff903">orb_data_s::raan</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, and <a class="el" href="structorb__data__s.html#ad84e7310f41e43a6bf92e31213e35e18">orb_data_s::true_anom</a>.</p>

</div>
</div>
<a class="anchor" id="ab23f9e3835efcc79ad4a5f32657df282"></a><!-- doxytag: member="sc_formation.h::sub_elements" ref="ab23f9e3835efcc79ad4a5f32657df282" args="(alf_orb_data_t el1, alf_orb_data_t el2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_s</a> sub_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el1</td><td>First element set </td></tr>
    <tr><td class="paramname">el2</td><td>Second element set, subtracted from first </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>el Difference of two element sets (all angles are wrapped between -PI and +PI) </dd></dl>

<p>References <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, and <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>.</p>

</div>
</div>
<a class="anchor" id="a475a2c55e89f2406b0d3fdbb0cea5065"></a><!-- doxytag: member="sc_formation.h::sub_elements" ref="a475a2c55e89f2406b0d3fdbb0cea5065" args="(orb_data_t el1, orb_data_t el2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structorb__data__s.html">orb_data_s</a> sub_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>epoch and orb_rate are not set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el1</td><td>First element set </td></tr>
    <tr><td class="paramname">el2</td><td>Second element set, subtracted from first </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>el Difference of two element sets (all angles are wrapped between -PI and +PI) </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#aca78dbce742ffcd14bec44f404628e3b">orb_data_s::inc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structorb__data__s.html#aa75fe6236be33bcd092bc1501efff903">orb_data_s::raan</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, and <a class="el" href="structorb__data__s.html#ad84e7310f41e43a6bf92e31213e35e18">orb_data_s::true_anom</a>.</p>

</div>
</div>
<a class="anchor" id="ae519a81dfda96292fb3731b43d607931"></a><!-- doxytag: member="sc_formation.h::CirclePhase" ref="ae519a81dfda96292fb3731b43d607931" args="(double beta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CirclePhase </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>beta</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the desired phase on a circle from the desired phase on the ellipse. The circle is superscribed about the ellipse.</p>
<p>The circle is superscribed about the ellipse. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>Phase angle measured on ellipse [rad] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>alpha Phase angle measured on superscribed circle [rad] </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="a29f78590c86bcdb8aef3a1788fcf0d09"></a><!-- doxytag: member="sc_formation.h::EllipsePhase" ref="a29f78590c86bcdb8aef3a1788fcf0d09" args="(double alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double EllipsePhase </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>alpha</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the desired phase on an ellipse from the desired phase on the circle. The circle is superscribed about the ellipse.</p>
<p>The circle is superscribed about the ellipse. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Phase angle measured on superscribed circle [rad] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>beta Phase angle measured on ellipse </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="a485faa11ebfca7d63747281d1a893236"></a><!-- doxytag: member="sc_formation.h::OrbElemDiff" ref="a485faa11ebfca7d63747281d1a893236" args="(alf_orb_data_t el0, alf_orb_data_t el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> OrbElemDiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Reference orbital elements (Alfriend format) </td></tr>
    <tr><td class="paramname">el</td><td>Secondary orbital elements (Alfriend format) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dEl Orbital element difference </dd></dl>

<p>References <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, and <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>.</p>

</div>
</div>
<a class="anchor" id="a9f4f410ad833b1fb9de80e97f1ec3a05"></a><!-- doxytag: member="sc_formation.h::OrbElemDiff" ref="a9f4f410ad833b1fb9de80e97f1ec3a05" args="(orb_data_t el0, orb_data_t el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structorb__data__s.html">orb_data_t</a> OrbElemDiff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>epoch and orb_rate are not set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Reference orbital elements (standard format) </td></tr>
    <tr><td class="paramname">el</td><td>Secondary orbital elements (standard format) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dEl Orbital element difference </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#aca78dbce742ffcd14bec44f404628e3b">orb_data_s::inc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structorb__data__s.html#aa75fe6236be33bcd092bc1501efff903">orb_data_s::raan</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, and <a class="el" href="structorb__data__s.html#ad84e7310f41e43a6bf92e31213e35e18">orb_data_s::true_anom</a>.</p>

</div>
</div>
<a class="anchor" id="aa2b4abf5c66ab1aa8059fca9ffe50853"></a><!-- doxytag: member="sc_formation.h::Goals2DeltaElem" ref="aa2b4abf5c66ab1aa8059fca9ffe50853" args="(alf_orb_data_t el0, geom_t goals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> Goals2DeltaElem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Measured orbital elements (Alfriend format) </td></tr>
    <tr><td class="paramname">goals</td><td>Geometric goals data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>alf_orb_data_t Desired orbital element differences </dd></dl>

</div>
</div>
<a class="anchor" id="ae8162926b5ec625c56a90f1391c7f3d0"></a><!-- doxytag: member="sc_formation.h::DeltaElem2Goals" ref="ae8162926b5ec625c56a90f1391c7f3d0" args="(alf_orb_data_t el0, alf_orb_data_t dEl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgeom__s.html">geom_t</a> DeltaElem2Goals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>dEl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Measured orbital elements (Alfriend format) [a,theta,i,q1,q2,W] </td></tr>
    <tr><td class="paramname">dEl</td><td>Desired orbital element differences </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>goals Geometric goals </dd></dl>

</div>
</div>
<a class="anchor" id="a5ca4b5a1b39f869dfbf1178c95dea5be"></a><!-- doxytag: member="sc_formation.h::DeltaElem2Hills" ref="a5ca4b5a1b39f869dfbf1178c95dea5be" args="(alf_orb_data_t elA, alf_orb_data_t dEl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix DeltaElem2Hills </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>elA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>dEl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">elA</td><td>Reference orbital elements [Alfriend format] </td></tr>
    <tr><td class="paramname">dEl</td><td>Orbital element difference </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH Hills frame position and velocity </dd></dl>

<p>References <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="sc__constants_8h.html#a671dcd512fb29ca4ef7fa99998fb2088">MU_EARTH</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, and <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>.</p>

</div>
</div>
<a class="anchor" id="a6ff4bbae07d407ca9977e9336f0dbbb4"></a><!-- doxytag: member="sc_formation.h::Hills2DeltaElem" ref="a6ff4bbae07d407ca9977e9336f0dbbb4" args="(alf_orb_data_t el0, const ml_matrix &amp;xH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_s</a> Hills2DeltaElem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Chief orbital elements in alfriend format </td></tr>
    <tr><td class="paramname">xH</td><td>Relative position and velocity in Hills frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>alf_orb_data Orbital element difference in alfriend format </dd></dl>

<p>References <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="sc__constants_8h.html#a671dcd512fb29ca4ef7fa99998fb2088">MU_EARTH</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="sc__constants_8h.html#ad6ced367857b130153df275020ee6785">RADIUS_EARTH</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, and <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>.</p>

</div>
</div>
<a class="anchor" id="a2e26b2c9b2e1dde172982705a67ccd78"></a><!-- doxytag: member="sc_formation.h::Hills2Goals" ref="a2e26b2c9b2e1dde172982705a67ccd78" args="(alf_orb_data_t el0, const ml_matrix &amp;xH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgeom__s.html">geom_s</a> Hills2Goals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Reference orbital elements </td></tr>
    <tr><td class="paramname">xH</td><td>Relative state in Hills frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>goals Geometric goals </dd></dl>

<p>References <a class="el" href="structgeom__s.html#adbab6299d3a80e8b379109f27090a53e">geom_s::aE</a>, <a class="el" href="structgeom__s.html#a9e8abc825a605849d01aa190ccf31912">geom_s::beta</a>, <a class="el" href="sc__constants_8h.html#a671dcd512fb29ca4ef7fa99998fb2088">MU_EARTH</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>, <a class="el" href="structgeom__s.html#a77ae63a3565f10d54abb66f795c59fed">geom_s::y0</a>, <a class="el" href="structgeom__s.html#ab27c76d41aabc8d362636f7e9be1cc16">geom_s::zInc</a>, and <a class="el" href="structgeom__s.html#a65ef88a8b5f6de3bb8616e8d87611e2c">geom_s::zLan</a>.</p>

</div>
</div>
<a class="anchor" id="aa8ef9602cb80c49bc50d8de0eb22ba94"></a><!-- doxytag: member="sc_formation.h::Goals2Hills" ref="aa8ef9602cb80c49bc50d8de0eb22ba94" args="(alf_orb_data_t el0, geom_t goals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix Goals2Hills </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Reference orbital elements </td></tr>
    <tr><td class="paramname">goals</td><td>Geometric goals </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH Relative state in Hills frame </dd></dl>

<p>References <a class="el" href="structgeom__s.html#adbab6299d3a80e8b379109f27090a53e">geom_s::aE</a>, <a class="el" href="structgeom__s.html#a9e8abc825a605849d01aa190ccf31912">geom_s::beta</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>, <a class="el" href="structgeom__s.html#a77ae63a3565f10d54abb66f795c59fed">geom_s::y0</a>, <a class="el" href="structgeom__s.html#ab27c76d41aabc8d362636f7e9be1cc16">geom_s::zInc</a>, and <a class="el" href="structgeom__s.html#a65ef88a8b5f6de3bb8616e8d87611e2c">geom_s::zLan</a>.</p>

</div>
</div>
<a class="anchor" id="af0cbc0cbba25da28734a8495e4edd905"></a><!-- doxytag: member="sc_formation.h::FFEccHills2DeltaElem" ref="af0cbc0cbba25da28734a8495e4edd905" args="(orb_data_t el0, const ml_matrix &amp;xH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structorb__data__s.html">orb_data_s</a> FFEccHills2DeltaElem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>[standard format] </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Reference orbital elements </td></tr>
    <tr><td class="paramname">xH</td><td>Relative position and velocity in Hills frame [km, km/s] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dEl Orbital element differences </dd></dl>

</div>
</div>
<a class="anchor" id="aabc32e5518972b7a946dced3e16897ff"></a><!-- doxytag: member="sc_formation.h::FFEccHills2DeltaElem" ref="aabc32e5518972b7a946dced3e16897ff" args="(alf_orb_data_t el0, const ml_matrix &amp;xH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_s</a> FFEccHills2DeltaElem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>[alfriend format] </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Reference orbital elements </td></tr>
    <tr><td class="paramname">xH</td><td>Relative position and velocity in Hills frame [km, km/s] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dEl Orbital element differences </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#ad84e7310f41e43a6bf92e31213e35e18">orb_data_s::true_anom</a>.</p>

</div>
</div>
<a class="anchor" id="aa27ce5873c82f32850e87fa1055a56be"></a><!-- doxytag: member="sc_formation.h::FFEccDeltaElem2Hills" ref="aa27ce5873c82f32850e87fa1055a56be" args="(alf_orb_data_t el0, alf_orb_data_t dEl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccDeltaElem2Hills </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>dEl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Reference orbital elements [Alfriend format] </td></tr>
    <tr><td class="paramname">dEl</td><td>Orbit element differences </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH Relative state in Hills frame </dd></dl>

</div>
</div>
<a class="anchor" id="ae5fb4ac3b55ddb8363123f4902e2c3c0"></a><!-- doxytag: member="sc_formation.h::FFEccDeltaElem2Goals" ref="ae5fb4ac3b55ddb8363123f4902e2c3c0" args="(alf_orb_data_t el0, alf_orb_data_t dEl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a> FFEccDeltaElem2Goals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>dEl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el0</td><td>Orbital elements [Alfriend format] </td></tr>
    <tr><td class="paramname">dEl</td><td>Orbital element differences </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>goals Eccentric geometric data structure </dd></dl>

<p>References <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, and <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>.</p>

</div>
</div>
<a class="anchor" id="a5c8af9ea03481cbf6d589eaa40e296fc"></a><!-- doxytag: member="sc_formation.h::FFEccGoals2Hills" ref="a5c8af9ea03481cbf6d589eaa40e296fc" args="(double e, double nu, ecc_geom_t g, double n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccGoals2Hills </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">g</td><td>Data structure of geometric goals </td></tr>
    <tr><td class="paramname">n</td><td>Mean orbit rate [rad/s] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH Hills frame state </dd></dl>

</div>
</div>
<a class="anchor" id="af457b46906d8d73604d153f92fe35712"></a><!-- doxytag: member="sc_formation.h::FFEccGoals2Hills" ref="af457b46906d8d73604d153f92fe35712" args="(double e, double nu, ecc_geom_xy_t g, double n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccGoals2Hills </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__geom__xy__s.html">ecc_geom_xy_t</a>&#160;</td>
          <td class="paramname"> <em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">g</td><td>Data structure of geometric goals </td></tr>
    <tr><td class="paramname">n</td><td>Mean orbit rate [rad/s] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH Hills frame state </dd></dl>

</div>
</div>
<a class="anchor" id="ab439a030d850ec9c3322191c3cbd3a15"></a><!-- doxytag: member="sc_formation.h::FFEccGoals2Hills" ref="ab439a030d850ec9c3322191c3cbd3a15" args="(double e, double nu, ecc_geom_t g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccGoals2Hills </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td>
          <td class="paramname"> <em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">g</td><td>Data structure of geometric goals </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH Hills frame state </dd></dl>

</div>
</div>
<a class="anchor" id="ab0cc4b1a81146ebc7cfa942136a43a56"></a><!-- doxytag: member="sc_formation.h::FFEccHills2Goals" ref="ab0cc4b1a81146ebc7cfa942136a43a56" args="(double e, double nu, ml_matrix xH, double n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a> FFEccHills2Goals </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>xH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">xH</td><td>Hills frame state </td></tr>
    <tr><td class="paramname">n</td><td>Mean orbit rate [rad/s] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>g Data structure of geometric goals </dd></dl>

<p>References <a class="el" href="structecc__geom__s.html#a398f35f6155784ec5f781f0f66dc4eea">ecc_geom_s::nu_xMax</a>, <a class="el" href="structecc__geom__s.html#a4100fce06537099120e1b1d6e24043c5">ecc_geom_s::nu_zMax</a>, <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, <a class="el" href="structecc__geom__s.html#a1aaa582416e17189a9fc5a93813f11f2">ecc_geom_s::xMax</a>, <a class="el" href="structecc__geom__s.html#a3d8183a44331649433736f42373959c2">ecc_geom_s::y0</a>, and <a class="el" href="structecc__geom__s.html#aafe2063745a1f38342af826046f1c309">ecc_geom_s::zMax</a>.</p>

</div>
</div>
<a class="anchor" id="afc07affc19e45b20d0924d3649c12cf8"></a><!-- doxytag: member="sc_formation.h::FFEccHills2Goals" ref="afc07affc19e45b20d0924d3649c12cf8" args="(double e, double nu, const ml_matrix &amp;xH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a> FFEccHills2Goals </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">xH</td><td>Hills frame state </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>g Data structure of geometric goals </dd></dl>

<p>References <a class="el" href="structecc__geom__s.html#a398f35f6155784ec5f781f0f66dc4eea">ecc_geom_s::nu_xMax</a>, <a class="el" href="structecc__geom__s.html#a4100fce06537099120e1b1d6e24043c5">ecc_geom_s::nu_zMax</a>, <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, <a class="el" href="structecc__geom__s.html#a1aaa582416e17189a9fc5a93813f11f2">ecc_geom_s::xMax</a>, <a class="el" href="structecc__geom__s.html#a3d8183a44331649433736f42373959c2">ecc_geom_s::y0</a>, and <a class="el" href="structecc__geom__s.html#aafe2063745a1f38342af826046f1c309">ecc_geom_s::zMax</a>.</p>

</div>
</div>
<a class="anchor" id="a3dd68e9224032941b4f12c12ef11f169"></a><!-- doxytag: member="sc_formation.h::Nu2TimeDomain" ref="a3dd68e9224032941b4f12c12ef11f169" args="(ml_matrix &amp;x, double n, double e, double nu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Nu2TimeDomain </td>
          <td>(</td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Relative State in nu-domain. Passed by reference. </td></tr>
    <tr><td class="paramname">n</td><td>Mean orbit rate [rad/s] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2a6dd2eec7f5c203035040dc6ce733a"></a><!-- doxytag: member="sc_formation.h::Time2NuDomain" ref="ad2a6dd2eec7f5c203035040dc6ce733a" args="(ml_matrix &amp;x, double n, double e, double nu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Time2NuDomain </td>
          <td>(</td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Relative State in time-domain </td></tr>
    <tr><td class="paramname">n</td><td>Mean orbit rate [rad/s] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly [rad] </td></tr>
    <tr><td class="paramname">x</td><td>Relative State in nu-domain. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9dd8a7da4eab83519601473daa0e66c"></a><!-- doxytag: member="sc_formation.h::GeometryCirc2Ecc" ref="ad9dd8a7da4eab83519601473daa0e66c" args="(double w, geom_t gCirc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a> GeometryCirc2Ecc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td>
          <td class="paramname"> <em>gCirc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Argument of perigee [rad] </td></tr>
    <tr><td class="paramname">gCirc</td><td>Geometry goals structure for circular orbits </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>gEcc Geometry goals structure for Eccentric orbits </dd></dl>

<p>References <a class="el" href="structgeom__s.html#adbab6299d3a80e8b379109f27090a53e">geom_s::aE</a>, <a class="el" href="structgeom__s.html#a9e8abc825a605849d01aa190ccf31912">geom_s::beta</a>, <a class="el" href="structecc__geom__s.html#a398f35f6155784ec5f781f0f66dc4eea">ecc_geom_s::nu_xMax</a>, <a class="el" href="structecc__geom__s.html#a4100fce06537099120e1b1d6e24043c5">ecc_geom_s::nu_zMax</a>, <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, <a class="el" href="structecc__geom__s.html#a1aaa582416e17189a9fc5a93813f11f2">ecc_geom_s::xMax</a>, <a class="el" href="structgeom__s.html#a77ae63a3565f10d54abb66f795c59fed">geom_s::y0</a>, <a class="el" href="structecc__geom__s.html#a3d8183a44331649433736f42373959c2">ecc_geom_s::y0</a>, <a class="el" href="structgeom__s.html#ab27c76d41aabc8d362636f7e9be1cc16">geom_s::zInc</a>, <a class="el" href="structgeom__s.html#a65ef88a8b5f6de3bb8616e8d87611e2c">geom_s::zLan</a>, and <a class="el" href="structecc__geom__s.html#aafe2063745a1f38342af826046f1c309">ecc_geom_s::zMax</a>.</p>

</div>
</div>
<a class="anchor" id="a7f61891744974fcef7be2c91ac0d6784"></a><!-- doxytag: member="sc_formation.h::GeometryEcc2Circ" ref="a7f61891744974fcef7be2c91ac0d6784" args="(double w, ecc_geom_t gEcc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgeom__s.html">geom_t</a> GeometryEcc2Circ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structecc__geom__s.html">ecc_geom_t</a>&#160;</td>
          <td class="paramname"> <em>gEcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Argument of perigee [rad] </td></tr>
    <tr><td class="paramname">gEcc</td><td>Geometry goals structure for Eccentric orbits </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>gCirc Geometry goals structure for Circular orbits </dd></dl>

<p>References <a class="el" href="structgeom__s.html#adbab6299d3a80e8b379109f27090a53e">geom_s::aE</a>, <a class="el" href="structgeom__s.html#a9e8abc825a605849d01aa190ccf31912">geom_s::beta</a>, <a class="el" href="structecc__geom__s.html#a398f35f6155784ec5f781f0f66dc4eea">ecc_geom_s::nu_xMax</a>, <a class="el" href="structecc__geom__s.html#a4100fce06537099120e1b1d6e24043c5">ecc_geom_s::nu_zMax</a>, <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, <a class="el" href="structecc__geom__s.html#a1aaa582416e17189a9fc5a93813f11f2">ecc_geom_s::xMax</a>, <a class="el" href="structecc__geom__s.html#a3d8183a44331649433736f42373959c2">ecc_geom_s::y0</a>, <a class="el" href="structgeom__s.html#a77ae63a3565f10d54abb66f795c59fed">geom_s::y0</a>, <a class="el" href="structgeom__s.html#ab27c76d41aabc8d362636f7e9be1cc16">geom_s::zInc</a>, <a class="el" href="structgeom__s.html#a65ef88a8b5f6de3bb8616e8d87611e2c">geom_s::zLan</a>, and <a class="el" href="structecc__geom__s.html#aafe2063745a1f38342af826046f1c309">ecc_geom_s::zMax</a>.</p>

</div>
</div>
<a class="anchor" id="ad62bd4537ef6531f493c38ef6f8dd9c2"></a><!-- doxytag: member="sc_formation.h::RotateState" ref="ad62bd4537ef6531f493c38ef6f8dd9c2" args="(geom_t goals, double phi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgeom__s.html">geom_t</a> RotateState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgeom__s.html">geom_t</a>&#160;</td>
          <td class="paramname"> <em>goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">goals</td><td>Geometric goals data structure </td></tr>
    <tr><td class="paramname">phi</td><td>Circular phase angle </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>goals New geometric data structure rotated to phi </dd></dl>

<p>References <a class="el" href="structgeom__s.html#a9e8abc825a605849d01aa190ccf31912">geom_s::beta</a>, <a class="el" href="structgeom__s.html#ab27c76d41aabc8d362636f7e9be1cc16">geom_s::zInc</a>, and <a class="el" href="structgeom__s.html#a65ef88a8b5f6de3bb8616e8d87611e2c">geom_s::zLan</a>.</p>

</div>
</div>
<a class="anchor" id="aea7fb7cd659e41e1ad86cd6776e3641d"></a><!-- doxytag: member="sc_formation.h::MeanAnom2TrueLat" ref="aea7fb7cd659e41e1ad86cd6776e3641d" args="(double e, double w, double M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MeanAnom2TrueLat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert mean anomlay to true latitude.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">w</td><td>Argument of Perigee [rad] </td></tr>
    <tr><td class="paramname">M</td><td>Mean Anomaly [rad] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>theta True Latitude [rad] </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="aaf6aa7f06996f687a4435386d275d323"></a><!-- doxytag: member="sc_formation.h::GetHillsMats" ref="aaf6aa7f06996f687a4435386d275d323" args="(const ml_matrix &amp;r0, const ml_matrix &amp;v0, ml_matrix &amp;A, ml_matrix &amp;Adot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GetHillsMats </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>Adot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r0</td><td>Position, ECI frame </td></tr>
    <tr><td class="paramname">v0</td><td>Velocity, ECI frame </td></tr>
    <tr><td class="paramname">A</td><td>Rotation Matrix (position). Passed by reference. </td></tr>
    <tr><td class="paramname">Adot</td><td>Rotation Matrix (velocity). Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="sc__constants_8h.html#a671dcd512fb29ca4ef7fa99998fb2088">MU_EARTH</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, and <a class="el" href="structorb__data__s.html#ad84e7310f41e43a6bf92e31213e35e18">orb_data_s::true_anom</a>.</p>

</div>
</div>
<a class="anchor" id="ab9d76e85be1767f1af1b3ac42737d0a7"></a><!-- doxytag: member="sc_formation.h::AbsRelECI2Hills" ref="ab9d76e85be1767f1af1b3ac42737d0a7" args="(ml_matrix r0, ml_matrix v0, ml_matrix dr, ml_matrix dv, ml_matrix &amp;rH, ml_matrix &amp;vH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbsRelECI2Hills </td>
          <td>(</td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>dr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>rH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>vH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r0</td><td>Reference position in ECI frame </td></tr>
    <tr><td class="paramname">v0</td><td>Reference velocity in ECI frame </td></tr>
    <tr><td class="paramname">dr</td><td>Relative position in ECI frame </td></tr>
    <tr><td class="paramname">dv</td><td>Relative velocity in ECI frame </td></tr>
    <tr><td class="paramname">rH</td><td>Curvilinear Hills frame position [dR; r1*dTheta; dZ ]. Passed by reference. </td></tr>
    <tr><td class="paramname">vH</td><td>Curvilinear Hills frame velocity [dRDot; r1*dThetaDot + r1Dot*dTheta; dZDot]. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52608ce1578fb0afa42dcc232d489d46"></a><!-- doxytag: member="sc_formation.h::Osc2Mean" ref="a52608ce1578fb0afa42dcc232d489d46" args="(alf_orb_data_t el, double J2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> Osc2Mean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>J2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>Osculating orbital elements </td></tr>
    <tr><td class="paramname">J2</td><td>J2 perturbation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>el Mean orbital elements </dd></dl>

<p>References <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="sc__constants_8h.html#ad6ced367857b130153df275020ee6785">RADIUS_EARTH</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, and <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>.</p>

</div>
</div>
<a class="anchor" id="a05ddff0f7463567683125614b02628a5"></a><!-- doxytag: member="sc_formation.h::ECI2MeanElements" ref="a05ddff0f7463567683125614b02628a5" args="(const ml_matrix &amp;xRefECI, const ml_matrix &amp;xRelECI, double J2, alf_orb_data_t &amp;elRefMean)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a>* ECI2MeanElements </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xRefECI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xRelECI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>J2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structalf__orb__data__s.html">alf_orb_data_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>elRefMean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xRefECI</td><td>Reference position &amp; velocity in ECI frame </td></tr>
    <tr><td class="paramname">xRelECI</td><td>Relative positions &amp; velocities in ECI frame </td></tr>
    <tr><td class="paramname">J2</td><td>Size of J2 perturbation </td></tr>
    <tr><td class="paramname">elRefMean</td><td>Mean orbital elements of the reference orbit. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dElMean Mean orbital element differences </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#ad84e7310f41e43a6bf92e31213e35e18">orb_data_s::true_anom</a>.</p>

</div>
</div>
<a class="anchor" id="a2dcb66087cfc6b7acc2b30c685c06ac9"></a><!-- doxytag: member="sc_formation.h::AlignThruster" ref="a2dcb66087cfc6b7acc2b30c685c06ac9" args="(const ml_matrix &amp;aH, const ml_matrix &amp;bTh, ml_matrix &amp;qHB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AlignThruster </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>aH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>bTh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>qHB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes desired Hills-to-body quaternion for a thruster firing. Rotation about thruster-axis is ignored.</p>
<p>Rotation about thruster-axis is ignored. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aH</td><td>Unit Hills frame vector of applied acceleration </td></tr>
    <tr><td class="paramname">bTh</td><td>Unit body vector of Hall Effect Thruster nozzle </td></tr>
    <tr><td class="paramname">qHB</td><td>Desired ECI-to-body quaternion. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always returns true. Output provided for compatibility with other AlignThruster function. </dd></dl>

</div>
</div>
<a class="anchor" id="a23de1c7d74b468ac67be46087f8de531"></a><!-- doxytag: member="sc_formation.h::AlignThruster" ref="a23de1c7d74b468ac67be46087f8de531" args="(const ml_matrix &amp;aH, const ml_matrix &amp;bTh, const ml_matrix &amp;bST, const ml_matrix &amp;r, const ml_matrix &amp;v, double jD, double sep, ml_matrix &amp;qHB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AlignThruster </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>aH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>bTh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>bST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>jD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>qHB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aH</td><td>Unit Hills frame vector of applied acceleration </td></tr>
    <tr><td class="paramname">bTh</td><td>Unit body vector of Hall Effect Thruster nozzle </td></tr>
    <tr><td class="paramname">bST</td><td>Unit body vector of star tracker bore-sight </td></tr>
    <tr><td class="paramname">r</td><td>Position in ECI at burn time [km] </td></tr>
    <tr><td class="paramname">v</td><td>Velocity in ECI at burn time [km/s] </td></tr>
    <tr><td class="paramname">jD</td><td>Julian Date of burn time [JD] </td></tr>
    <tr><td class="paramname">sep</td><td>Required angular separation between bore-sight and bright body horizon [rad] </td></tr>
    <tr><td class="paramname">qHB</td><td>Desired ECI-to-body quaternion. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Flag indicating whether angular separation constraint is satisfied for all: sun, Earth, and moon </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="aaa80f05cfcadacc8e4bdfe0cbbc371b7"></a><!-- doxytag: member="sc_formation.h::Hills2Frenet" ref="aaa80f05cfcadacc8e4bdfe0cbbc371b7" args="(const ml_matrix &amp;xH, const double &amp;e, const double &amp;nu, const double &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix Hills2Frenet </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"> <em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transforms from the Hills frame to the Frenet frame.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xH</td><td>(6,1) Relative position and velocity in Hills-frame </td></tr>
    <tr><td class="paramname">e</td><td>(1,1) Orbit eccentricity </td></tr>
    <tr><td class="paramname">nu</td><td>(1,1) True anomaly (rad) </td></tr>
    <tr><td class="paramname">n</td><td>(1,1) Mean orbit rate (rad/s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xF (6,1) Relative position and velocity in Frenet-frame </dd></dl>

</div>
</div>
<a class="anchor" id="a113d0887a185af1d98d5c7c3083af728"></a><!-- doxytag: member="sc_formation.h::HillsEqns" ref="a113d0887a185af1d98d5c7c3083af728" args="(const ml_matrix &amp;xH0, double n, double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix HillsEqns </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closed form solution of relative orbital motion using Hills equations. For circular orbits only.</p>
<p>For circular orbits only. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xH0</td><td>Initial state in Hills frame </td></tr>
    <tr><td class="paramname">n</td><td>Orbital Rate (rad/s) </td></tr>
    <tr><td class="paramname">t</td><td>Time (sec) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>X State </dd></dl>

</div>
</div>
<a class="anchor" id="ad3e1547c50125821e91ee4b0cc06a226"></a><!-- doxytag: member="sc_formation.h::FFEccHillsEqns" ref="ad3e1547c50125821e91ee4b0cc06a226" args="(ml_matrix xH0, double nu0, const ml_matrix &amp;nu, double e, double n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccHillsEqns </td>
          <td>(</td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>xH0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute Hills frame state (in time-domain) at future true anomaly(s). For eccentric or circular orbits.</p>
<p>For eccentric or circular orbits </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xH0</td><td>Initial Hills frame state </td></tr>
    <tr><td class="paramname">nu0</td><td>True anomaly (at initial state) [rad] </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly (at new state) [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">n</td><td>Mean orbit rate [rad/s] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH New Hills frame state at nu (with nu-derivatives) </dd></dl>

</div>
</div>
<a class="anchor" id="a17d76c90f5d0f67d7fe572a1bec83b7d"></a><!-- doxytag: member="sc_formation.h::FFEccHillsEqns" ref="a17d76c90f5d0f67d7fe572a1bec83b7d" args="(const ml_matrix &amp;xH0, double nu0, const ml_matrix &amp;nu, double e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccHillsEqns </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute Hills frame state (in nu-domain) at future true anomaly(s). For eccentric or circular orbits.</p>
<p>For eccentric or circular orbits </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">xH0</td><td>Initial Hills frame state </td></tr>
    <tr><td class="paramname">nu0</td><td>True anomaly (at initial state) [rad] </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly (at new state) [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH New Hills frame state at nu (with nu-derivatives) </dd></dl>

</div>
</div>
<a class="anchor" id="ae29b964554c262131987077a7df69ef8"></a><!-- doxytag: member="sc_formation.h::DiscreteHills" ref="ae29b964554c262131987077a7df69ef8" args="(const ml_matrix &amp;x0, double n, const ml_matrix &amp;aC, double dT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix DiscreteHills </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>aC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the force relative trajectory from the initial state and time-history of applied accelerations. For circular orbits only.</p>
<p>For circular orbits only. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>Initial state </td></tr>
    <tr><td class="paramname">n</td><td>Reference orbit rate (rad/sec) </td></tr>
    <tr><td class="paramname">aC</td><td>Commanded accelerations </td></tr>
    <tr><td class="paramname">dT</td><td>Thruster sampling time </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xS State trajectory </dd></dl>

</div>
</div>
<a class="anchor" id="ae50102b6e2dd5ec0b0c1145d45d5632a"></a><!-- doxytag: member="sc_formation.h::FFEccDiscreteHills" ref="ae50102b6e2dd5ec0b0c1145d45d5632a" args="(double e, double n, const ml_matrix &amp;x0, double nu0, const ml_matrix &amp;aC, const ml_matrix &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix FFEccDiscreteHills </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>aC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the force relative trajectory from the initial state and time-history of applied accelerations. For circular orbits only.</p>
<p>For circular orbits only. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">n</td><td>Mean orbit rate (rad/sec) </td></tr>
    <tr><td class="paramname">x0</td><td>Initial relative state </td></tr>
    <tr><td class="paramname">nu0</td><td>Initial true anomaly </td></tr>
    <tr><td class="paramname">aC</td><td>Commanded accelerations </td></tr>
    <tr><td class="paramname">t</td><td>Time vector (final time corresponds to final state) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xS Discrete Hills state </dd></dl>

</div>
</div>
<a class="anchor" id="a1b85fd2da3460e7794679940cdb08157"></a><!-- doxytag: member="sc_formation.h::CollProbSet" ref="a1b85fd2da3460e7794679940cdb08157" args="(double sigma, const ml_matrix &amp;S, const ml_matrix &amp;xc, const ml_matrix &amp;Ssc, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CollProbSet </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>Ssc0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Collision probability calculation using sets of ellipsoids.</p>
<p>The units of the inputs should all be consistent, for example km and km2. Only the position of the ellipsoid shold be input. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sigma</td><td>Standard deviations of input ellipsoid, ex. 1.0 or 2.0 </td></tr>
    <tr><td class="paramname">S</td><td>Ellipsoid matrix, 3x3, [length2] </td></tr>
    <tr><td class="paramname">xc</td><td>Ellipsoid center, 3x1, [length] </td></tr>
    <tr><td class="paramname">Ssc0</td><td>Hard-body ellipsoid for single spacecraft [length2] </td></tr>
    <tr><td class="paramname">n</td><td>Number of shells in computation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>prob Probability of a collision </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="a73346e35edc9d53d4e0adbee560e6c19"></a><!-- doxytag: member="sc_formation.h::MonitoringAlg" ref="a73346e35edc9d53d4e0adbee560e6c19" args="(ml_matrix &amp;y, ml_matrix &amp;t, ml_matrix &amp;M, ml_matrix &amp;nu, ml_matrix &amp;accel, ml_matrix &amp;aDiff, coll_mon_data_t d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix MonitoringAlg </td>
          <td>(</td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>accel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>aDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcoll__mon__data__s.html">coll_mon_data_s</a>&#160;</td>
          <td class="paramname"> <em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Collision monitoring algorithm implementation used for both modes, monitoring and surveying.</p>
<p>Requires an acceleration matrix for each relative spacecraft, which will be zero for monitoring. The differential accelerations aDiff may not be zero or else the data output will be corrupted. Currently only the first element of aDiff is used to scale Q assuming that it is a worst-case representation. The function GenerateTimeVector can be used to create t, M, and nu given the total time window. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Relative state, 6xm </td></tr>
    <tr><td class="paramname">t</td><td>Time vector (sec), 1xn </td></tr>
    <tr><td class="paramname">M</td><td>Mean anomaly, 1xn </td></tr>
    <tr><td class="paramname">nu</td><td>True anomaly, 1xn </td></tr>
    <tr><td class="paramname">accel</td><td>Stacked relative accleration vectors, 3mxn </td></tr>
    <tr><td class="paramname">aDiff</td><td>Differential accelerations, 3x1 </td></tr>
    <tr><td class="paramname">d</td><td>Collision monitoring data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Probability, mxn </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structcoll__mon__data__s.html#a2a5b88d1f832930281b2da177ce254cf">coll_mon_data_s::el_ref</a>, <a class="el" href="structalf__orb__data__s.html#a12908fa6ecaddd84d69c4cf5e52adbc7">alf_orb_data_s::inc</a>, <a class="el" href="structcoll__mon__data__s.html#a1ae2dd56fc945e7a6e8b1023e6bb864f">coll_mon_data_s::lenSC</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="structcoll__mon__data__s.html#a824f0e1ab8dc3a7dcaeca15188d97f56">coll_mon_data_s::nPts</a>, <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>, <a class="el" href="structcoll__mon__data__s.html#ad252fc5b315171c0f9f5d1cdb40dbff0">coll_mon_data_s::Pmin</a>, <a class="el" href="structalf__orb__data__s.html#a31ee42e8d8d656719c9a897f3a2dae01">alf_orb_data_s::q1</a>, <a class="el" href="structalf__orb__data__s.html#abfabc3e4621ee1f2b4e622dc65244932">alf_orb_data_s::q2</a>, <a class="el" href="structalf__orb__data__s.html#ab5efc64599a61c7391964922a094b893">alf_orb_data_s::raan</a>, <a class="el" href="structcoll__mon__data__s.html#af530108e86b0c6f2d12c32c8312e60e2">coll_mon_data_s::S0</a>, <a class="el" href="structcoll__mon__data__s.html#a943bbe94fd4ab5a848cfeb697fda7745">coll_mon_data_s::sigma</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, <a class="el" href="structalf__orb__data__s.html#a18339299dced50a59a620067b901e177">alf_orb_data_s::sma</a>, <a class="el" href="structcoll__mon__data__s.html#a9cd6877deaaebf90d2bd6c1d1fcc047e">coll_mon_data_s::Ssc</a>, and <a class="el" href="structalf__orb__data__s.html#a30ed51f5018e0469771615e23bbf3c45">alf_orb_data_s::true_lat</a>.</p>

</div>
</div>
<a class="anchor" id="a44af0a6d9034450fa2c3332cf0cc7614"></a><!-- doxytag: member="sc_formation.h::CollisionSurvey" ref="a44af0a6d9034450fa2c3332cf0cc7614" args="(ml_matrix &amp;y, double t0, maneuver_t mvr1, maneuver_t mvr2[], int n_points, coll_mon_data_s d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix CollisionSurvey </td>
          <td>(</td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmaneuver__s.html">maneuver_t</a>&#160;</td>
          <td class="paramname"> <em>mvr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmaneuver__s.html">maneuver_t</a>&#160;</td>
          <td class="paramname"> <em>mvr2</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>n_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcoll__mon__data__s.html">coll_mon_data_s</a>&#160;</td>
          <td class="paramname"> <em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Relative state (6,n). Passed by reference. </td></tr>
    <tr><td class="paramname">t0</td><td>Current time (MET) </td></tr>
    <tr><td class="paramname">mvr1</td><td>Maneuver data structure for self </td></tr>
    <tr><td class="paramname">mvr2</td><td>Maneuver structure array for relative spacecraft, must be [n] </td></tr>
    <tr><td class="paramname">n_points</td><td>Number of points for time vector </td></tr>
    <tr><td class="paramname">d</td><td>Collision monitor data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Probability matrix, one row per relative </dd></dl>

<p>References <a class="el" href="structcoll__mon__data__s.html#a2a5b88d1f832930281b2da177ce254cf">coll_mon_data_s::el_ref</a>, <a class="el" href="structmaneuver__s.html#addbeae89d2eb15e2528f17937647f919">maneuver_s::nBurns</a>, and <a class="el" href="structmaneuver__s.html#abeafa7fa5859039c6720f23ff5e262ca">maneuver_s::tF</a>.</p>

</div>
</div>
<a class="anchor" id="adf5caccba55c9d373562ef82893034d7"></a><!-- doxytag: member="sc_formation.h::DeltaElem2HillsMat" ref="adf5caccba55c9d373562ef82893034d7" args="(const ml_matrix &amp;elA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix DeltaElem2HillsMat </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>elA</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute transformation matrix from delta elements to Hills.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">elA</td><td>Reference orbital elements [Alfriend format] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>m Transformation matrix </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a671dcd512fb29ca4ef7fa99998fb2088">MU_EARTH</a>.</p>

</div>
</div>
<a class="anchor" id="abe169cee43dffe3de13a2c269f9fdfc4"></a><!-- doxytag: member="sc_formation.h::DeltaEl2AlfriendMat" ref="abe169cee43dffe3de13a2c269f9fdfc4" args="(orb_data_t el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix DeltaEl2AlfriendMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>el</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute transformation matrix from standard differential elements to Alfriend differential elements.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">el</td><td>Reference orbit data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>T Transformation matrix </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, and <a class="el" href="structorb__data__s.html#a415cae6f0641b6baf75301139ed646a6">orb_data_s::perigee</a>.</p>

</div>
</div>
<a class="anchor" id="a8ad27dc7f035f9254f39364c3e012ca8"></a><!-- doxytag: member="sc_formation.h::distant_pt_ell" ref="a8ad27dc7f035f9254f39364c3e012ca8" args="(const ml_matrix &amp;S, const ml_matrix &amp;U, const ml_matrix &amp;xc, const ml_matrix &amp;x0, ml_matrix &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double distant_pt_ell </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute minimum distance from a distance point to an ellipsoid's surface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>Singular value matrix of ellipsoid (3,3) </td></tr>
    <tr><td class="paramname">U</td><td>Rotation matrix of ellipsoid (3,3) </td></tr>
    <tr><td class="paramname">xc</td><td>Center of ellipsoid (3,1) </td></tr>
    <tr><td class="paramname">x0</td><td>Outside point (3D) (3,1) </td></tr>
    <tr><td class="paramname">x</td><td>Point on the ellipsoid (3,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Distance </dd></dl>

</div>
</div>
<a class="anchor" id="ad7d9b77c90526541327fc731ebad00b6"></a><!-- doxytag: member="sc_formation.h::Laguerre" ref="ad7d9b77c90526541327fc731ebad00b6" args="(const ml_matrix &amp;a, double x_guess)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Laguerre </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>x_guess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Laguerre root finding algorithm adapted to real roots.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Vector containing the coefficients of the polynomial, a[i] x^i </td></tr>
    <tr><td class="paramname">x_guess</td><td>Initial guess for the root </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Root </dd></dl>

</div>
</div>
<a class="anchor" id="aec672562e3bbe14ed91c73ceb717ccc3"></a><!-- doxytag: member="sc_formation.h::GenerateTimeVector" ref="aec672562e3bbe14ed91c73ceb717ccc3" args="(orb_data_t d, const double tF, const int nPts, ml_matrix &amp;M, ml_matrix &amp;nu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix GenerateTimeVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structorb__data__s.html">orb_data_t</a>&#160;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"> <em>tF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"> <em>nPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Also returns the corresponding mean and true anomaly vectors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Orbit elements data </td></tr>
    <tr><td class="paramname">tF</td><td>Final time </td></tr>
    <tr><td class="paramname">nPts</td><td>Number of points per orbit </td></tr>
    <tr><td class="paramname">M</td><td>Matrix for returning mean anomaly vector </td></tr>
    <tr><td class="paramname">nu</td><td>Matrix for returning true anomaly vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Time vector </dd></dl>

<p>References <a class="el" href="structorb__data__s.html#aa22f43b21e288ecc6dd9064fe1cfa71c">orb_data_s::ecc</a>, <a class="el" href="structorb__data__s.html#a800633dc1459d6ad1cea07e807799af4">orb_data_s::mean_anom</a>, <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, <a class="el" href="structorb__data__s.html#a505f10ac1834d3e71a5957bae288ae62">orb_data_s::sma</a>, and <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="a6c2c06571dc741c8f5d5ea99829cec08"></a><!-- doxytag: member="sc_formation.h::ManeuverStruct2AccelVector" ref="a6c2c06571dc741c8f5d5ea99829cec08" args="(maneuver_t mvr, const ml_matrix &amp;tProp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix ManeuverStruct2AccelVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaneuver__s.html">maneuver_t</a>&#160;</td>
          <td class="paramname"> <em>mvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>tProp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute a 3xN acceleration vector from a maneuver data structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mvr</td><td>Maneuver data structure, containing an array of burn data structures </td></tr>
    <tr><td class="paramname">tProp</td><td>Time history to use for acceleration vector [sec] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>aC 3xN acceleration matrix [km/s/s] </dd></dl>

<p>References <a class="el" href="structmaneuver__s.html#a41a2958b6682ce07df65a74401ee7d47">maneuver_s::burnData</a>, <a class="el" href="structburn__s.html#a3dd38fed38426c459c1d64f491571fce">burn_s::dT</a>, <a class="el" href="structburn__s.html#a732ba2516c2a463b63cd2eacb3b37162">burn_s::dV</a>, <a class="el" href="structmaneuver__s.html#addbeae89d2eb15e2528f17937647f919">maneuver_s::nBurns</a>, <a class="el" href="structburn__s.html#ad75a1ccd786c12d8c7ff246b22b6b0ff">burn_s::t</a>, <a class="el" href="structburn__s.html#ac1cecd41ced16122540106b43a451db6">burn_s::uX</a>, <a class="el" href="structburn__s.html#a222019ec604c14b1351f2662d69d8806">burn_s::uY</a>, and <a class="el" href="structburn__s.html#a671c7bd4e478d7b52cfb036b63c80aaf">burn_s::uZ</a>.</p>

</div>
</div>
<a class="anchor" id="ab36ab3e7e5a968d0643ed0846eb2516d"></a><!-- doxytag: member="sc_formation.h::TeamLevels" ref="ab36ab3e7e5a968d0643ed0846eb2516d" args="(team_t teams[], int num, ml_int_array &amp;levels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TeamLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteam__s.html">team_t</a>&#160;</td>
          <td class="paramname"> <em>teams</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_int_array &amp;&#160;</td>
          <td class="paramname"> <em>levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">teams</td><td>Array of team data structures. </td></tr>
    <tr><td class="paramname">num</td><td>Number of team data structures. </td></tr>
    <tr><td class="paramname">levels</td><td>Array of team hierarchical team levels. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>circular Flag indicating whether the supplied team organization is circular (true) or not (false). </dd></dl>

</div>
</div>
<a class="anchor" id="a6a24bd3783b9e7ffb11cf49caef25b05"></a><!-- doxytag: member="sc_formation.h::IsRelative" ref="a6a24bd3783b9e7ffb11cf49caef25b05" args="(int iD, team_t teams[], int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IsRelative </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>iD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteam__s.html">team_t</a>&#160;</td>
          <td class="paramname"> <em>teams</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Determine whether the given satellite ID is a relative of any team.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iD</td><td>Unique integer ID of the satellite being checked. </td></tr>
    <tr><td class="paramname">teams[]</td><td>Array of team data structures. </td></tr>
    <tr><td class="paramname">num</td><td>Number of team data structures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>kTeam Index of the team for which it is a relative (counts from 1). Returns 0 if not a relative. </dd></dl>

<p>References <a class="el" href="structteam__s.html#a03dd135b02704d70f1b68abf80f4831d">team_s::memID</a>.</p>

</div>
</div>
<a class="anchor" id="a7b3ce146c7c14b88e51cefa8d9229ced"></a><!-- doxytag: member="sc_formation.h::FindUpperTeams" ref="a7b3ce146c7c14b88e51cefa8d9229ced" args="(int kBot, team_t teams[], int num, ml_int_array &amp;kUpper)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FindUpperTeams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>kBot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteam__s.html">team_t</a>&#160;</td>
          <td class="paramname"> <em>teams</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_int_array &amp;&#160;</td>
          <td class="paramname"> <em>kUpper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find teams above this one in the hierarchy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">kBot</td><td>Index of team to consider. Find all teams above this one. </td></tr>
    <tr><td class="paramname">teams</td><td>Array of team data structures. </td></tr>
    <tr><td class="paramname">num</td><td>Number of team data structures. </td></tr>
    <tr><td class="paramname">kUpper</td><td>Array of team indices that are above this one in the hierarchy. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>circular Flag indicating whether the supplied team organization is circular (true) or not (false). </dd></dl>

</div>
</div>
<a class="anchor" id="a433ff3d1142ba6cda80abcfd2729fc4b"></a><!-- doxytag: member="sc_formation.h::TimeUntilTheta" ref="a433ff3d1142ba6cda80abcfd2729fc4b" args="(double a, double w, double e, double theta0, double &amp;theta1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TimeUntilTheta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>theta0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>theta1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Semi-major axis [km] </td></tr>
    <tr><td class="paramname">w</td><td>Argument of perigee [rad] </td></tr>
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">theta0</td><td>Initial true latitude [rad] </td></tr>
    <tr><td class="paramname">theta1</td><td>Final true latitude [rad] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dT Elapsed time between initial and final true latitude </dd>
<dd>
theta1 Updated value for final latitude (increased by 2*PI if originally less than initial latitude) </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="acfb0e7fc17aef36aefcf58d3ed20b3c1"></a><!-- doxytag: member="sc_formation.h::AccelVector2ManeuverStruct" ref="acfb0e7fc17aef36aefcf58d3ed20b3c1" args="(const ml_matrix &amp;aC, ml_matrix t, double tRef, double nomAccel, double minSepTime, maneuver_t &amp;mvr, ml_matrix &amp;dV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelVector2ManeuverStruct </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>aC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>tRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nomAccel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>minSepTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmaneuver__s.html">maneuver_t</a> &amp;&#160;</td>
          <td class="paramname"> <em>mvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>dV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">aC</td><td>3xN acceleration matrix. [km/s/s] </td></tr>
    <tr><td class="paramname">t</td><td>Time vector in seconds, starting at 0. </td></tr>
    <tr><td class="paramname">tRef</td><td>Reference time in seconds, [MET]. This is added to the time vector "t" after differencing to avoid numerical rounding errors. </td></tr>
    <tr><td class="paramname">nomAccel</td><td>Nominal acceleration in [km/s]. Each burn is assumed to apply this acceleration. This relates the burn duration to the delta-v magnitude. </td></tr>
    <tr><td class="paramname">minSepTime</td><td>Minimum allowable separation time between end of one burn and beginning of next. Multiple burns closer together than this will be grouped into a single burn. </td></tr>
    <tr><td class="paramname">mvr</td><td>Maneuver data structure with burn info. Passed by reference. </td></tr>
    <tr><td class="paramname">dV</td><td>Non-zero delta-v magnitudes. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structmaneuver__s.html#a41a2958b6682ce07df65a74401ee7d47">maneuver_s::burnData</a>, <a class="el" href="structburn__s.html#a3dd38fed38426c459c1d64f491571fce">burn_s::dT</a>, <a class="el" href="structburn__s.html#a732ba2516c2a463b63cd2eacb3b37162">burn_s::dV</a>, <a class="el" href="sc__formation_8h.html#a175ba4347f1786d726092db8c4954eb2">FF_TOL</a>, <a class="el" href="structmaneuver__s.html#aacfff05d905da791dd23e4bbc33a4bcb">maneuver_s::iD</a>, <a class="el" href="structburn__s.html#a60124cd02a54a246701f2a6f42910acb">burn_s::iD</a>, <a class="el" href="structmaneuver__s.html#addbeae89d2eb15e2528f17937647f919">maneuver_s::nBurns</a>, <a class="el" href="structburn__s.html#ad75a1ccd786c12d8c7ff246b22b6b0ff">burn_s::t</a>, <a class="el" href="structmaneuver__s.html#a61ffefc85c55ad7847276fe1cac28dd2">maneuver_s::t0</a>, <a class="el" href="structmaneuver__s.html#abeafa7fa5859039c6720f23ff5e262ca">maneuver_s::tF</a>, <a class="el" href="structburn__s.html#ac1cecd41ced16122540106b43a451db6">burn_s::uX</a>, <a class="el" href="structburn__s.html#a222019ec604c14b1351f2662d69d8806">burn_s::uY</a>, and <a class="el" href="structburn__s.html#a671c7bd4e478d7b52cfb036b63c80aaf">burn_s::uZ</a>.</p>

</div>
</div>
<a class="anchor" id="a81b318794c86fdb508faf7c8d092f821"></a><!-- doxytag: member="sc_formation.h::ManeuverStruct2AccelVector" ref="a81b318794c86fdb508faf7c8d092f821" args="(maneuver_t mvr, double dT, ml_matrix &amp;aC, ml_matrix &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ManeuverStruct2AccelVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmaneuver__s.html">maneuver_t</a>&#160;</td>
          <td class="paramname"> <em>mvr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>aC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mvr</td><td>Maneuver data structure, containing an array of burn data structures </td></tr>
    <tr><td class="paramname">dT</td><td>Time-step to use in creating the acceleration time-history [sec] </td></tr>
    <tr><td class="paramname">aC</td><td>3xN acceleration matrix [km/s/s]. Passed by reference. </td></tr>
    <tr><td class="paramname">t</td><td>1xN+1 time vector [sec]. Passed by reference. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structmaneuver__s.html#a41a2958b6682ce07df65a74401ee7d47">maneuver_s::burnData</a>, <a class="el" href="structburn__s.html#a3dd38fed38426c459c1d64f491571fce">burn_s::dT</a>, <a class="el" href="structburn__s.html#a732ba2516c2a463b63cd2eacb3b37162">burn_s::dV</a>, <a class="el" href="structmaneuver__s.html#addbeae89d2eb15e2528f17937647f919">maneuver_s::nBurns</a>, <a class="el" href="structburn__s.html#ad75a1ccd786c12d8c7ff246b22b6b0ff">burn_s::t</a>, <a class="el" href="structburn__s.html#ac1cecd41ced16122540106b43a451db6">burn_s::uX</a>, <a class="el" href="structburn__s.html#a222019ec604c14b1351f2662d69d8806">burn_s::uY</a>, and <a class="el" href="structburn__s.html#a671c7bd4e478d7b52cfb036b63c80aaf">burn_s::uZ</a>.</p>

</div>
</div>
<a class="anchor" id="aa222645204b5f7e8667f1832b4c0edba"></a><!-- doxytag: member="sc_formation.h::NOrbVector" ref="aa222645204b5f7e8667f1832b4c0edba" args="(window_t window)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix NOrbVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwindow__s.html">window_t</a>&#160;</td>
          <td class="paramname"> <em>win</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">win</td><td>Time window data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>nOrb Vector of maneuver durations (in orbits) to consider in planning </dd></dl>

<p>References <a class="el" href="structwindow__s.html#a860756c79a4d3e392fbf48bb1de01c01">window_s::nManeuvers</a>, <a class="el" href="structwindow__s.html#a37982aa244a9c36d996c7b085d71eec0">window_s::nOrbMax</a>, and <a class="el" href="structwindow__s.html#a528b04b5c3fdba6aa16747733dc7351b">window_s::nOrbMin</a>.</p>

</div>
</div>
<a class="anchor" id="afdc393a137c52e6b1abca417661bb652"></a><!-- doxytag: member="sc_formation.h::TargetTrueAnom" ref="afdc393a137c52e6b1abca417661bb652" args="(double e, double nu0, ml_matrix nOrb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix TargetTrueAnom </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>nu0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>nOrb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Eccentricity </td></tr>
    <tr><td class="paramname">nu0</td><td>Initial true anomaly [rad] </td></tr>
    <tr><td class="paramname">nOrb</td><td>Number of orbits into the future to evaluate the true anomaly </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>nuF Target true anomay at future times, unwrapped [rad] </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="ac5e3fd35bc1c5d2df3bef7874e4505b6"></a><!-- doxytag: member="sc_formation.h::Tetrahedron" ref="ac5e3fd35bc1c5d2df3bef7874e4505b6" args="(double d, const ml_matrix &amp;eul)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix Tetrahedron </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>eul</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Distance of each side. </td></tr>
    <tr><td class="paramname">eul</td><td>Euler angles for rotating the tetrahedron. [rad] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>p 3x4 matrix containing the [x;y;z]' coordinates of each point. </dd></dl>

</div>
</div>
<a class="anchor" id="a362f1d91de681694cb8f88123fec8735"></a><!-- doxytag: member="sc_formation.h::matout" ref="a362f1d91de681694cb8f88123fec8735" args="(ml_matrix mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* matout </td>
          <td>(</td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>mat</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output a matrix to a string with higher precision than built-in "to_string" function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix to convert to a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>String representation of the matrix in "MATLAB readable" format </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Aug 2 2012 11:11:31 for Spacecraft Control Framework by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
