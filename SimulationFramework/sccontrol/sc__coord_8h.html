<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Spacecraft Control Framework: sc_coord.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sc_coord.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Coordinate transformation functions.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a0f3ed12c9d818e043682694acd62c85c">az_el_range_range_rate_to_rv</a> (const ml_matrix &amp;q_radar_to_hills, double az, double el, double range, double range_dot)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts az, el, range and range rate to exact r and approximate v.  <a href="#a0f3ed12c9d818e043682694acd62c85c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a60369c0eadf560d63e24f18e28ab71ae">q_from_u</a> (const ml_matrix &amp;u_catalog, const ml_matrix &amp;u_meas)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a quaternion given at least 3 matching vectors.  <a href="#a60369c0eadf560d63e24f18e28ab71ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#aec275dab4bbf2410325bc78d8847acdc">q_to_angle</a> (const ml_matrix &amp;quaternion)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns value of the angle from the quaternion in radians.  <a href="#aec275dab4bbf2410325bc78d8847acdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ac24bed620e3a60e242af9b7f953da8ee">q_to_vec</a> (const ml_matrix &amp;quaternion)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the vector from quaternion.  <a href="#ac24bed620e3a60e242af9b7f953da8ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a821a61315099518ee5e20d15c5187f27">au_to_q</a> (double angle, double unit_vec[3])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute quaternion from angle and unit vector, array format.  <a href="#a821a61315099518ee5e20d15c5187f27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a7dedadc34984a4e52e14a54a40ffa659">au_to_q</a> (double angle, const ml_matrix &amp;unit_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute quaternion from angle and unit vector, matrix format.  <a href="#a7dedadc34984a4e52e14a54a40ffa659"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a175575c736d1b803c3aae2a502d73006">q_to_au</a> (const ml_matrix &amp;quaternion, ml_matrix &amp;unit_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute angle and unit vector from quaternion.  <a href="#a175575c736d1b803c3aae2a502d73006"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#abe18395cacd4614bf5dc39094dbed19a">eul_to_mat</a> (const ml_matrix &amp;euler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 3-2-1 Euler angle sequence to a matrix that transforms in the direction of the rotation.  <a href="#abe18395cacd4614bf5dc39094dbed19a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2afda408a872a8e99dc65517818a5c73"></a><!-- doxytag: member="sc_coord.h::eul_to_q" ref="a2afda408a872a8e99dc65517818a5c73" args="(const ml_matrix &amp;euler)" -->
ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a2afda408a872a8e99dc65517818a5c73">eul_to_q</a> (const ml_matrix &amp;euler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 3-2-1 Euler angle sequence to a quaternion that transforms in the direction of the rotation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#abbe028bc501906984410603fdfaf0682">delta_eul_to_q</a> (const ml_matrix &amp;q, const ml_matrix &amp;euler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a 3-2-1 Euler angle sequence to a quaternion that transforms in the direction of the rotation.  <a href="#abbe028bc501906984410603fdfaf0682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a069e05c0bdd196c36c0822601d3b50ab">rot_mat_x</a> (const double &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a rotation matrix for angular rotation about the x axis.  <a href="#a069e05c0bdd196c36c0822601d3b50ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a97d4c6f3474d36345c3d005e407ca597">rot_mat_y</a> (const double &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a rotation matrix for angular rotation about the y axis.  <a href="#a97d4c6f3474d36345c3d005e407ca597"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a2b7714ff92b433d9093820cdf3251db2">rot_mat_z</a> (const double &amp;a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a rotation matrix for angular rotation about the z axis.  <a href="#a2b7714ff92b433d9093820cdf3251db2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a6c3aed4d8813b4f191ce48357492cf61">mat_to_q</a> (const ml_matrix &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a matrix to a quaternion.  <a href="#a6c3aed4d8813b4f191ce48357492cf61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a6db8f60e1b0958a1daa2402790b368e0">mat_to_eul</a> (const ml_matrix &amp;mat, const ml_matrix &amp;euler)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a matrix to an Euler angle sequence.  <a href="#a6db8f60e1b0958a1daa2402790b368e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#aeb9d31ae95b49aa117bc1a6318d368a0">u_to_q</a> (const ml_matrix &amp;vec1, const ml_matrix &amp;vec2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quaternion which aligns one vector with a second.  <a href="#aeb9d31ae95b49aa117bc1a6318d368a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#af325fd2c66f65284cd9cec2ac7d65304">perpendicular</a> (const ml_matrix &amp;vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the perpendicular vector.  <a href="#af325fd2c66f65284cd9cec2ac7d65304"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a1f6cbfa5061ea2301347f6c784eaccb7">q_error</a> (const ml_matrix &amp;q_ref, const ml_matrix &amp;q_meas)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the small error between two quaternions and converts them into an angle vector.  <a href="#a1f6cbfa5061ea2301347f6c784eaccb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a143f7e11b2567d955c428c9444a42333">qb_to_i_dot</a> (const ml_matrix &amp;quaternion, const ml_matrix &amp;w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivative of the body to inertial quaternion.  <a href="#a143f7e11b2567d955c428c9444a42333"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a7056e2de61d89a4fa419dc89030666d0">qi_to_b_dot</a> (const ml_matrix &amp;quat, const ml_matrix &amp;w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivative of the inertial to body quaternion.  <a href="#a7056e2de61d89a4fa419dc89030666d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ac2b4f6fcdb092b76856c504564bb9ee5">qeb_re_ub_to_az_el</a> (const ml_matrix &amp;qEB, const ml_matrix &amp;rE, const ml_matrix &amp;vB)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate azimuth &amp; elevation angle from ECI to body quaternion, position, and boresight vector.  <a href="#ac2b4f6fcdb092b76856c504564bb9ee5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a5553e973e13e585fdd78f14b007bff10">mat_eci_to_lvlh</a> (const ml_matrix &amp;pos, const ml_matrix &amp;vel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the matrix that transforms from ECI to LVLH coordinates.  <a href="#a5553e973e13e585fdd78f14b007bff10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a24a521e442a8b82a89b94c7a5784f24d">q_eci_to_lvlh</a> (const ml_matrix &amp;pos, const ml_matrix &amp;vel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the quaternion that transforms from ECI to LVLH coordinates.  <a href="#a24a521e442a8b82a89b94c7a5784f24d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#aa01183185fdb2a594b56628487f51309">mat_eci_to_hills</a> (const ml_matrix &amp;r, const ml_matrix &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the matrix that transforms from ECI to Hills coordinates.  <a href="#aa01183185fdb2a594b56628487f51309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#abd057322876586cace7fb07ed040371c">q_eci_to_hills</a> (const ml_matrix &amp;r, const ml_matrix &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the quaternion that transforms from ECI to Hills coordinates.  <a href="#abd057322876586cace7fb07ed040371c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a358805bd2f2c5ce16bb1fa8e301e39f6">eci_to_hills</a> (const ml_matrix &amp;x0, const ml_matrix &amp;x1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform from two ECI states to one relative state in Hills-frame.  <a href="#a358805bd2f2c5ce16bb1fa8e301e39f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a94a7495da50d6414fb8ae6de2f8c35f5">hills_to_eci</a> (const ml_matrix &amp;x0, const ml_matrix &amp;xH)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform from a relative state in Hills-frame to an absolute ECI state.  <a href="#a94a7495da50d6414fb8ae6de2f8c35f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a68faa9bff69b984069c0f93fc485ec47">q_to_ra_dec</a> (const ml_matrix &amp;quaternion, const ml_matrix &amp;uu)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute right ascension and declination from a quaterion.  <a href="#a68faa9bff69b984069c0f93fc485ec47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ac13f985ce15fabc388e90a34291cfdfd">u_to_ra_dec</a> (const ml_matrix &amp;unit_vec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes right ascension and declination from a unit vector.  <a href="#ac13f985ce15fabc388e90a34291cfdfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a5044da8a3a86bec18595ceba7ca6b2b8">u_to_ra_dec</a> (const ml_matrix &amp;unit_vec, bool normalize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes right ascension and declination from a unit vector and normalizes the result.  <a href="#a5044da8a3a86bec18595ceba7ca6b2b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a15e3e59d23427d2217772efbc11236a5">ra_dec_to_q</a> (const ml_matrix &amp;uu, double ra, double dec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a quaternion from right ascension and declination.  <a href="#a15e3e59d23427d2217772efbc11236a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a3e37dca0b0b19e9a925f947a41acfd72">ra_dec_to_u</a> (double ra, double dec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a unit vector from right ascension and declination.  <a href="#a3e37dca0b0b19e9a925f947a41acfd72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a84d8de3c5463a370a63c76e89f6147d0">ra_dec_to_u</a> (const ml_matrix &amp;ra, const ml_matrix &amp;dec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a unit vector from right ascension and declination.  <a href="#a84d8de3c5463a370a63c76e89f6147d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#af2db20b38e3397817d113ee883394c1c">az_el_to_q</a> (ml_matrix az, ml_matrix el)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a quaternion from azimuth and elevation.  <a href="#af2db20b38e3397817d113ee883394c1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a5e15fc162b06693caf7449db0553df86">az_el_to_q</a> (double az, double el)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a quaternion from azimuth and elevation.  <a href="#a5e15fc162b06693caf7449db0553df86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a041a75124e24887f520d99971b3fa3ae">qslerp</a> (const ml_matrix &amp;quat1, const ml_matrix &amp;quat2, double t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates between two quaternions.  <a href="#a041a75124e24887f520d99971b3fa3ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a967a3bb8dc9c8cd40538731388f0a212">lat_lon_alt_to_pos</a> (double lat, double lon, double h, double f=<a class="el" href="sc__constants_8h.html#a91ff8aa39e1e77d25814ce44cc022923">FLATTENING_FACTOR</a>, double a=<a class="el" href="sc__constants_8h.html#ad6ced367857b130153df275020ee6785">RADIUS_EARTH</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute EF position vector from latitude, longitude, and altitude.  <a href="#a967a3bb8dc9c8cd40538731388f0a212"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a95f1b6cec6074595f1da061d2bb4fecb">lat_lon_to_pos</a> (double lat, double lon, double f, double a, bool is_geodetic)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts latitude and longitude to r for an ellipsoidal planet.  <a href="#a95f1b6cec6074595f1da061d2bb4fecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ae0ed1d3282925bfab8d7edc2e808b91d">lat_lon_to_pos</a> (double lat, double lon, double f=<a class="el" href="sc__constants_8h.html#a91ff8aa39e1e77d25814ce44cc022923">FLATTENING_FACTOR</a>, double a=<a class="el" href="sc__constants_8h.html#ad6ced367857b130153df275020ee6785">RADIUS_EARTH</a>, int type=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts latitude and longitude to r for an ellipsoidal planet.  <a href="#ae0ed1d3282925bfab8d7edc2e808b91d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#aae3e6319005d6ef219e654720c491aac">pos_to_lat_lon_alt</a> (const ml_matrix &amp;efPos, double f=<a class="el" href="sc__constants_8h.html#a91ff8aa39e1e77d25814ce44cc022923">FLATTENING_FACTOR</a>, double a=<a class="el" href="sc__constants_8h.html#ad6ced367857b130153df275020ee6785">RADIUS_EARTH</a>, double tolerance=1.0e-6)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute latitude, longitude, and altitude from EF position vector.  <a href="#aae3e6319005d6ef219e654720c491aac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a6b7b5b2552501ebcc8aa0e1aec902e78">cart_to_sph</a> (const ml_matrix &amp;x, const ml_matrix &amp;y, const ml_matrix &amp;z, ml_matrix &amp;r, ml_matrix &amp;theta, ml_matrix &amp;phi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts cartesian coordinates to spherical.  <a href="#a6b7b5b2552501ebcc8aa0e1aec902e78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a5bb034b49aad13aab8f05706803cf734">cart_to_sph</a> (const ml_matrix &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts cartesian coordinates to spherical. Stacked form.  <a href="#a5bb034b49aad13aab8f05706803cf734"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a362544fd51f36539397f7110432670b9">sph_to_cart</a> (const ml_matrix &amp;r, const ml_matrix &amp;theta, const ml_matrix &amp;phi, ml_matrix &amp;x, ml_matrix &amp;y, ml_matrix &amp;z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert spherical coordinates to cartesian.  <a href="#a362544fd51f36539397f7110432670b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a30a78bb7a9ddbddeb489f2f4e69e876b">RPhiTheta2Cart</a> (const ml_matrix &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transformation matrix from an r, phi, theta frame to cartesian.  <a href="#a30a78bb7a9ddbddeb489f2f4e69e876b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a89bef838795813cae3dd8af21a94ca5a">CameraToECI</a> (double az, double el, double tt, const ml_matrix &amp;qECIToBody, const ml_matrix &amp;mBaseToBody)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transformation matrix from a camera frame with 3 rotations to the body frame.  <a href="#a89bef838795813cae3dd8af21a94ca5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a8659c5138da88e205d71b799caffe4d6">eci_to_ned</a> (const ml_matrix &amp;r, int opt, double f=<a class="el" href="sc__constants_8h.html#a91ff8aa39e1e77d25814ce44cc022923">FLATTENING_FACTOR</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the transformation matrix or quaternion from a eciframe to the North East Down (NED) frame.  <a href="#a8659c5138da88e205d71b799caffe4d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ae8f9a0d538e6808d550df5ab838de140">u_to_az_el</a> (const ml_matrix &amp;u)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the azimuth and elevation of a unit vector.  <a href="#ae8f9a0d538e6808d550df5ab838de140"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ae7f9ab0cfab0945e980286899af4b8f3">az_el_to_u</a> (double az, double el)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes u from azimuth and elevation of a unit vector.  <a href="#ae7f9ab0cfab0945e980286899af4b8f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a85516cf668dbfcacd514106b47f0389c">az_el_to_u</a> (const ml_matrix &amp;az, const ml_matrix &amp;el)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a unit vector from azimuth and elevation.  <a href="#a85516cf668dbfcacd514106b47f0389c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a4d980c9dc809a47be66193709b111f25">q_from_dq</a> (const ml_matrix &amp;q, const ml_matrix &amp;dX)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes q as the product of q and a delta quaternion.  <a href="#a4d980c9dc809a47be66193709b111f25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a8fb377e7cad49e52fdbabd15ec928e9d">dq_from_dX</a> (const ml_matrix &amp;dX)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delta quaternion from a 3 vector.  <a href="#a8fb377e7cad49e52fdbabd15ec928e9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ac8ed6651dc7ae6e01b2241bc0e4cea37">r_lvlh_to_eci</a> (const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LVLH position to ECI.  <a href="#ac8ed6651dc7ae6e01b2241bc0e4cea37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#af4c356cde79acfc4c4cd34117a1c4e65">v_lvlh_to_eci</a> (const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ECI position to LVLH.  <a href="#af4c356cde79acfc4c4cd34117a1c4e65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ae8edb4922aded007e6e15c565a13c3c8">r_eci_to_lvlh</a> (const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LVLH position to ECI.  <a href="#ae8edb4922aded007e6e15c565a13c3c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#acf1e0381be34fc47d932803bb15196f9">v_eci_to_lvlh</a> (const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ECI position to LVLH.  <a href="#acf1e0381be34fc47d932803bb15196f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a18ebb3c592f1ddae34458b73798871b6">x_lvlh_to_eci</a> (const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">LVLH state to ECI.  <a href="#a18ebb3c592f1ddae34458b73798871b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ae368a1ac7cf9b98af9c1c26491aae1d9">x_eci_to_lvlh</a> (const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ECI state to LVLH.  <a href="#ae368a1ac7cf9b98af9c1c26491aae1d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ab84d21194a3ef469a6b6bd1e79651b5f">x_lvlh_to_eci</a> (const ml_matrix &amp;x_eci, const ml_matrix &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ECI state to LVLH.  <a href="#ab84d21194a3ef469a6b6bd1e79651b5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#a44b0d928f66ed82ba2fa25866a9cce86">x_eci_to_lvlh</a> (const ml_matrix &amp;x_eci, const ml_matrix &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ECI state to LVLH.  <a href="#a44b0d928f66ed82ba2fa25866a9cce86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ac5d2c04c3cf5dbd7376cc862f6d5986f">LLAToECEF</a> (const ml_matrix &amp;lla, double rP=<a class="el" href="sc__constants_8h.html#ad6ced367857b130153df275020ee6785">RADIUS_EARTH</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ECEF position from latitude, longitude, altitude.  <a href="#ac5d2c04c3cf5dbd7376cc862f6d5986f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ab3c687889d3eae123ed99eedd5c53671">small_angles_to_q</a> (const ml_matrix &amp;angle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert small angles to a quaternion.  <a href="#ab3c687889d3eae123ed99eedd5c53671"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ml_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sc__coord_8h.html#ae62eb2ea85e238d124cfde6324fa100f">spice_to_3_by_3</a> (const ml_matrix &amp;m, int k=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert SPICE rotation matrix to 3x3.  <a href="#ae62eb2ea85e238d124cfde6324fa100f"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0f3ed12c9d818e043682694acd62c85c"></a><!-- doxytag: member="sc_coord.h::az_el_range_range_rate_to_rv" ref="a0f3ed12c9d818e043682694acd62c85c" args="(const ml_matrix &amp;q_radar_to_hills, double az, double el, double range, double range_dot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix az_el_range_range_rate_to_rv </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>q_radar_to_hills</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>range_dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">az</td><td>Azimuth </td></tr>
    <tr><td class="paramname">el</td><td>Elevation </td></tr>
    <tr><td class="paramname">range</td><td>Range </td></tr>
    <tr><td class="paramname">range_dot</td><td>Range rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>state [r;v] </dd></dl>

</div>
</div>
<a class="anchor" id="a60369c0eadf560d63e24f18e28ab71ae"></a><!-- doxytag: member="sc_coord.h::q_from_u" ref="a60369c0eadf560d63e24f18e28ab71ae" args="(const ml_matrix &amp;u_catalog, const ml_matrix &amp;u_meas)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix q_from_u </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>u_catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>u_meas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">u_catalog</td><td>A 3xn matrix of catalog unit vectors </td></tr>
    <tr><td class="paramname">u_meas</td><td>A 3xn matrix of measured unit vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The quaternion. </dd></dl>

</div>
</div>
<a class="anchor" id="aec275dab4bbf2410325bc78d8847acdc"></a><!-- doxytag: member="sc_coord.h::q_to_angle" ref="aec275dab4bbf2410325bc78d8847acdc" args="(const ml_matrix &amp;quaternion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double q_to_angle </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>quaternion</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The angle from the quaternion in radians. </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>, and <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="ac24bed620e3a60e242af9b7f953da8ee"></a><!-- doxytag: member="sc_coord.h::q_to_vec" ref="ac24bed620e3a60e242af9b7f953da8ee" args="(const ml_matrix &amp;quaternion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix q_to_vec </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>quaternion</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>The quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The vector from the quaternion. </dd></dl>

</div>
</div>
<a class="anchor" id="a821a61315099518ee5e20d15c5187f27"></a><!-- doxytag: member="sc_coord.h::au_to_q" ref="a821a61315099518ee5e20d15c5187f27" args="(double angle, double unit_vec[3])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix au_to_q </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>unit_vec</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td></td></tr>
    <tr><td class="paramname">unit_vec</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The quaternion computed from the provided angle and unit vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dedadc34984a4e52e14a54a40ffa659"></a><!-- doxytag: member="sc_coord.h::au_to_q" ref="a7dedadc34984a4e52e14a54a40ffa659" args="(double angle, const ml_matrix &amp;unit_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix au_to_q </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>unit_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td></td></tr>
    <tr><td class="paramname">unit_vec</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The quaternion computed from the provided angle and unit vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a175575c736d1b803c3aae2a502d73006"></a><!-- doxytag: member="sc_coord.h::q_to_au" ref="a175575c736d1b803c3aae2a502d73006" args="(const ml_matrix &amp;quaternion, ml_matrix &amp;unit_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double q_to_au </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>quaternion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>unit_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>The quaternion. </td></tr>
    <tr><td class="paramname">unit_vec</td><td>The unit vector will be returned in this matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The angle computed from the quaternion, measured in radians. </dd></dl>

</div>
</div>
<a class="anchor" id="abe18395cacd4614bf5dc39094dbed19a"></a><!-- doxytag: member="sc_coord.h::eul_to_mat" ref="abe18395cacd4614bf5dc39094dbed19a" args="(const ml_matrix &amp;euler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix eul_to_mat </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>euler</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">euler</td><td>(3,1) The Euler angle sequence to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The matrix which transforms in the direction of the rotation. </dd></dl>

</div>
</div>
<a class="anchor" id="abbe028bc501906984410603fdfaf0682"></a><!-- doxytag: member="sc_coord.h::delta_eul_to_q" ref="abbe028bc501906984410603fdfaf0682" args="(const ml_matrix &amp;q, const ml_matrix &amp;euler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix delta_eul_to_q </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>euler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a 3-2-1 Euler angle sequence to a quaternion that transforms in the direction of the rotation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">euler</td><td>(3,1) The Euler angle sequence to be converted. </td></tr>
    <tr><td class="paramname">q</td><td>(4,1) The original quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The matrix which transforms in the direction of the rotation. </dd></dl>

</div>
</div>
<a class="anchor" id="a069e05c0bdd196c36c0822601d3b50ab"></a><!-- doxytag: member="sc_coord.h::rot_mat_x" ref="a069e05c0bdd196c36c0822601d3b50ab" args="(const double &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix rot_mat_x </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"> <em>a</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a rotation matrix for angular rotation about the x axis.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Angle of rotation (rad) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a97d4c6f3474d36345c3d005e407ca597"></a><!-- doxytag: member="sc_coord.h::rot_mat_y" ref="a97d4c6f3474d36345c3d005e407ca597" args="(const double &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix rot_mat_y </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"> <em>a</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a rotation matrix for angular rotation about the y axis.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Angle of rotation (rad) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b7714ff92b433d9093820cdf3251db2"></a><!-- doxytag: member="sc_coord.h::rot_mat_z" ref="a2b7714ff92b433d9093820cdf3251db2" args="(const double &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix rot_mat_z </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"> <em>a</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a rotation matrix for angular rotation about the z axis.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Angle of rotation (rad) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The rotation matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c3aed4d8813b4f191ce48357492cf61"></a><!-- doxytag: member="sc_coord.h::mat_to_q" ref="a6c3aed4d8813b4f191ce48357492cf61" args="(const ml_matrix &amp;mat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix mat_to_q </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>mat</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a matrix to a quaternion.</p>
<p>Wrapper for the MatrixLib function q_from_mat. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>(3,3) The matrix to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The quaternion generated from the provided matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a6db8f60e1b0958a1daa2402790b368e0"></a><!-- doxytag: member="sc_coord.h::mat_to_eul" ref="a6db8f60e1b0958a1daa2402790b368e0" args="(const ml_matrix &amp;mat, const ml_matrix &amp;euler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix mat_to_eul </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>euler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wrapper for the MatrixLib function q_mat_to_eul. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>(3,3) </td></tr>
    <tr><td class="paramname">euler</td><td>(3,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the Euler angle sequence generated from the provided matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb9d31ae95b49aa117bc1a6318d368a0"></a><!-- doxytag: member="sc_coord.h::u_to_q" ref="aeb9d31ae95b49aa117bc1a6318d368a0" args="(const ml_matrix &amp;vec1, const ml_matrix &amp;vec2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix u_to_q </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the quaternion which aligns one vector with a second.</p>
<p>This is not a unique solution.</p>
<p>Wrapper for the MatrixLib function q_from_u. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>(3,1) Starting vector. </td></tr>
    <tr><td class="paramname">vec2</td><td>(3,1) Ending vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Quaternion which rotates vec1 into vec2 </dd></dl>

</div>
</div>
<a class="anchor" id="af325fd2c66f65284cd9cec2ac7d65304"></a><!-- doxytag: member="sc_coord.h::perpendicular" ref="af325fd2c66f65284cd9cec2ac7d65304" args="(const ml_matrix &amp;vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix perpendicular </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>vec</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wrapper for the MatrixLib function q_perpendicular.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>(3,1) The vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the perpendicular to the given vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f6cbfa5061ea2301347f6c784eaccb7"></a><!-- doxytag: member="sc_coord.h::q_error" ref="a1f6cbfa5061ea2301347f6c784eaccb7" args="(const ml_matrix &amp;q_ref, const ml_matrix &amp;q_meas)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix q_error </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>q_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>q_meas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine gives the correct sign when both vectors transform from frame a to frame b and frame b is the body frame. If the convention is reversed you must reverse the sign. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q_ref</td><td>(4,1) Reference quaternion. </td></tr>
    <tr><td class="paramname">q_meas</td><td>(4,1) Measured quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(3,1) Vector of small angular errors. </dd></dl>

</div>
</div>
<a class="anchor" id="a143f7e11b2567d955c428c9444a42333"></a><!-- doxytag: member="sc_coord.h::qb_to_i_dot" ref="a143f7e11b2567d955c428c9444a42333" args="(const ml_matrix &amp;quaternion, const ml_matrix &amp;w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix qb_to_i_dot </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>quaternion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the derivative of the body to inertial quaternion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>(4,1) The quaternion, should be a column vector </td></tr>
    <tr><td class="paramname">w</td><td>(3,1) The anglular velocity, a 3 element column vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(4,1) Derivative of the body to inertial quaternion. </dd></dl>

</div>
</div>
<a class="anchor" id="a7056e2de61d89a4fa419dc89030666d0"></a><!-- doxytag: member="sc_coord.h::qi_to_b_dot" ref="a7056e2de61d89a4fa419dc89030666d0" args="(const ml_matrix &amp;quat, const ml_matrix &amp;w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix qi_to_b_dot </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the derivative of the inertial to body quaternion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">quat</td><td>(4,1) The quaternion, should be a column vector. </td></tr>
    <tr><td class="paramname">w</td><td>(3,1) The angular rate, a 3 element column vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(4,1) Derivative of the inertial to body quaternion. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2b4f6fcdb092b76856c504564bb9ee5"></a><!-- doxytag: member="sc_coord.h::qeb_re_ub_to_az_el" ref="ac2b4f6fcdb092b76856c504564bb9ee5" args="(const ml_matrix &amp;qEB, const ml_matrix &amp;rE, const ml_matrix &amp;vB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix qeb_re_ub_to_az_el </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>qEB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>rE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>vB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate azimuth &amp; elevation angle from ECI to body quaternion, position, and boresight vector.</p>
<p>Azimuth angle is measured clockwise from north to the projection of the boresight vector onto the east-north plane. Elevation angle is the "angle off nadir", the angular distance between the nadir vector and the boresight vector. Adapted by KenW from Joe Mueller's QEB_RE_UB_to_AzEl.m matlab code in /Contracts/NavyReconfigure/Matlab </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">qEB</td><td>(4,1) ECI to spacecraft body coordinate frame quaternion </td></tr>
    <tr><td class="paramname">rE</td><td>(3,1) ECI position of spacecraft </td></tr>
    <tr><td class="paramname">vB</td><td>(3,1) boresight vector defined in body frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(2,1) matrix containing azimuth angle in (1,1) and elevation angle in (2,1) </dd></dl>

</div>
</div>
<a class="anchor" id="a5553e973e13e585fdd78f14b007bff10"></a><!-- doxytag: member="sc_coord.h::mat_eci_to_lvlh" ref="a5553e973e13e585fdd78f14b007bff10" args="(const ml_matrix &amp;pos, const ml_matrix &amp;vel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix mat_eci_to_lvlh </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>vel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For LVLH coordinates; z is in the -r direction y is in the - rxv direction x completes the set </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>(3,1) Position vectors </td></tr>
    <tr><td class="paramname">vel</td><td>(3,1) Velocity vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(4,n) The quaternions that transform from ECI to LVLH coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="a24a521e442a8b82a89b94c7a5784f24d"></a><!-- doxytag: member="sc_coord.h::q_eci_to_lvlh" ref="a24a521e442a8b82a89b94c7a5784f24d" args="(const ml_matrix &amp;pos, const ml_matrix &amp;vel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix q_eci_to_lvlh </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>vel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>(3,1) Position vector </td></tr>
    <tr><td class="paramname">vel</td><td>(3,1) Velocity vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(4,n) The quaternions that transform from ECI to LVLH coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="aa01183185fdb2a594b56628487f51309"></a><!-- doxytag: member="sc_coord.h::mat_eci_to_hills" ref="aa01183185fdb2a594b56628487f51309" args="(const ml_matrix &amp;r, const ml_matrix &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix mat_eci_to_hills </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For Hills coordinates; x is in the + r direction z is in the + rxv direction y completes the set (aligned with velocity for circular orbits) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>(3,1) Position vector </td></tr>
    <tr><td class="paramname">v</td><td>(3,1) Velocity vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>q (4,1) Quaternion </dd></dl>

</div>
</div>
<a class="anchor" id="abd057322876586cace7fb07ed040371c"></a><!-- doxytag: member="sc_coord.h::q_eci_to_hills" ref="abd057322876586cace7fb07ed040371c" args="(const ml_matrix &amp;r, const ml_matrix &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix q_eci_to_hills </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>(3,1) Position vector </td></tr>
    <tr><td class="paramname">v</td><td>(3,1) Velocity vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>q (4,1) Quaternion </dd></dl>

</div>
</div>
<a class="anchor" id="a358805bd2f2c5ce16bb1fa8e301e39f6"></a><!-- doxytag: member="sc_coord.h::eci_to_hills" ref="a358805bd2f2c5ce16bb1fa8e301e39f6" args="(const ml_matrix &amp;x0, const ml_matrix &amp;x1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix eci_to_hills </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>(6,1) ECI position and velocity of reference orbit </td></tr>
    <tr><td class="paramname">x1</td><td>(6,1) ECI position and velocity of secondary orbit </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>xH (6,1) Relative position and velocity in Hills-frame </dd></dl>

</div>
</div>
<a class="anchor" id="a94a7495da50d6414fb8ae6de2f8c35f5"></a><!-- doxytag: member="sc_coord.h::hills_to_eci" ref="a94a7495da50d6414fb8ae6de2f8c35f5" args="(const ml_matrix &amp;x0, const ml_matrix &amp;xH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix hills_to_eci </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>xH</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>(6,1) ECI position and velocity of reference orbit </td></tr>
    <tr><td class="paramname">xH</td><td>(6,1) Relative position and velocity in Hills-frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>x1 (6,1) ECI position and velocity of secondary orbit </dd></dl>

</div>
</div>
<a class="anchor" id="a68faa9bff69b984069c0f93fc485ec47"></a><!-- doxytag: member="sc_coord.h::q_to_ra_dec" ref="a68faa9bff69b984069c0f93fc485ec47" args="(const ml_matrix &amp;quaternion, const ml_matrix &amp;uu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix q_to_ra_dec </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>quaternion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>uu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute right ascension and declination from a quaterion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">quaternion</td><td>(4,1) The quaternion (inertial to body). </td></tr>
    <tr><td class="paramname">uu</td><td>(3,1) unit vector in the body frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The right ascension and declination. </dd></dl>

</div>
</div>
<a class="anchor" id="ac13f985ce15fabc388e90a34291cfdfd"></a><!-- doxytag: member="sc_coord.h::u_to_ra_dec" ref="ac13f985ce15fabc388e90a34291cfdfd" args="(const ml_matrix &amp;unit_vec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix u_to_ra_dec </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>unit_vec</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes right ascension and declination from a unit vector.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">unit_vec</td><td>(3,n) Unit vector(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>rADec (2,n) stacked vector(s) of right ascension (top) and declination (bot) </dd></dl>

</div>
</div>
<a class="anchor" id="a5044da8a3a86bec18595ceba7ca6b2b8"></a><!-- doxytag: member="sc_coord.h::u_to_ra_dec" ref="a5044da8a3a86bec18595ceba7ca6b2b8" args="(const ml_matrix &amp;unit_vec, bool normalize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix u_to_ra_dec </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>unit_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes right ascension and declination from a unit vector and normalizes the result.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">unit_vec</td><td>(3,n) Unit vector(s) </td></tr>
    <tr><td class="paramname">normalize</td><td>Flag indicating whether the return vector should be normalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>rADec (2,n) stacked vector(s) of right ascension (top) and declination (bot) </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a820597b124334bf7fb85214114f4876d">TWO_PI</a>.</p>

</div>
</div>
<a class="anchor" id="a15e3e59d23427d2217772efbc11236a5"></a><!-- doxytag: member="sc_coord.h::ra_dec_to_q" ref="a15e3e59d23427d2217772efbc11236a5" args="(const ml_matrix &amp;uu, double ra, double dec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix ra_dec_to_q </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>uu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If right ascension and declination are defined in frame a, and u is fixed in frame b, q transforms from frame a to b such that u lies along the vector determined by (rA,dec) in frame a. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">uu</td><td>(3,1) unit vector </td></tr>
    <tr><td class="paramname">ra</td><td>(1) Right ascension [rad] </td></tr>
    <tr><td class="paramname">dec</td><td>(1) Declination [rad] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(4,1) Quaternion </dd></dl>

</div>
</div>
<a class="anchor" id="a3e37dca0b0b19e9a925f947a41acfd72"></a><!-- doxytag: member="sc_coord.h::ra_dec_to_u" ref="a3e37dca0b0b19e9a925f947a41acfd72" args="(double ra, double dec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix ra_dec_to_u </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ra</td><td>(1) Right ascension [rad] </td></tr>
    <tr><td class="paramname">dec</td><td>(1) Declination [rad] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unit vector(3,1) computed from the provided right ascension and declination. </dd></dl>

</div>
</div>
<a class="anchor" id="a84d8de3c5463a370a63c76e89f6147d0"></a><!-- doxytag: member="sc_coord.h::ra_dec_to_u" ref="a84d8de3c5463a370a63c76e89f6147d0" args="(const ml_matrix &amp;ra, const ml_matrix &amp;dec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix ra_dec_to_u </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>ra</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>dec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ra</td><td>(1,n) Right ascension [rad] </td></tr>
    <tr><td class="paramname">dec</td><td>(1,n) Declination [rad] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unit vector computed from the provided right ascension and declination. </dd></dl>

</div>
</div>
<a class="anchor" id="af2db20b38e3397817d113ee883394c1c"></a><!-- doxytag: member="sc_coord.h::az_el_to_q" ref="af2db20b38e3397817d113ee883394c1c" args="(ml_matrix az, ml_matrix el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix az_el_to_q </td>
          <td>(</td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix&#160;</td>
          <td class="paramname"> <em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute a quaternion from azimuth and elevation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">az</td><td>Is the azimuth (angle about +z from +x) </td></tr>
    <tr><td class="paramname">el</td><td>is the elevation (angle about +y from +x) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(4,n) The quaternion from base to rotated frame. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e15fc162b06693caf7449db0553df86"></a><!-- doxytag: member="sc_coord.h::az_el_to_q" ref="a5e15fc162b06693caf7449db0553df86" args="(double az, double el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix az_el_to_q </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute a quaternion from azimuth and elevation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">az</td><td>Is the azimuth (angle about +z from +x) </td></tr>
    <tr><td class="paramname">el</td><td>is the elevation (angle about +y from +x) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(4,1) The quaternion from base to rotated frame. </dd></dl>

</div>
</div>
<a class="anchor" id="a041a75124e24887f520d99971b3fa3ae"></a><!-- doxytag: member="sc_coord.h::qslerp" ref="a041a75124e24887f520d99971b3fa3ae" args="(const ml_matrix &amp;quat1, const ml_matrix &amp;quat2, double t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix qslerp </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>quat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>quat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">quat1</td><td>(4,1) </td></tr>
    <tr><td class="paramname">quat2</td><td>(4,1) </td></tr>
    <tr><td class="paramname">t</td><td>(1) between 0 to 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(4,1) Interpolated quaternion </dd></dl>

</div>
</div>
<a class="anchor" id="a967a3bb8dc9c8cd40538731388f0a212"></a><!-- doxytag: member="sc_coord.h::lat_lon_alt_to_pos" ref="a967a3bb8dc9c8cd40538731388f0a212" args="(double lat, double lon, double h, double f=FLATTENING_FACTOR, double a=RADIUS_EARTH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix lat_lon_alt_to_pos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>Latitude in radians. </td></tr>
    <tr><td class="paramname">lon</td><td>Longitude in radians. </td></tr>
    <tr><td class="paramname">h</td><td>Distance above the subsatellite point. </td></tr>
    <tr><td class="paramname">f</td><td>Flattening factor </td></tr>
    <tr><td class="paramname">a</td><td>Equatorial radius </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(3,1) The EF position vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a95f1b6cec6074595f1da061d2bb4fecb"></a><!-- doxytag: member="sc_coord.h::lat_lon_to_pos" ref="a95f1b6cec6074595f1da061d2bb4fecb" args="(double lat, double lon, double f, double a, bool is_geodetic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix lat_lon_to_pos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>is_geodetic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>Latitude in radians. </td></tr>
    <tr><td class="paramname">lon</td><td>Longitude in radians. </td></tr>
    <tr><td class="paramname">f</td><td>Flattening factor </td></tr>
    <tr><td class="paramname">a</td><td>Equatorial radius </td></tr>
    <tr><td class="paramname">is_geodetic</td><td>true for geodetic </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(3,1) The EF position vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0ed1d3282925bfab8d7edc2e808b91d"></a><!-- doxytag: member="sc_coord.h::lat_lon_to_pos" ref="ae0ed1d3282925bfab8d7edc2e808b91d" args="(double lat, double lon, double f=FLATTENING_FACTOR, double a=RADIUS_EARTH, int type=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix lat_lon_to_pos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lat</td><td>Latitude in radians. </td></tr>
    <tr><td class="paramname">lon</td><td>Longitude in radians. </td></tr>
    <tr><td class="paramname">f</td><td>Flattening factor </td></tr>
    <tr><td class="paramname">a</td><td>Equatorial radius </td></tr>
    <tr><td class="paramname">type</td><td>0 for Geodetic </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The EF position vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aae3e6319005d6ef219e654720c491aac"></a><!-- doxytag: member="sc_coord.h::pos_to_lat_lon_alt" ref="aae3e6319005d6ef219e654720c491aac" args="(const ml_matrix &amp;efPos, double f=FLATTENING_FACTOR, double a=RADIUS_EARTH, double tolerance=1.0e&#45;6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix pos_to_lat_lon_alt </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>efPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">efPos</td><td>ECEF position (km) </td></tr>
    <tr><td class="paramname">f</td><td>Flattening factor </td></tr>
    <tr><td class="paramname">a</td><td>Equatorial radius </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance for the iteration </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(3,1) lat (radians), lon (radians), altitude (km) </dd></dl>

<p>References <a class="el" href="sc__constants_8h.html#a952eac791b596a61bba0a133a3bb439f">PI</a>.</p>

</div>
</div>
<a class="anchor" id="a6b7b5b2552501ebcc8aa0e1aec902e78"></a><!-- doxytag: member="sc_coord.h::cart_to_sph" ref="a6b7b5b2552501ebcc8aa0e1aec902e78" args="(const ml_matrix &amp;x, const ml_matrix &amp;y, const ml_matrix &amp;z, ml_matrix &amp;r, ml_matrix &amp;theta, ml_matrix &amp;phi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cart_to_sph </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Individual vector form. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramname">r</td><td></td></tr>
    <tr><td class="paramname">theta</td><td></td></tr>
    <tr><td class="paramname">phi</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bb034b49aad13aab8f05706803cf734"></a><!-- doxytag: member="sc_coord.h::cart_to_sph" ref="a5bb034b49aad13aab8f05706803cf734" args="(const ml_matrix &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix cart_to_sph </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts cartesian coordinates to spherical. Stacked form.</p>
<p>Stacked matrix form. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Position state [x;y;z] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>r New coordinates [r;theta;phi] </dd></dl>

</div>
</div>
<a class="anchor" id="a362544fd51f36539397f7110432670b9"></a><!-- doxytag: member="sc_coord.h::sph_to_cart" ref="a362544fd51f36539397f7110432670b9" args="(const ml_matrix &amp;r, const ml_matrix &amp;theta, const ml_matrix &amp;phi, ml_matrix &amp;x, ml_matrix &amp;y, ml_matrix &amp;z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_to_cart </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert spherical coordinates to cartesian.</p>
<p>Individual vector form. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
    <tr><td class="paramname">theta</td><td></td></tr>
    <tr><td class="paramname">phi</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">z</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30a78bb7a9ddbddeb489f2f4e69e876b"></a><!-- doxytag: member="sc_coord.h::RPhiTheta2Cart" ref="a30a78bb7a9ddbddeb489f2f4e69e876b" args="(const ml_matrix &amp;r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix RPhiTheta2Cart </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the transformation matrix from an r, phi, theta frame to cartesian.</p>
<p>In an RPT frame, r is the radial direction, phi is 'east', and theta is in the direction of co-elevation. When theta is zero the r vector is in the xy-plane. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Position vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>cRPT2Cart Transformation matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a89bef838795813cae3dd8af21a94ca5a"></a><!-- doxytag: member="sc_coord.h::CameraToECI" ref="a89bef838795813cae3dd8af21a94ca5a" args="(double az, double el, double tt, const ml_matrix &amp;qECIToBody, const ml_matrix &amp;mBaseToBody)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix CameraToECI </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>el</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>tt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>qECIToBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>mBaseToBody</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the transformation matrix from a camera frame with 3 rotations to the body frame.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">az</td><td>Azimuth (rad) </td></tr>
    <tr><td class="paramname">el</td><td>Elevation (rad) </td></tr>
    <tr><td class="paramname">tt</td><td>Turntable angle (rad) </td></tr>
    <tr><td class="paramname">qECIToBody</td><td>Quaternion from ECI to Body </td></tr>
    <tr><td class="paramname">mBaseToBody</td><td>Transformation matrix from Camera base to body </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>mCameraToECI Transformation matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a8659c5138da88e205d71b799caffe4d6"></a><!-- doxytag: member="sc_coord.h::eci_to_ned" ref="a8659c5138da88e205d71b799caffe4d6" args="(const ml_matrix &amp;r, int opt, double f=FLATTENING_FACTOR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix eci_to_ned </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the transformation matrix or quaternion from a eciframe to the North East Down (NED) frame.</p>
<p>Reference: Stevens, B.L., Lewis, F.L. , Aircraft Control and Simulation, John Wiley &amp; Sons, 1992, p. 36.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>ECI position vector (km) </td></tr>
    <tr><td class="paramname">opt</td><td>0 output quaternion 1 output matrix (rad) </td></tr>
    <tr><td class="paramname">f</td><td>Flattening factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>qECIToNED or mECIToNED Transformation quaternion or matrix </dd></dl>

</div>
</div>
<a class="anchor" id="ae8f9a0d538e6808d550df5ab838de140"></a><!-- doxytag: member="sc_coord.h::u_to_az_el" ref="ae8f9a0d538e6808d550df5ab838de140" args="(const ml_matrix &amp;u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix u_to_az_el </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>u</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes the azimuth and elevation of a unit vector.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Unit vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>[az;el] </dd></dl>

</div>
</div>
<a class="anchor" id="ae7f9ab0cfab0945e980286899af4b8f3"></a><!-- doxytag: member="sc_coord.h::az_el_to_u" ref="ae7f9ab0cfab0945e980286899af4b8f3" args="(double az, double el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix az_el_to_u </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes u from azimuth and elevation of a unit vector.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">az</td><td>Azimuth </td></tr>
    <tr><td class="paramname">el</td><td>Elevation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unit vector </dd></dl>

</div>
</div>
<a class="anchor" id="a85516cf668dbfcacd514106b47f0389c"></a><!-- doxytag: member="sc_coord.h::az_el_to_u" ref="a85516cf668dbfcacd514106b47f0389c" args="(const ml_matrix &amp;az, const ml_matrix &amp;el)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix az_el_to_u </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute a unit vector from azimuth and elevation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">az</td><td>is the azimuth (angle about +z from +x) </td></tr>
    <tr><td class="paramname">el</td><td>is the elevation (angle about +y from +x) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The unit vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d980c9dc809a47be66193709b111f25"></a><!-- doxytag: member="sc_coord.h::q_from_dq" ref="a4d980c9dc809a47be66193709b111f25" args="(const ml_matrix &amp;q, const ml_matrix &amp;dX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix q_from_dq </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>dX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Computes q as the product of q and a delta quaternion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Quaternion </td></tr>
    <tr><td class="paramname">dX</td><td>Delta quaternion </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Quaternion </dd></dl>

</div>
</div>
<a class="anchor" id="a8fb377e7cad49e52fdbabd15ec928e9d"></a><!-- doxytag: member="sc_coord.h::dq_from_dX" ref="a8fb377e7cad49e52fdbabd15ec928e9d" args="(const ml_matrix &amp;dX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix dq_from_dX </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>dX</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delta quaternion from a 3 vector.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dX</td><td>Delta quaternion </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Quaternion </dd></dl>

</div>
</div>
<a class="anchor" id="ac8ed6651dc7ae6e01b2241bc0e4cea37"></a><!-- doxytag: member="sc_coord.h::r_lvlh_to_eci" ref="ac8ed6651dc7ae6e01b2241bc0e4cea37" args="(const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix r_lvlh_to_eci </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>LVLH position to ECI.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r_eci</td><td>Position vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">v_eci</td><td>Velocity vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">r</td><td>Position vector in lvlh frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position vector in the eci frame </dd></dl>

</div>
</div>
<a class="anchor" id="af4c356cde79acfc4c4cd34117a1c4e65"></a><!-- doxytag: member="sc_coord.h::v_lvlh_to_eci" ref="af4c356cde79acfc4c4cd34117a1c4e65" args="(const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix v_lvlh_to_eci </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ECI position to LVLH.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r_eci</td><td>Position vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">v_eci</td><td>Velocity vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">v</td><td>Position vector in lvlh frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position vector in the eci frame </dd></dl>

</div>
</div>
<a class="anchor" id="ae8edb4922aded007e6e15c565a13c3c8"></a><!-- doxytag: member="sc_coord.h::r_eci_to_lvlh" ref="ae8edb4922aded007e6e15c565a13c3c8" args="(const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix r_eci_to_lvlh </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>LVLH position to ECI.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r_eci</td><td>Position vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">v_eci</td><td>Velocity vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">r</td><td>Position vector in eci frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position vector in the lvlh frame </dd></dl>

</div>
</div>
<a class="anchor" id="acf1e0381be34fc47d932803bb15196f9"></a><!-- doxytag: member="sc_coord.h::v_eci_to_lvlh" ref="acf1e0381be34fc47d932803bb15196f9" args="(const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix v_eci_to_lvlh </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ECI position to LVLH.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r_eci</td><td>Position vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">v_eci</td><td>Velocity vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">v</td><td>Position vector in eci frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position vector in the lvlh frame </dd></dl>

</div>
</div>
<a class="anchor" id="a18ebb3c592f1ddae34458b73798871b6"></a><!-- doxytag: member="sc_coord.h::x_lvlh_to_eci" ref="a18ebb3c592f1ddae34458b73798871b6" args="(const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix x_lvlh_to_eci </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>LVLH state to ECI.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r_eci</td><td>Position vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">v_eci</td><td>Velocity vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">x</td><td>[r;v] in lvlh frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position vector in the eci frame </dd></dl>

</div>
</div>
<a class="anchor" id="ae368a1ac7cf9b98af9c1c26491aae1d9"></a><!-- doxytag: member="sc_coord.h::x_eci_to_lvlh" ref="ae368a1ac7cf9b98af9c1c26491aae1d9" args="(const ml_matrix &amp;r_eci, const ml_matrix &amp;v_eci, const ml_matrix &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix x_eci_to_lvlh </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>r_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>v_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ECI state to LVLH.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r_eci</td><td>Position vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">v_eci</td><td>Velocity vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">x</td><td>[r;v] in eci frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position vector in the eci frame </dd></dl>

</div>
</div>
<a class="anchor" id="ab84d21194a3ef469a6b6bd1e79651b5f"></a><!-- doxytag: member="sc_coord.h::x_lvlh_to_eci" ref="ab84d21194a3ef469a6b6bd1e79651b5f" args="(const ml_matrix &amp;x_eci, const ml_matrix &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix x_lvlh_to_eci </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ECI state to LVLH.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x_eci</td><td>Velocity vector of reference center in the ECI frame </td></tr>
    <tr><td class="paramname">x</td><td>[r;v] in lvlh frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position vector in the eci frame </dd></dl>

</div>
</div>
<a class="anchor" id="a44b0d928f66ed82ba2fa25866a9cce86"></a><!-- doxytag: member="sc_coord.h::x_eci_to_lvlh" ref="a44b0d928f66ed82ba2fa25866a9cce86" args="(const ml_matrix &amp;x_eci, const ml_matrix &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix x_eci_to_lvlh </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x_eci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ECI state to LVLH.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x_eci</td><td>State vector of reference center in the ECI frame [r;v] </td></tr>
    <tr><td class="paramname">x</td><td>[r;v] in eci frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>State in the eci frame </dd></dl>

</div>
</div>
<a class="anchor" id="ac5d2c04c3cf5dbd7376cc862f6d5986f"></a><!-- doxytag: member="sc_coord.h::LLAToECEF" ref="ac5d2c04c3cf5dbd7376cc862f6d5986f" args="(const ml_matrix &amp;lla, double rP=RADIUS_EARTH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix LLAToECEF </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>lla</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>rP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute ECEF position from latitude, longitude, altitude.</p>
<p>Assumes a spherical planet. Can handle an array of positions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lla</td><td>(3xn) Latitude [rad], longitude [rad], altitude [km] </td></tr>
    <tr><td class="paramname">rP</td><td>Radius of planet (for Earth: 6378.14) [km] </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ECEF position vector [km] </dd></dl>

</div>
</div>
<a class="anchor" id="ab3c687889d3eae123ed99eedd5c53671"></a><!-- doxytag: member="sc_coord.h::small_angles_to_q" ref="ab3c687889d3eae123ed99eedd5c53671" args="(const ml_matrix &amp;angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix small_angles_to_q </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>angle</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Angle vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Equivalent quaternion </dd></dl>

</div>
</div>
<a class="anchor" id="ae62eb2ea85e238d124cfde6324fa100f"></a><!-- doxytag: member="sc_coord.h::spice_to_3_by_3" ref="ae62eb2ea85e238d124cfde6324fa100f" args="(const ml_matrix &amp;m, int k=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ml_matrix spice_to_3_by_3 </td>
          <td>(</td>
          <td class="paramtype">const ml_matrix &amp;&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert SPICE rotation matrix to 3x3.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>SPICE 9-by-1 rotation matrix (column major) </td></tr>
    <tr><td class="paramname">k</td><td>Column </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>3-by-3 matrix Planet fixed to ECI </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Aug 2 2012 11:11:31 for Spacecraft Control Framework by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
