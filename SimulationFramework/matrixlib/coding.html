<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Optimizing</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.3.4 -->
<h1><a class="anchor" name="coding">Optimizing</a></h1>This page summarizes the best coding strategies for efficient code. While MatrixLib has been designed to provide efficiency independent of the user, there are nonetheless strategies that may be employed to improve the performance of code dependent on matrix operations. The following is a list, with explanation, of the most important of these guidelines.<p>
<ol>
<li>
Use get() to access matrix elements whenever possible. Only use the parentheses operator, (), when you must set a value. Since <a class="el" href="a00015.html#a1">ml_matrix::get()</a> is implemented inline, it doesn't result in function call overhead; It also does not need to consider resizing. This results in a considerable increase in speed.<p>
</li>
<li>
Resizing matrices is a slow operation. If you can, ensure that a matrix is the proper size initially so that resizing can be avoided. This is especially true in the case of repeated <a class="el" href="a00015.html#a42">stack()</a> or <a class="el" href="a00015.html#a41">append()</a> calls - by creating a destination matrix of the appropriate size and then using <a class="el" href="a00015.html#a31">ml_matrix::inc_rows()</a> or <a class="el" href="a00015.html#a32">ml_matrix::inc_cols()</a> better performance can be achieved.<p>
</li>
<li>
Use the combined *=, +=, /=, etc., operators whenever possible. While this results in code that looks unusual, it results in fewer temporary variables and therefore a speed increase. For instance, to add A + B + C where all are matrices, you might write <a class="el" href="a00006.html">ml_matrix</a> D = A + B + C; However, the faster way to write this is: <a class="el" href="a00006.html">ml_matrix</a> D(A); (D+=B)+=C; The first line uses the copy constructor to create D from A, which is faster than first creating a D matrix and then setting it equal to A (<a class="el" href="a00006.html">ml_matrix</a> D = A). The second line first adds B to D, then adds C to D. This version adds one line of code, but avoids creating the two invisible temporary matrices (one for A+B and one for the addition of C to the first temporary) created in the first example. No temporary variables are needed, and there are exactly the same number of arithmetic operations. <p>
</li>
<li>
Nearly all non-member functions in MatrixLib are implemented in terms of their member function equivalents. As a result, it is almost invariably faster to use the member functions when possible, as their use results in the avoidance of a second function call.<p>
</li>
<li>
Avoid unnecessary type conversions. MatrixLib works with doubles. Do the same with anything that interacts with MatrixLib to avoid int-to-double promotions during computation. Numbers that don't interact, such as index variables which aren't added, subtracted, or otherwise operated upon, can be integers. However, numbers used in any formula should be doubles. For example, if you are tripling the elements of a matrix, be sure to multiply by 3.0 instead of 3.<p>
</li>
<li>
If you're iterating through a matrix, iterate in the direction that the matrix is stored in. If the ML_COLUMN_MAJOR macro is defined, have the outer loop iterate columns and the inner loop iterate rows: that is, go from (1,1) to (X,1), then from (1,2) to (X,2), and so on. If the macro is not defined, do the opposite: go from (1,1) to (1,X), then from (2,1) to (2,X), and so on. MatrixLib's internal storage order is variable and is based on the configuration options given at the time your library was compiled; the ML_COLUMN_MAJOR macro will allow user code to determine this.<p>
</li>
<li>
While the <a class="el" href="a00004.html">ml_int_array</a> class provides significant convenience to the user, it can also impact performance if used heavily. Especially when working in tight loops that require arrays of matrix indices, it can be much more efficient to work with standard C arrays. If the functionality of <a class="el" href="a00004.html">ml_int_array</a> remains desired but the array is invariant over a loop, the <a class="el" href="a00012.html#a20">ml_int_array::get_c_arr()</a> function can be used to get the C array version of a <a class="el" href="a00004.html">ml_int_array</a> outside of the loop, rather than forcing MatrixLib to extract it during each iteration.<p>
</li>
</ol>
</body>
</html>
