<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BLAS and LAPACK</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.3.4 -->
<h1><a class="anchor" name="lapack">BLAS and LAPACK</a></h1><h2><a class="anchor" name="Overview">
Overview</a></h2>
MatrixLib provides integration with BLAS and LAPACK, both via built-in functions that use one or the other to do actual calculations and via functions that allow a user to extract the necessary data from MatrixLib to make arbitrary BLAS/LAPACK function calls in their own code. Doing so is quite straightforward, and allows the user to take advantage of BLAS/LAPACK functionality not yet built into MatrixLib itself.<p>
There are a few things that must be kept in mind to ensure smooth integration between MatrixLib and BLAS/LAPACK. The first is that MatrixLib expects to have control over the arrays that contain the data for a matrix, and if user code makes unexpected changes to these buffers errors can occur. MatrixLib provides access to the internal data array for a matrix, but the user is advised to avoid manipulation of this array beyond that strictly necessary- resizing, element access and modification, etc should all be done via the standard MatrixLib function calls.<h2><a class="anchor" name="Arbitrary">
BLAS/LAPACK Calls</a></h2>
BLAS and LAPACK functions require four pieces of information regarding a matrix in order to properly operate on it. The first two are simple: the number of rows and the number of columns in the matrix. This information is readily available to the user via the <a class="el" href="a00017.html#a17">ml_matrix::rows()</a> and <a class="el" href="a00017.html#a18">ml_matrix::cols()</a> function calls. The third and fourth pieces of information are details usually masked by the MatrixLib class: A pointer to the data array for the matrix, and the "major stride" of the matrix. MatrixLib internally stores matrices in memory that is sometimes slightly larger than strictly necessary in order to optimize resizes and provide a workspace for certain operations. The major stride tells BLAS/LAPACK how large the matrix <em>actually</em> is in terms of the storage array, rather than the size presented to the user.<p>
These two pieces of information can be retrieved via the <a class="el" href="a00016.html#a0">ml_matrix::raw_data()</a> function and the <a class="el" href="a00016.html#a1">ml_matrix::data_stride()</a> function. They are provided entirely for the purpose of allows BLAS/LAPACK calls; again, it is not advised tha the user modify the raw data array directly.<p>
Often BLAS and LAPACK calls will require an input matrix and an output matrix. The most efficient way to handle this is to create the output matrix, of the appropriate size, before the function call; raw_data() and data_stride() can then be called on this new output matrix to acquire the necessary information for passing into the BLAS or LAPACK function call. When doing this, however, be sure that the output matrix is the correct size when it is constructed; many BLAS and LAPACK function calls assume the output matrix size from the input matrix size rather than taking specific row/column count information (other than the major stride). If the output matrix data array passed in is smaller than that needed by the function, memory corruption will occur.<h2><a class="anchor" name="An">
Example</a></h2>
One of the simplest examples of using BLAS to perform calculations can come straight from MatrixLib and the * operator for matrix multiplication. To implement this as a user function via BLAS would be quite simple.<p>
First, let's assume that we have two matrices, A and B. We'll assume for the sake of brevity that the sizes of the matrices match up such that A*B is a valid operation. We're interested in writing a function to compute A*B and return the result, C. We can use the following as the signature for our function: <pre><div>
<a class="el" href="a00006.html">ml_matrix</a> matrix_multiply(const ml_matrix &amp;A,const ml_matrix &amp;B);
</pre></div><p>
To do the calculation, we'll use the BLAS function cblas_dgemm. This function actually does more work than we need, calculating C = x*A*B + y*C, but by passing in the appropriate scalar values for x and y we can accomplish our goal. The function takes a large number of parameters:<p>
<table cellspacing="0" width="100%" border="1" cellpadding="3">
<tr>
<td colspan="3" align="center">cblas_dgemm Parameters </td></tr>
<tr bgcolor="#CCCCCC">
<td>Parameter</td><td>Type</td><td>Meaning </td></tr>
<tr>
<td>1</td><td>(constant)</td><td>Storage order of matrix. Use the ML_BLAS_STORAGE macro to pass the correct value. </td></tr>
<tr>
<td>2-3</td><td>(constant)</td><td>Whether or not the A and B (respectively) matrices should be transposed before multiplication. Pass CblasNoTrans to avoid transpose. </td></tr>
<tr>
<td>4</td><td>integer</td><td>The number of rows in the A matrix. </td></tr>
<tr>
<td>5</td><td>integer</td><td>The number of columns in the B matrix. </td></tr>
<tr>
<td>6</td><td>integer</td><td>The number of columns in the A matrix. </td></tr>
<tr>
<td>7</td><td>double</td><td>A scalar to multiply by during computation. </td></tr>
<tr>
<td>8</td><td>double *</td><td>The data array for the A matrix. </td></tr>
<tr>
<td>9</td><td>integer</td><td>The major stride for the A matrix. </td></tr>
<tr>
<td>10</td><td>double *</td><td>The data array for the B matrix. </td></tr>
<tr>
<td>11</td><td>integer</td><td>The major stride for the B matrix. </td></tr>
<tr>
<td>12</td><td>double</td><td>A scalar to multiply C by during the computation. </td></tr>
<tr>
<td>13</td><td>double *</td><td>The data array for the C matrix (output). </td></tr>
<tr>
<td>14</td><td>integer</td><td>The major stride for the C matrix. </td></tr>
</table>
<p>
Looking at the above list, then, we see that despite the large number of parameters the function call will actually be reasonably straightforward. First, we create an output matrix, C, of the appropriate size: <pre><div>
<a class="el" href="a00006.html">ml_matrix</a> C(A.rows(),B.cols());
</pre></div> Now that we have that, we can call cblas_dgemm to do the work. <pre><div>
cblas_dgemm(ML_BLAS_STORAGE,CblasNoTrans,CBlasNoTrans,
            A.rows(),B.cols(),A.rows(),
            1.0,A.raw_data(),A.data_stride(),
            B.raw_data(),B.data_stride(),
            0.0,C.raw_data(),C.data_stride());
</pre></div> Putting everything together, we can produce the whole function: <pre><div>
<a class="el" href="a00006.html">ml_matrix</a> matrix_multiply(const ml_matrix &amp;A,const ml_matrix &amp;B)
{
    <a class="el" href="a00006.html">ml_matrix</a> C(A.rows(),B.cols());
    cblas_dgemm(ML_BLAS_STORAGE,CblasNoTrans,CBlasNoTrans,
                A.rows(),B.cols(),A.rows(),
                1.0,A.raw_data(),A.data_stride(),
                B.raw_data(),B.data_stride(),
                0.0,C.raw_data(),C.data_stride());
    return C;
}
</pre></div> The above function does no error checking, of course, but when inputs are assumed to be valid it will properly return the result A*B by way of BLAS matrix multiplication calculations. </body>
</html>
